<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-01-07 Fri 14:37 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Types in TypeScript</title>
<meta name="generator" content="Org mode">
<link rel="stylesheet" href="/org.css" type="text/css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">Types in TypeScript</h1>
<p>
<i>This blog post is written on the assumption that you have a working knowledge of TypeScript but have come to it from a strongly typed language. If that isn't true, it might not help you very much.</i>
</p>

<div id="outline-container-org7da91b8" class="outline-2">
<h2 id="org7da91b8">These are not the types you are looking for</h2>
<div class="outline-text-2" id="text-org7da91b8">
<p>
If you're used to writing code in other strongly typed languages, TypeScript's compiler can have a few surprises ready for you. Sometimes it needs more information than you expect to decide what type something is, or could be. And sometimes it compiles code that you think you've written types to make illegal. This is the story of one such piece of code (simplified) and the epiphany about TypeScript it led me to.
</p>
</div>
</div>

<div id="outline-container-orgee1b759" class="outline-2">
<h2 id="orgee1b759">The code</h2>
<div class="outline-text-2" id="text-orgee1b759">
<p>
I'm writing some code to help make defining GraphQL resolvers a type safe experience. Earlier feedback for the win. You don't really need to know the details of GQL to follow this example though; all you need to know is that I have a type for defining the configuration of a resolver, and once certain information is supplied, I know the config is valid.
</p>

<p>
Let's have a look at some code:
</p>

<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #96dd3b;">type</span> <span style="color: #ead47a;">ConfigValid</span> = <span style="color: #91bb9e;">"valid"</span> | <span style="color: #91bb9e;">"invalid"</span>

<span style="color: #96dd3b;">class</span> <span style="color: #ead47a;">Config</span>&lt;<span style="color: #ead47a;">T</span> <span style="color: #96dd3b;">extends</span> <span style="color: #ead47a;">ConfigValid</span>&gt; <span style="color: #8c8c8c;">{</span>
  <span style="color: #96dd3b;">private</span> myConfig: <span style="color: #96dd3b;">string</span> | <span style="color: #497958;">null</span> = <span style="color: #497958;">null</span>

  <span style="color: #96dd3b;">private</span> <span style="color: #96dd3b;">constructor</span><span style="color: #93a8c6;">()</span> <span style="color: #93a8c6;">{}</span>

  <span style="color: #96dd3b;">public</span> <span style="color: #96dd3b;">static</span> <span style="color: #fec758;">make</span><span style="color: #93a8c6;">()</span>: <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"invalid"</span>&gt; <span style="color: #93a8c6;">{</span>
    <span style="color: #96dd3b;">return</span> <span style="color: #96dd3b;">new</span> <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"invalid"</span>&gt;<span style="color: #b0b1a3;">()</span>
  <span style="color: #93a8c6;">}</span>

  <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">I want this function to only accept valid configurations, and I want to</span>
  <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">check if they are valid *at compile time*</span>
  <span style="color: #96dd3b;">public</span> <span style="color: #96dd3b;">static</span> <span style="color: #fec758;">build</span><span style="color: #93a8c6;">(</span>config: <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"valid"</span>&gt;<span style="color: #93a8c6;">)</span> <span style="color: #93a8c6;">{</span>
    <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">do stuff!</span>
    <span style="color: #ead47a;">console</span>.<span style="color: #fec758;">log</span><span style="color: #b0b1a3;">(</span>config.myConfig<span style="color: #b0b1a3;">)</span>
  <span style="color: #93a8c6;">}</span>
<span style="color: #8c8c8c;">}</span>
</pre>
</div>

<p>
Pop quiz: <code>Config.make</code> always return a <code>Config&lt;"invalid"&gt;</code>, and <code>Config.build</code> only takes a <code>Config&lt;"valid"&gt;</code>. Will the code <code>Config.build(Config.make())</code> compile or not?
</p>

<p>
Given I'm asking, you've probably guessed that it <b>does</b> compile, breaking the intuition of all of your strongly typed language experience. The actually interesting bit is&#x2026; why?!
</p>
</div>
</div>

<div id="outline-container-org6e1194a" class="outline-2">
<h2 id="org6e1194a">What actually <span class="underline">is</span> TypeScript anyway?</h2>
<div class="outline-text-2" id="text-org6e1194a">
<p>
Don't get whiplash, I'm going somewhere with this.
</p>

<p>
What is TypeScript?
</p>

<p>
Let's hit the <a href="https://www.typescriptlang.org/">TypeScript website</a>. It starts with "TypeScript is JavaScript with syntax for types", and then continues with "TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale". 
</p>

<p>
To my way of thinking, that first quote looks accurate. The second is a lie.
</p>

<p>
Okay, okay: "strongly typed" has <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">"no precise technical definition"</a> so you can argue that it's half true; I wouldn't agree, given the code above, but you can argue it. But what I'm really calling a lie is the statement that TypeScript is a programming language. I would instead argue that TypeScript is an inline theorem prover for JavaScript. Anything that <b>does</b> anything in your code is really JavaScript - after all, TypeScript compiles to JavaScript, and all your lovely types are erased.
</p>

<p>
All of the actual <i>TypeScript</i> in your code (rather than JavaScript) is just trying to prove that your code is correct, and TypeScript has been designed to make that as easy as possible when dealing with existing (untyped) JavaScript.
</p>
</div>
</div>

<div id="outline-container-orge996f20" class="outline-2">
<h2 id="orge996f20">Erm&#x2026; what's this got to do with the code above?</h2>
<div class="outline-text-2" id="text-orge996f20">
<p>
We're not there yet. Stage 2 in our journey is structural typing.
</p>

<p>
Most strongly typed programming languages use "nominal" typing. Roughly, it's the "name" of the type that matters and if you give two types two different names (not aliases, actual different names), the compiler will keep track of which one you use where and treat them as different things - <i>even if they hold exactly the same data</i>.
</p>

<p>
So if, for example, F# - the following two types are not the same, and a function that accepts one will not accept the other:
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #96dd3b;">type</span> <span style="color: #ead47a;">FirstRecord</span> = <span style="color: #8c8c8c;">{</span>
    name: <span style="color: #ead47a;">string</span>
<span style="color: #8c8c8c;">}</span>

<span style="color: #96dd3b;">type</span> <span style="color: #ead47a;">SecondRecord</span> = <span style="color: #8c8c8c;">{</span>
    name: <span style="color: #ead47a;">string</span>
<span style="color: #8c8c8c;">}</span>

<span style="color: #96dd3b;">let</span> <span style="color: #fec758;">withFirstRecord</span> <span style="color: #8c8c8c;">(</span><span style="color: #497958;">record</span>: <span style="color: #ead47a;">FirstRecord</span><span style="color: #8c8c8c;">)</span> =
  record.name
</pre>
</div>

<p>
Trying to send a record of <code>SecondRecord</code> to <code>withFirstRecord</code> would be a compile time error. Now, in F# there's an alternative; this function will accept any type with a member called <code>name</code>:
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span style="color: #96dd3b;">let</span> <span style="color: #96dd3b;">inline</span> <span style="color: #fec758;">withName</span> <span style="color: #497958;">arg</span> =
  <span style="color: #8c8c8c;">(</span>^a : <span style="color: #93a8c6;">(</span><span style="color: #96dd3b;">member</span> <span style="color: #fec758;">name</span> : <span style="color: #ead47a;">string</span><span style="color: #93a8c6;">)</span> arg<span style="color: #8c8c8c;">)</span>
</pre>
</div>

<p>
Notice a few things here:
</p>

<ul class="org-ul">
<li>That syntax is horrific; turns out this is a deliberate choice to discourage overuse (see the rest of the bullets for why)</li>
<li>I had to add the <code>inline</code> keyword to get it to compile. This literally means that in each place this method is used, the compiler will inline a version that uses the type inferred in that location in the code base. This can be good or bad.</li>
<li>You can probably imagine that the error messages from this type of code become explosively unreadable if you nest several layers of functions using this technique, as the constraints start to grow. F# can no longer tell you "you need to give my a <code>FirstRecord</code>"; instead it has to resort to "here's a list of constraints, find me something that meets them all."</li>
</ul>

<p>
This is structural typing, checking types based on the type of data that they hold. And here we wrap back around to TypeScript. <i>What</i> are we comparing to see if things are structurally compatible?
</p>

<p>
In F#, we're comparing the <span class="underline">type definition</span> to the constraints. But in TypeScript, we're comparing the <span class="underline">JavaScript representation of the type</span> to the constraints <i>because TypeScript exists to make JavaScript safer</i>, not to be a programming language in its own right.
</p>
</div>
</div>

<div id="outline-container-org8f80b60" class="outline-2">
<h2 id="org8f80b60">The mystery resolved</h2>
<div class="outline-text-2" id="text-org8f80b60">
<p>
Back to our code:   
</p>

<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #96dd3b;">type</span> <span style="color: #ead47a;">ConfigValid</span> = <span style="color: #91bb9e;">"valid"</span> | <span style="color: #91bb9e;">"invalid"</span>

<span style="color: #96dd3b;">class</span> <span style="color: #ead47a;">Config</span>&lt;<span style="color: #ead47a;">T</span> <span style="color: #96dd3b;">extends</span> <span style="color: #ead47a;">ConfigValid</span>&gt; <span style="color: #8c8c8c;">{</span>
  <span style="color: #96dd3b;">private</span> myConfig: <span style="color: #96dd3b;">string</span> | <span style="color: #497958;">null</span> = <span style="color: #497958;">null</span>

  <span style="color: #96dd3b;">private</span> <span style="color: #96dd3b;">constructor</span><span style="color: #93a8c6;">()</span> <span style="color: #93a8c6;">{}</span>

  <span style="color: #96dd3b;">public</span> <span style="color: #96dd3b;">static</span> <span style="color: #fec758;">make</span><span style="color: #93a8c6;">()</span>: <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"invalid"</span>&gt; <span style="color: #93a8c6;">{</span>
    <span style="color: #96dd3b;">return</span> <span style="color: #96dd3b;">new</span> <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"invalid"</span>&gt;<span style="color: #b0b1a3;">()</span>
  <span style="color: #93a8c6;">}</span>

  <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">I want this function to only accept valid configurations, and I want to</span>
  <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">check if they are valid *at compile time*</span>
  <span style="color: #96dd3b;">public</span> <span style="color: #96dd3b;">static</span> <span style="color: #fec758;">build</span><span style="color: #93a8c6;">(</span>config: <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"valid"</span>&gt;<span style="color: #93a8c6;">)</span> <span style="color: #93a8c6;">{</span>
    <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">do stuff!</span>
    <span style="color: #ead47a;">console</span>.<span style="color: #fec758;">log</span><span style="color: #b0b1a3;">(</span>config.myConfig<span style="color: #b0b1a3;">)</span>
  <span style="color: #93a8c6;">}</span>
<span style="color: #8c8c8c;">}</span>
</pre>
</div>

<p>
What is the difference between the JavaScript representations of <code>Config&lt;"invalid"&gt;</code> and <code>Config&lt;"valid"&gt;</code>?
</p>

<p>
Answer: nothing.
</p>

<p>
The generic parameter on the type is not used or stored at runtime (i.e. in JavaScript) on <code>Config</code>, and therefore it gets completely erased when we compile to JavaScript. Suddenly, it becomes no surprise that the compiler is perfectly happy to allow the use of <code>Config&lt;"invalid"&gt;</code> anywhere we specify <code>Config&lt;"valid"&gt;</code> - by TypeScript's standards they are structurally equivalent.
</p>
</div>
</div>

<div id="outline-container-org343cc15" class="outline-2">
<h2 id="org343cc15">But: the safety?!</h2>
<div class="outline-text-2" id="text-org343cc15">
<p>
Okay, so the code above doesn't work. But now we know what the problem actually is, so&#x2026; let's fix it!
</p>

<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #96dd3b;">type</span> <span style="color: #ead47a;">ConfigValid</span> = <span style="color: #91bb9e;">"valid"</span> | <span style="color: #91bb9e;">"invalid"</span>

<span style="color: #96dd3b;">class</span> <span style="color: #ead47a;">Config</span>&lt;<span style="color: #ead47a;">T</span> <span style="color: #96dd3b;">extends</span> <span style="color: #ead47a;">ConfigValid</span>&gt; <span style="color: #8c8c8c;">{</span>
  <span style="color: #96dd3b;">private</span> myConfig: <span style="color: #96dd3b;">string</span> | <span style="color: #497958;">null</span> = <span style="color: #497958;">null</span>
  <span style="color: #96dd3b;">private</span> _isValid: T

  <span style="color: #96dd3b;">private</span> <span style="color: #96dd3b;">constructor</span><span style="color: #93a8c6;">(</span>isValid: T<span style="color: #93a8c6;">)</span> <span style="color: #93a8c6;">{</span>
    <span style="color: #96dd3b;">this</span>._isValid = isValid
  <span style="color: #93a8c6;">}</span>

  <span style="color: #96dd3b;">public</span> <span style="color: #96dd3b;">static</span> <span style="color: #fec758;">make</span><span style="color: #93a8c6;">()</span>: <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"invalid"</span>&gt; <span style="color: #93a8c6;">{</span>
    <span style="color: #96dd3b;">return</span> <span style="color: #96dd3b;">new</span> <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"invalid"</span>&gt;<span style="color: #b0b1a3;">(</span><span style="color: #91bb9e;">"invalid"</span><span style="color: #b0b1a3;">)</span>
  <span style="color: #93a8c6;">}</span>

  <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">I want this function to only accept valid configurations, and I want to</span>
  <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">check if they are valid *at compile time*</span>
  <span style="color: #96dd3b;">public</span> <span style="color: #96dd3b;">static</span> <span style="color: #fec758;">build</span><span style="color: #93a8c6;">(</span>config: <span style="color: #ead47a;">Config</span>&lt;<span style="color: #91bb9e;">"valid"</span>&gt;<span style="color: #93a8c6;">)</span> <span style="color: #93a8c6;">{</span>
    <span style="color: #245032; font-style: italic;">// </span><span style="color: #245032; font-style: italic;">do stuff!</span>
    <span style="color: #ead47a;">console</span>.<span style="color: #fec758;">log</span><span style="color: #b0b1a3;">(</span>config.myConfig<span style="color: #b0b1a3;">)</span>
  <span style="color: #93a8c6;">}</span>
<span style="color: #8c8c8c;">}</span>
</pre>
</div>

<p>
You see that <code>_isValid</code> field? Now we're storing a value in that field, and that value will exist at runtime in the compiled JavaScript. Now TypeScript cares about it, and now we can call~Config.build~ safe in the knowledge it will only take a valid configuration instance.
</p>
</div>
</div>

<div id="outline-container-orgb537b45" class="outline-2">
<h2 id="orgb537b45">That's a wrap</h2>
<div class="outline-text-2" id="text-orgb537b45">
<p>
I hope you've enjoyed this little journey into making<a href="https://blog.janestreet.com/effective-ml-revisited/"> making illegal states unrepresentable</a>, and if you think you could enjoy this kind of thing (or even using the results to just build stuff!) I'm currently working with Blissfully and we're <a href="https://www.blissfully.com/careers/">currently hiring</a> (it says backend developers, but we're also hiring for our Elm frontend where making illegal states unrepresentable is even easier&#x2026;).
</p>
</div>
</div>
</div>
</body>
</html>
