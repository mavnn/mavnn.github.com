<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-09-16 Tue 13:18 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Log in, log out: Dev Journal 4 (part 2)</title>
<meta name="author" content="Michael Newton" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="/org.css">
<script src="/htmx.min.js"></script>
</head>
<body hx-boost="true">
<div id="org-div-home-and-up"><span class="home-text"><a accesskey="H" href="/">HOME</span><img class="home-logo" src="http://blog.mavnn.co.uk/images/swirl.svg" /></a></div><div id="content" class="container">
<header>
<h1 class="title">Log in, log out: Dev Journal 4 (part 2)</h1>
</header><blockquote>
<p>
This post is the second half of a two part update in the "Dev Journal" series. <a href="../../../2024/03/01/dev_journal_4.html">The first half</a> talks about adding dependencies to the project on postgresql and the Marten event store library, which we'll look at using in this post. <a href="../../../2024/01/31/dev-journal-1.html">Part 1</a> contains the series index, while the <a href="https://gitlab.com/mavnn/caldance/-/commits/DevJournal4?ref_type=tags">DevJournal4</a> tag for the CalDance project in GitLab holds the state of the repository as described here.
</p>
</blockquote>

<p>
So. We have an event store. Our website is going to have users. How do we go about user management?
</p>
<div id="outline-container-org6a7d3c8" class="outline-2">
<h2 id="org6a7d3c8">Where's the cheese?</h2>
<div class="outline-text-2" id="text-org6a7d3c8">
<p>
To borrow a term from domain driven design, this sounds like a "bounded context" within our system. Other parts of the code may care about certain events happening related to users (users being created, that kind of thing), but they probably shouldn't know or care about how the internals of "a user" work or what it takes to authenticate a user.
</p>

<p>
There are as many ways of organizing your code as there are grains of sand on the beach, but fundamentally all of the ones that help are about choosing where to have boundaries in your code base.
</p>

<p>
We are going to have three horizontal slices; shared library code, domain logic (our "business" code), and execution environment. Vertically we're going to slice the domain logic by bounded context - of which, admittedly, we only have one at the moment.
</p>

<p>
We end up with something like (things further down the table depend on the things above):
</p>

<!-- This HTML table template is generated by emacs 30.1 -->
<table border="1">
  <tr>
    <td colspan="2" align="left" valign="top">
      &nbsp;Http&nbsp;Handler&nbsp;abstraction,&nbsp;UI&nbsp;components&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;User&nbsp;domain&nbsp;logic&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Things&nbsp;users&nbsp;do&nbsp;domain&nbsp;logic&nbsp;
    </td>
  </tr>
  <tr>
    <td colspan="2" align="left" valign="top">
      &nbsp;Read&nbsp;configuration&nbsp;files,&nbsp;start&nbsp;the&nbsp;web&nbsp;server&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
</table>

<p>
You'll notice that this doesn't group the code by the technical task the code is trying to achieve, a pattern you'll often find in example project templates where you'll end up with a "Controllers" directory and a "Views" directory. It's also not an organization along "clean/hexagon/ports and adapters" lines with a strict demarcation between code that speaks to the outside world achieved via interfaces and abstractions.
</p>

<p>
It's not that I feel that either of those patterns has no merit (although I feel like the main driver of the first pattern is that you can suggest it even for projects you <i>know nothing about</i> which is a useful property when writing templates and dispensing nuggets of wisdom at conferences about the <b>one true way</b> to organize code). But I do feel that for the vast majority of code bases, it is a far bigger gain to productivity to be able to co-locate code by <i>purpose</i> than by <i>type</i>.
</p>

<p>
Let's face it: while you sometimes pick up a story/card/work ticket that requires you to go and change all the controllers (normally during dependency upgrades), or replace all the database interface implementations (you're about to have a long few months), it is much more likely on a day to day basis that you're trying to add a new field to the data we store about users, and you want to update the data store, business logic, and UI of <i>users</i> to be able to do that. Taking this logic to its logical extremes leads you towards microservices - but that starts to bring in a different type of complexity of its own.
</p>

<p>
All of this to say: there's now a folder called <code>Domain</code> which holds our new, shiny, user management code in a file called: <i>drumroll, please</i> <code>User.fs</code>. Let's have a look at it in detail.
</p>
</div>
</div>
<div id="outline-container-org52673bd" class="outline-2">
<h2 id="org52673bd">The cheese. We have found it.</h2>
<div class="outline-text-2" id="text-org52673bd">
<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">module</span> <span class="org-type">Mavnn.CalDance.Domain.User</span>

<span class="org-keyword">open</span> <span class="org-type">Falco</span>
<span class="org-keyword">open</span> <span class="org-type">Falco.Routing</span>
<span class="org-keyword">open</span> <span class="org-type">Falco.Markup</span>
<span class="org-keyword">open</span> <span class="org-type">Falco.Security</span>
<span class="org-keyword">open</span> <span class="org-type">Marten</span>
<span class="org-keyword">open</span> <span class="org-type">Marten.Events.Aggregation</span>
<span class="org-keyword">open</span> <span class="org-type">Marten.Events.Projections</span>
<span class="org-keyword">open</span> <span class="org-type">Mavnn.CalDance</span>
<span class="org-keyword">open</span> <span class="org-type">Mavnn.CalDance.Routing</span>
<span class="org-keyword">open</span> <span class="org-type">System.Security.Claims</span>
<span class="org-keyword">open</span> <span class="org-type">Microsoft.AspNetCore.Identity</span>
</pre>
</div>

<p>
As just mentioned, this module is going to be responsible for the whole vertical slice of the application for user management, so we start by including everything we need from the data store (<code>Marten</code>) through to the UI (<code>Falco.Markup</code>). We could have created sub modules within a Users folder if needed, but the module is only ~300 lines long so I haven't split it up (yet).
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">type</span> <span class="org-type">User</span> = { id: <span class="org-type">System.</span>Guid; username: <span class="org-type">string</span> }

<span class="org-keyword">type</span> <span class="org-type">UserState</span> =
  <span class="org-fsharp-ui-operator">|</span> Active
  <span class="org-fsharp-ui-operator">|</span> Disabled

<span class="org-preprocessor">[&lt;CLIMutable&gt;]</span>
<span class="org-keyword">type</span> <span class="org-type">UserRecord</span> =
  { Id: <span class="org-type">System.</span>Guid
    Username: <span class="org-type">string</span>
    PasswordHash: <span class="org-type">string</span>
    State: <span class="org-type">UserState</span> }

<span class="org-keyword">type</span> <span class="org-type">UserEvent</span> =
  <span class="org-fsharp-ui-operator">|</span> Created <span class="org-keyword">of</span> UserRecord
  <span class="org-fsharp-ui-operator">|</span> PasswordChanged <span class="org-keyword">of</span> passwordHash: <span class="org-type">string</span>
  <span class="org-fsharp-ui-operator">|</span> Disabled
</pre>
</div>

<p>
Next we define a few data types that represent our users, and the events that can happen to them over time. This is important because we are "event sourcing" the state of our users, meaning that the golden source of truth for what state a user is in is defined by what events have happened to them so far. The two representations of the user represent what we care about in the running system (the main <code>User</code> type) and what we need to store about them on disk (the <code>UserRecord</code> type); in general we would expect that other modules <i>might</i> make use of the <code>User</code> type but in general they should not make use of the <code>UserRecord</code> type. Its an open question in my mind whether it should actually be marked as a private type declaration, but I've erred on the side of leaving it available for now.
</p>

<p>
A minor implementation detail: to try and keep the incremental steps of the project manageable I'm using the default (de)serializers for Marten, which require the object to be deserialized from the data base has a default constructor and mutable fields, which we get from the <code>[&lt;CLIMutable&gt;]</code> attribute. We'll probably remove that going forwards by switching to a serialization strategy that works with immutable F# records.
</p>

<p>
The life cycle of our users is very simple at the moment; a <code>Created</code> event signals that a new, active, user was created. That user can change their password, or they can be marked disabled which effectively ends the lifecycle of the user. There's no way to reactivate a user now, although we could always add one later.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">type</span> <span class="org-type">UserRecordProjection</span>() =
  <span class="org-keyword">inherit</span> <span class="org-type">SingleStreamProjection</span>&lt;UserRecord&gt;()

  <span class="org-keyword">member</span> <span class="org-variable-name">_</span>.<span class="org-function-name">Create</span>(<span class="org-variable-name">userEvent</span>, <span class="org-variable-name">metadata</span>: <span class="org-type">Events.</span><span class="org-variable-name">IEvent</span>) =
    <span class="org-keyword">match</span> userEvent <span class="org-keyword">with</span>
    <span class="org-fsharp-ui-operator">|</span> Created user -&gt; user
    <span class="org-fsharp-ui-operator">|</span> _ -&gt;
      <span class="org-comment-delimiter">// </span><span class="org-comment">We should always receive a created event</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">first so this shouldn't ever happen...</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">...but it might, and we don't want to throw</span>
      <span class="org-comment-delimiter">// </span><span class="org-comment">in projections.</span>
      { Id = metadata.Id
        Username = <span class="org-string">""</span>
        PasswordHash = <span class="org-string">""</span>
        State = UserState.Disabled }


  <span class="org-keyword">member</span> <span class="org-variable-name">_</span>.<span class="org-function-name">Apply</span>(<span class="org-variable-name">userEvent</span>, <span class="org-variable-name">userRecord</span>: <span class="org-type">UserRecord</span>) =
    task {

      <span class="org-keyword">match</span> userEvent <span class="org-keyword">with</span>
      <span class="org-fsharp-ui-operator">|</span> Created _ -&gt;
        <span class="org-comment-delimiter">// </span><span class="org-comment">Should never occur after the first event in the stream</span>
        <span class="org-comment-delimiter">// </span><span class="org-comment">so we ignore duplicates</span>
        <span class="org-keyword">return</span> userRecord
      <span class="org-fsharp-ui-operator">|</span> PasswordChanged passwordHash -&gt;
        <span class="org-keyword">match</span> userRecord <span class="org-keyword">with</span>
        <span class="org-fsharp-ui-operator">|</span> { State = UserState.Disabled } -&gt;
          <span class="org-comment-delimiter">// </span><span class="org-comment">Don't update password of disabled users</span>
          <span class="org-keyword">return</span> userRecord
        <span class="org-fsharp-ui-operator">|</span> user -&gt;
          <span class="org-keyword">return</span>
            { user <span class="org-keyword">with</span>
                PasswordHash = passwordHash }
      <span class="org-fsharp-ui-operator">|</span> Disabled -&gt;
        <span class="org-keyword">match</span> userRecord <span class="org-keyword">with</span>
        <span class="org-fsharp-ui-operator">|</span> { State = UserState.Disabled } -&gt;
          <span class="org-keyword">return</span> userRecord
        <span class="org-fsharp-ui-operator">|</span> { State = Active } -&gt;
          <span class="org-keyword">return</span>
            { userRecord <span class="org-keyword">with</span>
                State = UserState.Disabled }
    }
</pre>
</div>

<p>
<code>Marten</code> leans heavily into the code reflection capabilities of the dotnet framework, allowing us to configure our data store in terms of the in program types we want it to store. A "projection" in event sourcing is the logic which takes a list of events (our base line source of truth) and turns it into a current state, so this class defines a projection that will create and/or update <code>UserRecord</code> data in Marten's document store (we know it does this because it implements the <code>SingleStreamProjection&lt;UserRecord&gt;</code> interface). It will project <i>from</i> events of the <code>UserEvent</code> type, because that is the type of the first argument of the <code>Create</code> and <code>Apply</code> methods we have supplied.
</p>

<p>
There are a few conventions we need to follow here to allow for this minimalist a configuration. Our current state type <i>must</i> have an <code>Id</code> (or <code>id</code>) field of type string, uuid, or integer. And when an event matching the signature of our projection is pushed to a stream with an ID, the resulting update to the current status type must produce a document with the same ID as the stream ID.
</p>

<p>
We're treating our records as immutable objects (because we're planning to make them immutable going forward), so our create and apply methods return a <code>Task&lt;UserRecord&gt;</code>; if the document type was mutable we would also have the options of mutating it in place and returning void.
</p>

<p>
With that explanation out of the way, hopefully the state machine that represents our user life cycle is clear in the code above.
</p>

<p>
Now that we can store information about our users, and update them based on what is happening to them, it's time to start implementing the actual responsibilities of the module. We're keeping things minimal to get started, so we'll implement only the three things we <i>really</i> need: sign up, log in, and log out.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">type</span> <span class="org-type">LoginFormData</span> = { username: <span class="org-type">string</span>; password: <span class="org-type">string</span> }

<span class="org-keyword">let</span> <span class="org-function-name">findUserRecord</span> (<span class="org-variable-name">username</span>: <span class="org-type">string</span>) =
  Marten.withMarten (<span class="org-keyword">fun</span> <span class="org-variable-name">marten</span> -&gt;
    marten
      .Query&lt;UserRecord&gt;()
      .SingleOrDefaultAsync(<span class="org-keyword">fun</span> <span class="org-variable-name">ur</span> -&gt;
        ur.Username = username))
  <span class="org-fsharp-ui-operator">|&gt;</span> Handler.map Marten.returnOption

<span class="org-keyword">let</span> <span class="org-variable-name">loginRoute</span> = RouteDef.literalSection <span class="org-string">"/login"</span>
<span class="org-keyword">let</span> <span class="org-variable-name">logoutRoute</span> = RouteDef.literalSection <span class="org-string">"/logout"</span>
<span class="org-keyword">let</span> <span class="org-variable-name">signupRoute</span> = RouteDef.literalSection <span class="org-string">"/signup"</span>

<span class="org-keyword">let</span> <span class="org-variable-name">getSessionUser</span>: <span class="org-type">Handler</span><span class="org-fsharp-ui-generic">&lt;User option&gt;</span> =
  Handler.fromCtx (<span class="org-keyword">fun</span> <span class="org-variable-name">ctx</span> -&gt;
    <span class="org-keyword">match</span> ctx.User <span class="org-keyword">with</span>
    <span class="org-fsharp-ui-operator">|</span> <span class="org-keyword">null</span> -&gt; None
    <span class="org-fsharp-ui-operator">|</span> principal -&gt;
      <span class="org-keyword">match</span>
        (System.Guid.TryParse(
          principal.FindFirstValue(<span class="org-string">"userId"</span>)
         ),
         principal.FindFirstValue(<span class="org-string">"name"</span>))
      <span class="org-keyword">with</span>
      <span class="org-fsharp-ui-operator">|</span> ((<span class="org-keyword">false</span>, _), _)
      <span class="org-fsharp-ui-operator">|</span> (_, <span class="org-keyword">null</span>) -&gt; None
      <span class="org-fsharp-ui-operator">|</span> ((<span class="org-keyword">true</span>, id), username) -&gt;
        Some { id = id; username = username })
</pre>
</div>

<p>
A few definitions and helpers start us off; what data a form needs to capture for someone to sign up/log on, what urls exist and are managed by this module, and a couple of helper functions for obtaining a user record and a user session from the current HTTP context (using the <code>Handler</code> type we talked about in the last post).
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-variable-name">loginGetEndpoint</span> =
  Handler.toEndpoint get loginRoute (<span class="org-keyword">fun</span> () -&gt;
    Handler.return' (
      Response.ofHtmlCsrf (<span class="org-keyword">fun</span> <span class="org-variable-name">csrfToken</span> -&gt;
        Elem.html
          []
          [ Elem.body
              []
              [ Elem.form
                  [ Attr.<span class="org-keyword">method</span> <span class="org-string">"post"</span> ]
                  [ Elem.input [ Attr.name <span class="org-string">"username"</span> ]
                    Elem.input [ Attr.name <span class="org-string">"password"</span> ]
                    Xss.antiforgeryInput csrfToken
                    Elem.input
                      [ Attr.type' <span class="org-string">"submit"</span>
                        Attr.value <span class="org-string">"Submit"</span> ] ] ] ])
    ))
</pre>
</div>

<p>
Our first end point is straight forward. When we receive a get request to the login path, we reply with a form containing a token to prevent cross site vulnerabilities and username and password fields.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-keyword">private</span> <span class="org-function-name">makePrincipal</span> <span class="org-variable-name">userRecord</span> =
  <span class="org-keyword">let</span> <span class="org-variable-name">claims</span> =
    [ <span class="org-keyword">new</span> Claim(<span class="org-string">"name"</span>, userRecord.Username)
      <span class="org-keyword">new</span> Claim(<span class="org-string">"userId"</span>, userRecord.Id.ToString()) ]

  <span class="org-keyword">let</span> <span class="org-variable-name">identity</span> = <span class="org-keyword">new</span> ClaimsIdentity(claims, <span class="org-string">"Cookies"</span>)

  <span class="org-keyword">new</span> ClaimsPrincipal(identity)

<span class="org-keyword">let</span> <span class="org-variable-name">passwordHasher</span> = PasswordHasher()

<span class="org-keyword">let</span> <span class="org-function-name">updateUser</span> (<span class="org-variable-name">id</span>: <span class="org-type">System.</span><span class="org-variable-name">Guid</span>, <span class="org-variable-name">events</span>: <span class="org-type">seq</span><span class="org-fsharp-ui-generic">&lt;UserEvent&gt;</span>) =
  handler {
    <span class="org-keyword">do!</span>
      Marten.withMarten (<span class="org-keyword">fun</span> <span class="org-variable-name">marten</span> -&gt;
        task {
          <span class="org-comment-delimiter">// </span><span class="org-comment">explicitly assign this as an array of objects</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">so that Marten chooses the correct method</span>
          <span class="org-comment-delimiter">// </span><span class="org-comment">overload for `Append`</span>
          <span class="org-keyword">let</span> <span class="org-variable-name">eventObjs</span>: <span class="org-type">obj[</span>] =
            Array.ofSeq events <span class="org-fsharp-ui-operator">|&gt;</span> Array.map box

          marten.Events.Append(id, eventObjs) <span class="org-fsharp-ui-operator">|&gt;</span> ignore
          <span class="org-keyword">return!</span> marten.SaveChangesAsync()
        })

    <span class="org-keyword">return!</span>
      Marten.withMarten (<span class="org-keyword">fun</span> <span class="org-variable-name">marten</span> -&gt;
        marten.LoadAsync&lt;UserRecord&gt;(id))
  }
</pre>
</div>

<p>
Our next end point is going to actually handle the form coming in, so it requires a few more helpers. The web framework we're using will handle things like sessions for us, but only if we "buy into" the .NET standard ways of representing a user, in this case using the <code>ClaimsPrincipal</code> type - so we have a helper to map from one of our user records to a claims principal. We initialize a password hasher which will salt and hash our passwords for us (don't roll your own crypto, folks, especially when your language ecosystem has a decent implementation ready for you). And finally we add an other method that works within our HTTP context expressions - <code>updateUser</code> takes the ID of a user and a list of events and returns the updated <code>UserRecord</code>.
</p>

<p>
With all of that in place, we can write the <code>loginPostEndpoint</code>.
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-variable-name">loginPostEndpoint</span> =
  Handler.toEndpoint post loginRoute (<span class="org-keyword">fun</span> () -&gt;
    handler {
      <span class="org-keyword">let!</span> loginData =
        Handler.formDataOrFail
          (Response.withStatusCode 400 &gt;&gt; Response.ofEmpty)
          (<span class="org-keyword">fun</span> <span class="org-variable-name">f</span> -&gt;
            Option.map2
              (<span class="org-keyword">fun</span> <span class="org-variable-name">username</span> <span class="org-variable-name">password</span> -&gt;
                { username = username
                  password = password })
              (f.TryGetStringNonEmpty <span class="org-string">"username"</span>)
              (f.TryGetStringNonEmpty <span class="org-string">"password"</span>))

      <span class="org-keyword">let!</span> userRecord =
        findUserRecord loginData.username
        <span class="org-fsharp-ui-operator">|&gt;</span> Handler.ofOption (
          Response.withStatusCode 403 &gt;&gt; Response.ofEmpty
        )

      <span class="org-keyword">let</span> <span class="org-variable-name">verificationResult</span> =
        passwordHasher.VerifyHashedPassword(
          userRecord,
          userRecord.PasswordHash,
          loginData.password
        )

      <span class="org-keyword">match</span> verificationResult <span class="org-keyword">with</span>
      <span class="org-fsharp-ui-operator">|</span> PasswordVerificationResult.Failed -&gt;
        <span class="org-keyword">return</span>
          (Response.withStatusCode 403 &gt;&gt; Response.ofEmpty)
      <span class="org-fsharp-ui-operator">|</span> PasswordVerificationResult.Success -&gt;
        <span class="org-keyword">return</span>
          Response.signInAndRedirect
            <span class="org-string">"Cookies"</span>
            (makePrincipal userRecord)
            <span class="org-string">"/"</span>
      <span class="org-fsharp-ui-operator">|</span> PasswordVerificationResult.SuccessRehashNeeded -&gt;
        <span class="org-keyword">let!</span> _ =
          updateUser (
            userRecord.Id,
            [ PasswordChanged(
                passwordHasher.HashPassword(
                  userRecord,
                  loginData.password
                )
              ) ]
          )

        <span class="org-keyword">return</span>
          Response.signInAndRedirect
            <span class="org-string">"Cookies"</span>
            (makePrincipal userRecord)
            <span class="org-string">"/"</span>
      <span class="org-fsharp-ui-operator">|</span> _ -&gt;
        <span class="org-keyword">return</span>
          failwithf
            <span class="org-string">"Unknown password verification result type %O"</span>
            verificationResult

    })
</pre>
</div>

<p>
Time to actually use our <code>handler</code> expression in earnest! There is some personal preference in play here, but personally I really like the clear flow of the request we can see happening in this code. We either have the form data we need, or we return a <code>400</code> error. Then we either find a user record with a matching username, or we return a <code>403</code> error (we don't want to reveal whether a username exists or not, so we return the same code as for when the password is incorrect; security +1, helpful error messages to users -1). Then we check the password, and we either return <code>403</code> (if it is wrong) or log you in if it is correct. A minor piece of extra complexity is introduced by the fact that the password hasher may signal that the password is correct but the <i>hash</i> needs updating in storage, a background operation that the user does not need to know about.
</p>

<p>
I'll leave the other end points for the reader to read at their leisure <a href="https://gitlab.com/mavnn/caldance/-/blob/e62126228d63e77834112a193fcb0396f4410bc5/Server/src/Domain/User.fs">on Gitlab</a>, as they are either trivial (<code>logoutEndpoint</code>) or very similar to the log in end points (<code>signupGetEndpoint</code> and <code>signupPostEndpoint</code>).
</p>

<p>
Finally, we get to the end of the module where we export everything that the web server setup code (the bottom layer in my newly christened "julienned domain sandwich" architecture).
</p>

<div class="org-src-container">
<pre class="src src-fsharp"><span class="org-keyword">let</span> <span class="org-variable-name">endpoints</span> =
  [ loginGetEndpoint
    loginPostEndpoint
    logoutEndpoint
    signupGetEndpoint
    signupPostEndpoint ]

<span class="org-keyword">let</span> <span class="org-function-name">martenConfig</span> (<span class="org-variable-name">storeOptions</span>: <span class="org-type">Marten.</span><span class="org-variable-name">StoreOptions</span>) =
  storeOptions.Projections.Add&lt;UserRecordProjection&gt;(
    ProjectionLifecycle.Inline
  )
</pre>
</div>

<p>
At the moment, with only one domain, this is just an adhoc export of the end points we're wanting to add to the webserver and the projections we want to add to <code>Marten</code>. As the project grows, we'll probably add an interface that each of our domain modules will export which will provide to allow a standardized process for consuming the needed configuration. But there's little point trying to proactively create an abstraction over a single example of a pattern.
</p>

<p>
And there you have it; event sourced (basic) user management for our web application. If you have thoughts and questions, drop them as an issue on the <a href="https://gitlab.com/mavnn/caldance/-/blob/e62126228d63e77834112a193fcb0396f4410bc5/Server/src/Domain/User.fs">CalDance repository</a>. I'd love to see example repositories having in depth discussions of when the architecture they suggest is or isn't useful, even if (especially if!) that discussion includes comments critical of the architecture demonstrated.
</p>

<p>
Next up: <a href="../../../2024/03/09/dev_journal_5.html">a round of internal quality control</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer id="my-contacts">
<p hx-boost="false"><a href="https://blog.mavnn.co.uk/rss.xml">RSS</a></p>
<p><a href="https://mastodon.sdf.org/@mavnn">Mastodon</a></p>
<p>Git(<a href="https://github.com/mavnn">Hub</a>|<a href="https://gitlab.com/mavnn">Lab</a>)</p>
</footer>
</div>
</body>
</html>
