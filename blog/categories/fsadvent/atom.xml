<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: FsAdvent | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/fsadvent/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2016-02-29T21:19:35+00:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Angels from the realms of glory]]></title>
    <link href="http://blog.mavnn.co.uk/angels-from-the-realms-of-glory/"/>
    <updated>2015-12-19T12:00:00+00:00</updated>
    <id>http://blog.mavnn.co.uk/angels-from-the-realms-of-glory</id>
    <content type="html"><![CDATA[<blockquote><p>An angel of the Lord appeared to them, and the glory of the Lord shone around them, and they were terrified. <ref><a href="https://www.biblegateway.com/passage/?search=luke+2:9&version=NIV" title="Luke 2:9">Luke 2:9</a></ref></p></blockquote>

<p>It&rsquo;s that time of year again, where the F# community get together to source a collection of weird, wonderful and occasionally useful blog posts on life, the universe and sometimes Christmas.</p>

<p>As mentioned in last years post, I like to go back to the source when it comes to advent posts, so lets dive back into the book of Luke (and learn about agent based programming as we go).</p>

<!-- more -->


<h3>The plan</h3>

<p>We&rsquo;re going to simulate the angelic choir as they sing for the shepherds, although with a
couple of minor limitations. One is I don&rsquo;t feel like dealing with cross platform audio issues
(and don&rsquo;t think I could do the voices justice anyway&hellip;) and the other is that I can&rsquo;t draw
for toffee.</p>

<p>So we&rsquo;re going to simulate a view of the angels from a long way away out of earshot.</p>

<p>The final result should end up looking something like this (your results may vary depending
on console colour scheme, but I&rsquo;d suggest dark background for the best effect!):</p>

<p><img src="http://blog.mavnn.co.uk/images/angels1.gif"/></p>

<h3>Step 1: atomic writes to the console</h3>

<p>If you&rsquo;ve tried to use the <code>System.Console</code> namespace in .net, you&rsquo;ll have discovered a few
things about it. The biggest problem we want to deal with, is that writing a character in colour
to the console is not atomic.</p>

<p>You have to:</p>

<p><code>fsharp
// Set the cursor to the position you want to write
Console.SetCursorPosition(x, y)
// Change the foreground colour to the colour you want
Console.ForegroundColor &lt;- c
// Write the character
Console.Write (string m)
</code></p>

<p>In async code, different threads doing this at the same time will mix these operations up,
as there&rsquo;s no way to know what an other thread is doing with the cursor while you try and
set up your own write.</p>

<p>For this we&rsquo;re going to set up our first agent: the console agent. It will be responsible
for all writes to the screen in our program.</p>

<p>``` fsharp
let (|ConsoleColour|) i =
  if i &lt;= 0 then</p>

<pre><code>ConsoleColor.Black
</code></pre>

<p>  elif i >= 15 then</p>

<pre><code>ConsoleColor.White
</code></pre>

<p>  else</p>

<pre><code>enum i
</code></pre>

<p>let console =
  MailboxProcessor.Start(</p>

<pre><code>fun agent -&gt;
  let rec inner () =
    async {
      let! (x, y, ConsoleColour c, m : char) = agent.Receive()
      Console.SetCursorPosition(x, y)
      Console.ForegroundColor &lt;- c
      Console.Write (string m)
      return! inner () }
  inner ())
</code></pre>

<p>console.Error.Add(fun e &ndash;> printfn &ldquo;%A&rdquo; e.Message)
```</p>

<p>The <code>(|ConsoleColour|)</code> construct is what&rsquo;s called an active pattern. With it, we can pattern
match on any integer and be guaranteed to get a valid ConsoleColor enum out. It also spells
&ldquo;colour&rdquo; correctly :D.</p>

<p>Then we start a <code>MailboxProcessor</code> (the default name for an agent in F#). This agent listens
for messages which consist of: an x coordinate, a y coordinate, an int for colour and a character
to write. The overall agent is implemented as an async block and so will not block a thread while
waiting for messages &ndash; but it will guarantee that it will not start processing the next message
until the current one is finished.</p>

<p>Hey presto! We can now safely write to the console from any thread simply by calling <code>console.Post.</code></p>

<p>We&rsquo;ll try it out by creating some random stationary angels.</p>

<p>First, we&rsquo;ll initialize some infinite sequences of random numbers:</p>

<p>``` fsharp
let seedx, seedy, seedc = 100, 150, 200</p>

<p>let randX = Random(seedx)
let randY = Random(seedy)
let randC = Random(seedc)</p>

<p>let randSeq (rand : Random) min' max' =
  Seq.unfold (fun () &ndash;> Some(rand.Next(min', max'), ())) ()</p>

<p>let xSeq = randSeq randX xZero (width + xZero &ndash; 1)
let ySeq = randSeq randY yZero (height + yZero &ndash; 1)
let cSeq = randSeq randC 0 15
```</p>

<p>Then we&rsquo;ll wrap the write in an async method, and draw our angels across the screen concurrently;
each angel will wait 50 milliseconds per unit across the x axis to give a nice staggered appearance.</p>

<p>You can find a full listing in <a href="https://github.com/mavnn/advent2015/blob/master/advent1.fsx">advent1.fsx</a>. Running it should give you something like this:</p>

<p><img src="http://blog.mavnn.co.uk/images/angels2.gif"/></p>

<blockquote><p>But the angel said to them, “Do not be afraid. I bring you good news that will cause great joy for all the people. Today in the town of David a Savior has been born to you; he is the Messiah, the Lord. This will be a sign to you: You will find a baby wrapped in cloths and lying in a manger.” <ref><a href="https://www.biblegateway.com/passage/?search=luke+2:10-12&version=NIV" title="Luke 2:10-12">Luke 2:10-12</a></ref></p></blockquote>

<h2>Step 2: Add event loop</h2>

<p>Onwards! Time to make our angels move. Following on with the theme, we&rsquo;re going to make an agent
responsible for ticking off each &lsquo;loop&rsquo; of events.</p>

<p>We&rsquo;ll add some safety to our console agent to make sure that writes outside the console don&rsquo;t
cause us issues:</p>

<p>``` fsharp
let width  = Console.WindowWidth
let height = Console.WindowHeight</p>

<p>let xZero  = Console.WindowLeft
let yZero  = Console.WindowTop</p>

<p>let (|ConsoleColour|) i =
  if i &lt;= 0 then</p>

<pre><code>ConsoleColor.Black
</code></pre>

<p>  elif i >= 15 then</p>

<pre><code>ConsoleColor.White
</code></pre>

<p>  else</p>

<pre><code>enum i
</code></pre>

<p>let (|X|) x =
  if x &lt; xZero then</p>

<pre><code>xZero
</code></pre>

<p>  elif x >= width then</p>

<pre><code>width - 1
</code></pre>

<p>  else</p>

<pre><code>x
</code></pre>

<p>let (|Y|) y =
  if y &lt; yZero then</p>

<pre><code>yZero
</code></pre>

<p>  elif y >= height then</p>

<pre><code>height - 1
</code></pre>

<p>  else</p>

<pre><code>y
</code></pre>

<p>let console =
  MailboxProcessor.Start(</p>

<pre><code>fun agent -&gt;
  let rec inner () =
    async {
      let! (X x, Y y, ConsoleColour c, m : char) = agent.Receive()
      Console.SetCursorPosition(x, y)
      Console.ForegroundColor &lt;- c
      Console.Write (string m)
      return! inner () }
  inner ())
</code></pre>

<p>console.Error.Add(fun e &ndash;> printfn &ldquo;%A&rdquo; e.Message)
```</p>

<p>Notice the use of the X and Y active patterns to enforce our domain constraints on the underlying
.net type.</p>

<p>We&rsquo;ll also have some types for keeping track of an angels position and velocity.</p>

<p>``` fsharp
type Vector2 =
  { x : float; y : float }
  static member (+) ({ x = x1; y = y1 }, { x = x2; y = y2 }) =</p>

<pre><code>{ x = x1 + x2; y = y1 + y2 }
</code></pre>

<p>  static member (&ndash;) ({ x = x1; y = y1 }, { x = x2; y = y2 }) =</p>

<pre><code>{ x = x1 - x2; y = y1 - y2 }
</code></pre>

<p>  static member Abs { x = x1; y = y1 } =</p>

<pre><code>x1 * x1 + y1 * y1
|&gt; sqrt
</code></pre>

<p>type AngelInfo =
  { Position : Vector2</p>

<pre><code>Velocity : Vector2 }
</code></pre>

<p>```</p>

<p>Here we&rsquo;ve defined + and &ndash; on a two element vector, and a helper function to calculate the vectors
magnitude.</p>

<p>Now we&rsquo;re ready to set up our event loop agent. I&rsquo;m going to call mine <code>ping</code>.</p>

<p>``` fsharp
type AngelMessage =
  | Init of AsyncReplyChannel<AngelInfo>
  | Next of AngelInfo list * AsyncReplyChannel<AngelInfo></p>

<p>let ping =
  MailboxProcessor.Start(</p>

<pre><code>fun agent -&gt;
  let rec inner (angels : MailboxProcessor&lt;AngelMessage&gt; list) infos =
    async {
      // Ask the angels where they will be next
      let! newInfos =
        angels
        |&gt; List.map (fun angel -&gt; angel.PostAndAsyncReply (fun r -&gt; Next(infos, r)))
        |&gt; Async.Parallel

      let newInfos = newInfos |&gt; List.ofArray

      // Erase old locations
      do!
        infos
        |&gt; List.map (fun { Position = p } -&gt; p)
        |&gt; List.map (fun p -&gt; setAsync (int p.x) (int p.y) 0 ' ')
        |&gt; Async.Parallel
        |&gt; Async.Ignore

      // Draw new locations
      do!
        newInfos
        |&gt; List.map (fun { Position = p } -&gt; p)
        |&gt; List.map (fun p -&gt; setAsync (int p.x) (int p.y) 15 '*')
        |&gt; Async.Parallel
        |&gt; Async.Ignore

      do! Async.Sleep 100
      return! inner angels newInfos
    }
  let init () =
    async {
      // Wait for angels to be passed in
      let! (msg : MailboxProcessor&lt;AngelMessage&gt; list) = agent.Receive()

      let! infos =
        msg
        |&gt; List.map (fun angel -&gt; angel.PostAndAsyncReply Init)
        |&gt; Async.Parallel

      return! inner msg (infos |&gt; List.ofArray)
    }
  init ()
)
</code></pre>

<p>```</p>

<p>This agent is a bit more chunky. If you look down to the end of the body, you&rsquo;ll see it starts
by calling <code>init</code>. This method is responsible for waiting for the initial list of angels that
will populate our night sky. The angels themselves will be agents that listen for the AngelMessage
type.</p>

<p><code>init</code> sends an <code>Init</code> message to each angel, asking it for it&rsquo;s initial position and velocity.
The message consists solely of a reply channel which the angel will use to pass back the information.</p>

<p>Once all the angels have reported in, we pass control to the recursive inner loop. On each round
through, the <code>ping</code> agent asks every angel where it&rsquo;s moving to. It then writes spaces to every square on the console that held an angel last
tick, and finally draws the new positions of every angel.</p>

<p>And most of our infrastructure is in place! Let&rsquo;s test it with a collection of angels that will
start with a random position and velocity and move in a straight line for a while.</p>

<p>``` fsharp
let xSeq  = randSeq randX xZero (width + xZero &ndash; 1)
let ySeq  = randSeq randY yZero (height + yZero &ndash; 1)
let vxSeq = randSeq randX -5 5
let vySeq = randSeq randY -5 5</p>

<p>let createAngel logic angelInfo =
  MailboxProcessor.Start(</p>

<pre><code>fun agent -&gt;
  let rec inner currentInfo =
    async {
      let! msg = agent.Receive()
      return!
        match msg with
        | Init r -&gt;
          r.Reply currentInfo
          inner currentInfo
        | Next (infos, r) -&gt;
          let newInfo = logic currentInfo infos
          r.Reply newInfo
          inner newInfo
    }
  inner angelInfo)
</code></pre>

<p>let angels =
  Seq.zip (Seq.zip xSeq ySeq) (Seq.zip vxSeq vySeq)
  |> Seq.take 10
  |> Seq.map</p>

<pre><code>  (fun ((px, py), (vx, vy)) -&gt;
    { Position = { x = float px; y = float py }; Velocity = { x = float vx; y = float py }})
</code></pre>

<p>  |> Seq.map (createAngel (fun c _ &ndash;> { c with Position = c.Position + c.Velocity }))
  |> Seq.toList</p>

<p>// Start the whole thing off
ping.Post angels</p>

<p>Console.ReadLine()</p>

<p>Console.ForegroundColor &lt;&ndash; ConsoleColor.White
Console.CursorVisible &lt;&ndash; true
```</p>

<p>Each of our angels knows how to report its initial state, and how to apply a function called <code>logic</code> to it&rsquo;s previous state to generate the new position. For testing, the <code>logic</code> we&rsquo;re passing in is just to add its velocity to it&rsquo;s current position each time its asked.</p>

<p>Full listing is in <a href="https://github.com/mavnn/advent2015/blob/master/advent2.fsx">advent2.fsx</a>, and running it should give us something like this:</p>

<p><img src="http://blog.mavnn.co.uk/images/angels3.gif"/></p>

<blockquote><p>Suddenly a great company of the heavenly host appeared with the angel, praising God and saying,</p>

<p>“Glory to God in the highest heaven,
   and on earth peace to those on whom his favor rests.” <ref><a href="https://www.biblegateway.com/passage/?search=luke+2:13-14&version=NIV" title="Luke 2:13-14">Luke 2:13-14</a></ref></p></blockquote>

<h3>Adding some dancing</h3>

<p>But! Angels in straight lines doesn&rsquo;t sound much fun. We&rsquo;ll make our angels a bit more interesting
by implementing a simple <a href="https://en.wikipedia.org/wiki/Boids">boid</a> variant.</p>

<p>First we&rsquo;ll add the ability to specify a colour as part of our angel info (check the full listing for details). We&rsquo;ll also expand the vectors to implement multiplication, division and a magnitude limit.</p>

<p>Then we can add a <code>logic</code> module:</p>

<p>``` fsharp
module Logic =
  let private surrounding radius (us : AngelInfo) (others : AngelInfo list) =</p>

<pre><code>others
|&gt; List.filter (fun a -&gt; Vector2.abs (a.Position - us.Position) &lt; radius)
</code></pre>

<p>  let private desiredVel angels =</p>

<pre><code>angels
|&gt; List.fold
    (fun (v, i) angel -&gt;
      (angel.Velocity + v, i + 1)) ({ x = 0.; y = 0.}, 0)
|&gt; fun (v, i) -&gt;
    match i with
    | 0 -&gt;
      { x = 0.; y = 0. }
    | _ -&gt;
      { x = v.x / float i; y = v.y / float i }
</code></pre>

<p>  let private avoid this angels =</p>

<pre><code>let dodge v =
  { x = 1. / v.x * -1.
    y = 1. / v.y * -1. } * (List.length angels |&gt; float)
match angels with
| [] | [_] -&gt; { x = 0.; y = 0. }
| _ -&gt;
  angels
  |&gt; List.map (fun angel -&gt; angel.Position - this.Position)
  |&gt; List.reduce (+)
  |&gt; dodge
</code></pre>

<p>  let boid midpoint friendRadius dodgeRadius maxAcc maxVel this angels =</p>

<pre><code>let groupVel =
  surrounding friendRadius this angels
  |&gt; desiredVel
  |&gt; Vector2.limit maxVel
let avoidCollision =
  surrounding dodgeRadius this angels
  |&gt; avoid this
  |&gt; Vector2.limit maxVel
let towardsMiddle =
  midpoint - this.Position
  |&gt; Vector2.limit maxVel
let acceleration =
  (groupVel * 0.5 + avoidCollision * 2. + towardsMiddle)
  / 3.
{ this with Position = this.Position + this.Velocity
            Velocity = (this.Velocity + acceleration) |&gt; Vector2.limit maxVel }
</code></pre>

<p>  let stationary this _ =</p>

<pre><code>{ this with Velocity = { x = 0.; y = 0. } }
</code></pre>

<p>```</p>

<p>Nothing super exciting here individually &ndash; we have methods for discovering other angels nearby
(<code>surrounding</code>), the average velocity of a group of angels (<code>desiredVel</code>) and a rough guess
at not running into a group of nearby angels (<code>avoid</code>). All could probably be improved!</p>

<p>Putting it all together, the <code>boid</code> method calculates the acceleration the angel would &ldquo;like&rdquo; to
have to follow all if its rules fully, and then limits that by a specified maximum acceleration.
I played with the weighting of the rules a bit to get something that looked kind of nice, and also
decided to make my life easier by aiming cohesion towards the middle of the screen rather than the
middle of the flock.</p>

<p>Generating our angels is now just a case of partially applying boid with the parameters of our
choice:</p>

<p>``` fsharp
let angels =
  Seq.zip3 (Seq.zip xSeq ySeq) (Seq.zip vxSeq vySeq) cSeq
  |> Seq.take 40
  |> Seq.map</p>

<pre><code>  (fun ((px, py), (vx, vy), c) -&gt;
   { Position = { x = float px; y = float py }
     Velocity = { x = float vx; y = float vy }
     Colour   = c })
</code></pre>

<p>  |> Seq.map (createAngel (Logic.boid midpoint 10. 1. 0.3 1.))
  |> Seq.append</p>

<pre><code>  [(createAngel
     Logic.stationary { Position = midpoint
                        Velocity = { x = 0.; y = 0. }
                        Colour   = 15 })]
</code></pre>

<p>  |> Seq.toList
```</p>

<p>The ones in listing <a href="https://github.com/mavnn/advent2015/blob/master/advent3.fsx">advent3.fsx</a> give something reasonably nice, looking like:</p>

<p><img src="http://blog.mavnn.co.uk/images/angels4.gif"/></p>

<p>One word of warning: there&rsquo;s a bug in the avoidance which I haven&rsquo;t had a chance to track down,
so if you add too many angels they&rsquo;ll all push each other into the top left corner. Oops.</p>

<p>And that&rsquo;s all for now. I hope you enjoyed this brief dive into agent based programming,
and how we can use agents to separate responsibility and protect against unwanted race conditions.</p>

<p>As you can see, this framework allows easy modification of angel logic, and in fact allows for
every angel to have its own implementation without much added complexity &ndash; as long as it replies to
the same messages.</p>

<p>Happy Christmas, and God bless.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modelling Inheritance with Inheritance]]></title>
    <link href="http://blog.mavnn.co.uk/modelling-inheritance-with-inheritance/"/>
    <updated>2014-12-18T12:01:41+00:00</updated>
    <id>http://blog.mavnn.co.uk/modelling-inheritance-with-inheritance</id>
    <content type="html"><![CDATA[<blockquote><p>This post is part of the <a href="https://sergeytihon.wordpress.com/tag/fsadvent/">F# Advent Calendar</a> 2014, which is stuffed full of other interesting posts. Go have a read!</p></blockquote>

<p>Note: This post is epic in length. If you just want to see the final resulting script of much silliness, skip straight to <a href="#conclusion">the conclusion</a>!</p>

<p>Note 2: If you just want to see an example of a sane generated type provider, <a href="https://github.com/mavnn/FPDays.TypeProvider/">the code from my FPDays tutorial</a> is a much better bet.</p>

<p>Note 3: There is a lot of code below. If you&rsquo;re viewing this on a desktop, I suggest collapsing the sidebar to the right otherwise you&rsquo;ll have a lot of horizontal scroll bars. If you&rsquo;re on a mobile device, you might want to bookmark for later.</p>

<p>So&hellip; I&rsquo;ve been playing with generated (not erased) type providers for a bit, and meaning to write something up about them. Most of the documentation out there is for erased type providers, and to be honest they have a lot of advantages in terms of performance.</p>

<p>But they also have two fundamental limitations:</p>

<ul>
<li>You can&rsquo;t used erased F# types in any other .net language</li>
<li>You can&rsquo;t use reflection on erased types (even in F#)</li>
</ul>


<p>So let&rsquo;s see if we can have a play with generated types, and then &ndash; given this is Christmas, and all &ndash; let&rsquo;s see if we can build Jesus' family tree in the .net type system. After all, if you&rsquo;re going to use inheritance to model something, how about modelling inheritance?</p>

<!-- more -->


<blockquote><p>If you need a reminder of type provider basics, check out <a href="http://blog.mavnn.co.uk/type-providers-from-the-ground-up/">Type Providers from the Ground Up</a></p></blockquote>

<p>Let&rsquo;s start with a really basic example of a generative type provider. We&rsquo;ll just create a single type with a static property on it.</p>

<p>First, our input. We&rsquo;re going to grab <a href="https://www.biblegateway.com/passage/?search=matthew+1%3A2-16&amp;version=NIV">the genealogy of Jesus from Matthew</a> and then massage the content just enough that the first name on each line is a &ldquo;parent&rdquo;, and any other names on a line are&hellip; other people. We&rsquo;ll assume they&rsquo;re siblings, although actually not all of them are.</p>

<pre><code>Abraham was the father of Isaac,
Isaac the father of Jacob,
Jacob the father of Judah and his brothers,
Judah the father of Perez and Zerah, whose mother was Tamar,
Perez the father of Hezron,
Hezron the father of Ram,
Ram the father of Amminadab,
... (some other people here) ...
Akim the father of Elihud,
Elihud the father of Eleazar,
Eleazar the father of Matthan,
Matthan the father of Jacob,
Jacob the father of Joseph, the husband of Mary, 
and Mary was the mother of Jesus who is called the Messiah.
</code></pre>

<p>For round one, we&rsquo;re just going to put this string into a type as a property.</p>

<p>Our type provider file looks a bit like this:</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()</p>

<p>```</p>

<p>What&rsquo;s with the <code>#if INTERACTIVE</code> bits? Well, that&rsquo;ll be the subject of another blog post soon; I&rsquo;m doing must of my type provider dev in Vim these days to avoid the Visual Studio restart cycle, so I thought I might as well skip the fsproj file completely.</p>

<p>In the actual provider itself, there&rsquo;s a few new things to note if you&rsquo;ve only previously done erased type provider development.</p>

<p>```fsharp</p>

<pre><code>let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath
</code></pre>

<p>```</p>

<p>Generative type providers, unlike erased type providers, actually pass IL (.net byte code) to the compiler rather than just a quotation. To achieve that, we need to write the IL into an actual assembly that the compiler will then merge into the dll it&rsquo;s compiling.</p>

<p>Let&rsquo;s try that again, slower. The compiler will be building a piece of code that uses your type provider into <code>Output.dll</code>. It will call into your type provider, which needs to write the IL of the type/codes it&rsquo;s generating to disk into <code>Temp.dll</code>. The compiler will then take the IL from <code>Temp.dll</code> and insert it into <code>Output.dll</code>. At this point, we have no further use for <code>Temp.dll</code>, hence why we&rsquo;re using <code>GetTempFileName</code> to get a file in the OS temporary file
folder.</p>

<p>The <code>ProvidedTypes</code> API knows how to create these temporary dlls, so we wrap our filename in the <code>ProvidedAssembly</code> type.</p>

<p>```fsharp</p>

<pre><code>do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>```</p>

<p>We also need to specify which types need adding to the temporary assembly. Here we&rsquo;re specifying that the parameterized type (the one that takes a filename) should be added; on line 46 of the main code you&rsquo;ll see the type generated when a parameter is supplied being added. We also need to tell the type provider where the runtime dll is being created &ndash; fortunately, a helper method works this out for us when given the config item from the type provider constructor.</p>

<p>It&rsquo;s important to note that nested types <em>should not</em> be added to the temporary assembly. That&rsquo;s handled by adding the root.</p>

<p>So, if you compile this code down you can invoke it like this:</p>

<p>```fsharp</p>

<h1>!/usr/bin/env fsharpi</h1>

<p>// Put all of this in a file called something like Families.fsx
// Yes, that hashbang line means if you make it executable it
// will run on linux/mac</p>

<h1>r @&ldquo;AdventProvider.dll&rdquo;</h1>

<p>open AdventProvider
open Advent.Provided</p>

<p>type JesusGenerations = Family&lt;&ldquo;Genealogy.txt&rdquo;></p>

<p>printfn &ldquo;%s&rdquo; JesusGenerations.Raw
```</p>

<p>Excellent! A real, valid .net type. You can only invoke the type provider from F#, but the types generated are usable across the .net language universe &ndash; and reflection works fine.</p>

<p>So&hellip; phase two. Let&rsquo;s see if we can parse something sane out of our plain text mess to turn into types. I&rsquo;m not going to go into this in detail, but because I wanted to avoid the complication of external dependencies I just wrote a very simple regex based parser for this.</p>

<p>Behold! The <code>Parser.fs</code> file:</p>

<p>```fsharp
module Parser
open System.Text.RegularExpressions</p>

<p>type Person =</p>

<pre><code>{
    Name : string
    Heir : Person option
    Others : string list
}
</code></pre>

<p>let namesRegex = Regex(@&ldquo;(?<name>[A-Z][a-z]+)&rdquo;, RegexOptions.Compiled)</p>

<p>let ParseToNames line =</p>

<pre><code>namesRegex.Matches(line)
|&gt; Seq.cast&lt;Match&gt;
|&gt; Seq.map (fun m -&gt; m.Groups.["name"].Value)
|&gt; Seq.filter (fun n -&gt; n &lt;&gt; "King" &amp;&amp; n &lt;&gt; "Messiah" &amp;&amp; n &lt;&gt; "Babylon")
|&gt; Seq.toList
|&gt; function h::t -&gt; h, t | [] -&gt; failwith "No blank lines!"
</code></pre>

<p>let rec NamesToPerson names =</p>

<pre><code>match names with
| [] -&gt; None
| (father,others)::t -&gt;
    let heir =
        match t with
        | [] -&gt; None
        | (heir, _)::_ -&gt; Some heir
    Some {
        Name = father
        Heir = NamesToPerson t
        Others =
            others
            |&gt; List.filter
                (fun c -&gt;
                    match heir with
                    | Some h -&gt; c &lt;&gt; h
                    | None -&gt; true)
    }
</code></pre>

<p>let Parse lines =</p>

<pre><code>lines
|&gt; List.map ParseToNames
|&gt; NamesToPerson
</code></pre>

<p>```</p>

<p>Nb. Never, ever, ever build a parser like this for production code. Treat this as a &ldquo;how not to build a parser&rdquo; example, and go read something like <a href="http://trelford.com/blog/post/parser.aspx">Phil&rsquo;s excellent parsing posts</a> instead.</p>

<p>So&hellip; what can we do this this?</p>

<p>Let&rsquo;s start be parsing our file, and seeing if we can build a nested set of types representing the family tree.</p>

<p>Recursive type building! Go!</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>load &ldquo;Parser.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open Parser</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile
            let input =
                raw
                |&gt; Seq.toList
                |&gt; Parse

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)
            g.SetAttributes (TypeAttributes.Public ||| TypeAttributes.Class)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            let rec personToType (father : ProvidedTypeDefinition) (person : Person) =
                let t = ProvidedTypeDefinition(person.Name, Some (father :&gt; System.Type), IsErased = false)
                t.SetAttributes (TypeAttributes.Class ||| TypeAttributes.Public)
                father.AddMember t
                match person.Heir with
                | Some p -&gt; personToType t p
                | None -&gt; ()

            match input with
            | Some p -&gt;
                personToType g p
            | None -&gt;
                ()

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>It&rsquo;s not looking too bad&hellip; but we&rsquo;re also getting our first hint of trouble to come. The first time I tried to use this provider, I didn&rsquo;t have lines 46 and 55. It turns out that the default attributes of a <code>ProvidedTypeDefinition</code> set the <code>Sealed</code> attribute on the class that&rsquo;s generated. If you then try and build a type that inherits from it, you get an error when you try and consume the types from the provider.</p>

<p>But, hey? We&rsquo;ve worked around that, right? I&rsquo;m sure there&rsquo;s no reason it&rsquo;s set that way by default&hellip;</p>

<p>And: we have types. Lots of types:</p>

<p>```fsharp</p>

<h1>!/usr/bin/env fsharpi</h1>

<h1>r @&ldquo;AdventProvider.dll&rdquo;</h1>

<p>open AdventProvider
open Advent.Provided</p>

<p>type JesusGenerations = Family&lt;&ldquo;Genealogy.txt&rdquo;></p>

<p>printfn &ldquo;%s&rdquo; JesusGenerations.Raw</p>

<p>JesusGenerations.Abraham.Isaac.Jacob.Judah.Perez.Hezron.Ram.Amminadab
// &hellip; there&rsquo;s more where that came from
```</p>

<p>We can even do things like this:</p>

<p>```fsharp
let DescendedFromAbraham (person : JesusGenerations.Abraham) =</p>

<pre><code>true
</code></pre>

<p>```</p>

<p>Compile time family tree checking &ndash; pretty nifty. Except&hellip; when we try and call this function we realise we have a problem. None of these classes have constructors.</p>

<p>Hmmm.</p>

<p>Let&rsquo;s try and add one. Nothing fancy &ndash; just a default constructor.</p>

<p>We&rsquo;ll replace the <code>personToType</code> method with this:</p>

<p>```fsharp
let rec personToType (father : ProvidedTypeDefinition) (person : Person) =</p>

<pre><code>let t = ProvidedTypeDefinition(person.Name, Some (father :&gt; System.Type), IsErased = false)
t.SetAttributes (TypeAttributes.Class ||| TypeAttributes.Public)
let c = ProvidedConstructor([])
c.InvokeCode &lt;-
    fun args -&gt;
        match args with
        | [] -&gt;
            failwith "Generated constructors should always pass the instance as the first argument!"
        | _ -&gt;
            &lt;@@ () @@&gt;
t.AddMember c
father.AddMember t
match person.Heir with
| Some p -&gt; personToType t p
| None -&gt; ()
</code></pre>

<p>```</p>

<p>All looks good. In here you can see one of the first differences between erased and generated type. For a generated type, the first input arg to the constructor is the instance of the type to be initialized &ndash; and the return type of the constructor should be null.</p>

<p>The only problem is that our type provider errors immediately on usage with an &ldquo;Argument cannot be null. Parameter name: obj&rdquo; error. Not immediately informative.</p>

<p>A quick check with a type provider providing a single type later, we can confirm that the constructor above is valid; sounds like we&rsquo;re having issues with the fact that we&rsquo;re inheriting from a provided type. Maybe they&rsquo;re sealed for a reason after all. Still; we&rsquo;re not to be deterred so easily!</p>

<p><em>Cue dramatic music of choice!</em></p>

<p>Taking an guess, we&rsquo;ll assume this might have something to do with the <code>JesusGenerations</code> type not having a constructor; we&rsquo;ll add one and try again and&hellip; no dice. Same error.</p>

<p>Which is round about the time I noticed that provided constructors also have a <code>BaseConstructorCall</code> property. Time for a slightly more invasive rewrite, leaving us an overall type provider that looks like this:</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>load &ldquo;Parser.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open Parser</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile
            let input =
                raw
                |&gt; Seq.toList
                |&gt; Parse

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)
            g.SetAttributes (TypeAttributes.Public ||| TypeAttributes.Class)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            let c = ProvidedConstructor([])
            c.InvokeCode &lt;-
                fun args -&gt;
                    match args with
                    | [] -&gt;
                        failwith "Generated constructors should always pass the instance as the first argument!"
                    | _ -&gt;
                        &lt;@@ () @@&gt;
            g.AddMember c

            let rec personToType (father : ProvidedTypeDefinition) fatherCtor (person : Person) =
                let t = ProvidedTypeDefinition(person.Name, Some (father :&gt; System.Type), IsErased = false)
                t.SetAttributes (TypeAttributes.Class ||| TypeAttributes.Public)
                let c = ProvidedConstructor([])
                c.BaseConstructorCall &lt;- fun args -&gt; (fatherCtor, args)
                c.InvokeCode &lt;-
                    fun args -&gt;
                        match args with
                        | [] -&gt;
                            failwith "Generated constructors should always pass the instance as the first argument!"
                        | _ -&gt;
                            &lt;@@ () @@&gt;
                t.AddMember c
                father.AddMember t
                match person.Heir with
                | Some p -&gt; personToType t c p
                | None -&gt; ()

            match input with
            | Some p -&gt;
                personToType g c p
            | None -&gt;
                ()

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>It all builds, we can reference it&hellip; and then we get:</p>

<pre><code>The type provider 'AdventProvider+AdventProvider' reported an error: User defined subclasses of System.Type are not yet supported
</code></pre>

<p>Hmm. Irritating. Especially as the error message is actually incorrect; we&rsquo;re not subclassing System.Type and we know that that was working correctly as the types were being generated correctly before we tried to add constructors to them. But it looks like we might have hit the limits of what the current type provider implementation allows.</p>

<p>But we&rsquo;re still not quite done yet; let&rsquo;s turn the insanity up a notch.</p>

<p><em>Cue your choice of even more dramatic music or Benny Hill here</em></p>

<p>As well as actual inheritance in .net, we have interfaces which can be used to model inheritance. Let&rsquo;s have a last throw of the dice, and see whether we can create generated interfaces to do compile time ancestry checking.</p>

<p>Adding an <code>Interface</code> at every level turns out to be fairly easy, and it appears we can create generated interfaces &ndash; a useful trick to have up your sleeve. Let&rsquo;s have a look what that looks like:</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>load &ldquo;Parser.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open Parser</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile
            let input =
                raw
                |&gt; Seq.toList
                |&gt; Parse

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            let rec personToType (father : ProvidedTypeDefinition) (fatherInterfaces : System.Type list) (person : Person) =
                let t = ProvidedTypeDefinition(person.Name, Some typeof&lt;obj&gt;, IsErased = false)
                let parentInterface =
                    match fatherInterfaces with
                    | [] -&gt; None
                    | h::_ -&gt; Some h
                let i = ProvidedTypeDefinition("I" + person.Name, None, IsErased = false)
                i.SetAttributes (TypeAttributes.Public ||| TypeAttributes.Interface ||| TypeAttributes.Abstract)
                father.AddMembers [t;i]
                match person.Heir with
                | Some p -&gt; personToType t (i :&gt; System.Type::fatherInterfaces) p
                | None -&gt; ()

            match input with
            | Some p -&gt;
                personToType g [] p
            | None -&gt;
                ()

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>Line 58 and 59 do all the work &ndash; normally an interface has no base type, and we need to reset the type attributes to make the interface look like an interface to the compiler. This all works well &ndash; but doesn&rsquo;t, of course, give us any inheritance. Lets see if we can use those &ldquo;fatherInterfaces&rdquo; I&rsquo;ve fed into the function to get us any closer.</p>

<p>A brief experiment with <code>IDisposable</code> shows us that if we change the base type of the interface to <code>Some typeof&lt;System.IDisposable&gt;</code>, that actually works. Again &ndash; useful type provider knowledge, but doesn&rsquo;t help us here. No dice on using the parent interface as the base type &ndash; we just start getting into more of the problems we were having above inheriting from other generated types.</p>

<p>So let&rsquo;s see what happens if instead we use implement interface instead of trying to inherit the interface; it seems about as reasonable as anything else we&rsquo;re tried so far&hellip;</p>

<p>We&rsquo;ll add this:</p>

<p><code>fsharp
fatherInterfaces
|&gt; List.iter i.AddInterfaceImplementation
</code></p>

<p>after line 59 of the version above and see what happens.</p>

<h2><a name="conclusion"></a> Conclusion</h2>

<p>And suddenly&hellip; hey presto! We can do things like this:</p>

<p>```fsharp</p>

<h1>!/usr/bin/env fsharpi</h1>

<h1>r @&ldquo;AdventProvider.dll&rdquo;</h1>

<p>open AdventProvider
open Advent.Provided</p>

<p>type JesusGenerations = Family&lt;&ldquo;Genealogy.txt&rdquo;></p>

<p>printfn &ldquo;%s&rdquo; (JesusGenerations.Raw.Substring(0, 20) + &ldquo;&hellip;&rdquo;)</p>

<p>let descendentOfAbraham (_ : #JesusGenerations.IAbraham) = true
let descendentOfDavid</p>

<pre><code>    (_ : 
        #JesusGenerations
            .Abraham
            .Isaac
            .Jacob
            .Judah
            .Perez
            .Hezron
            .Ram
            .Amminadab
            .Nahshon
            .Salmon
            .Boaz
            .Obed
            .Jesse
            .IDavid) = true
</code></pre>

<p>// This compiles&hellip;
printfn &ldquo;%A&rdquo; &lt;| descendentOfAbraham ({ new JesusGenerations.Abraham.IIsaac })</p>

<p>// So does this:
printfn &ldquo;%A&rdquo; &lt;|</p>

<pre><code>descendentOfDavid 
    ({ new JesusGenerations
            .Abraham
            .Isaac
            .Jacob
            .Judah
            .Perez
            .Hezron
            .Ram
            .Amminadab
            .Nahshon
            .Salmon
            .Boaz
            .Obed
            .Jesse
            .David
            .Solomon
            .Rehoboam
            .IAbijah })
</code></pre>

<p>// This doesn&rsquo;t &ndash; how cool is that?
(* printfn &ldquo;%A&rdquo; &lt;|</p>

<pre><code>descendentOfDavid ({ new JesusGenerations.Abraham.IIsaac }) *)
</code></pre>

<p>```</p>

<p>Which personally I think is pretty awesome.</p>

<p>There is, unfortunately, only one problem. Whilst we now have compile time propositional logic&hellip; unfortunately our code fails at runtime with a type load error. Whilst the compiler is happy with the IL my random hacking has turned at, apparently the runtime is not.</p>

<p>Maybe next year&hellip;</p>

<p>I hope you enjoyed this random journey down the rabbit hole of type providers; and if you&rsquo;re interested in looking into the genealogy a bit further <a href="http://christianity.about.com/od/biblefactsandlists/a/jesusgenealogy.htm">this article</a> gives a brief overview of a few things, like why we think Jesus has two different genealogies in the bible and how Jewish genealogies didn&rsquo;t always include every generation.</p>

<p>See you next time: and if anyone can get the inheritance to work properly, I&rsquo;ll owe you a beverage of (reasonable) choice!</p>

<p>The code from this blog post can, as normal be found on github in the <a href="https://github.com/mavnn/Advent2014">Advent2014</a> repository.</p>

<p>It&rsquo;s set up to be developed in Vim or Emacs without project files on a nix system, but it will probably play nicely with Visual Studio as well.</p>
]]></content>
  </entry>
  
</feed>
