<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2014-02-27T15:43:07+00:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Type Provider ProTip]]></title>
    <link href="http://blog.mavnn.co.uk/type-provider-protip/"/>
    <updated>2014-01-10T12:15:15+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-provider-protip</id>
    <content type="html"><![CDATA[<p>While type providers are incredibly powerful, the ProvidedTypes api for creating them is sometimes a bit rough around the edges. And not always as functional as you might hope.</p>

<p>At some point I&rsquo;d like to do something about that, but for the moment I&rsquo;m just going to collect a few helpful tips and hints (mostly for own reference).</p>

<p>Tip one is in the case where you have XmlDocs to add to ProvidedTypes, ProvidedMethods and ProvidedProperties; in our case we have an optional description field in our metadata and the boiler plate was getting tiresome.</p>

<p>``` fsharp
let inline addDoc (desc : Descriptor) def =</p>

<pre><code>match desc.Description with
| Some d -&gt;
    (^T : (member AddXmlDoc : string -&gt; unit) (def, d))
| None -&gt; ()
</code></pre>

<p>```</p>

<p>This function takes a <code>Descriptor</code> with a <code>string option</code> Description field and any <code>def</code> with an AddXmlDoc member with the noted signature &ndash; and adds description as the xml doc if it exists.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Providers from the Ground Up]]></title>
    <link href="http://blog.mavnn.co.uk/type-providers-from-the-ground-up/"/>
    <updated>2013-12-05T11:28:00+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-providers-from-the-ground-up</id>
    <content type="html"><![CDATA[<p>In the ground tradition of blog posts as both documentation and augmented memory, I&rsquo;ve just added our first <a href="http://blogs.msdn.com/b/dsyme/archive/2013/01/30/twelve-type-providers-in-pictures.aspx">Type Provider</a> to the code base. Time to write up the details before a) I forget them and b) anyone else needs to modify the code.</p>

<p>So, first things first. Before we get to the actual problem space at hand, let&rsquo;s try and provide a type. Any type&hellip;</p>

<p>1) Create yourself a new Visual Studio F# library project (2012 or up should work).</p>

<p>2a) Install the <a href="https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack/">F# TypeProvider Starter Pack</a> or</p>

<p>2b) add <a href="https://raw.github.com/fsharp/FSharp.Data/master/src/CommonProviderImplementation/ProvidedTypes.fs">ProvidedTypes.fs</a> and <a href="https://raw.github.com/fsharp/FSharp.Data/master/src/CommonProviderImplementation/ProvidedTypes.fsi">ProvidedTypes.fsi</a> to the project as the first couple of files.</p>

<p>In either case, make sure that the .fsi file appears before the .fs file in your project listing, and that both appear before any type provider code &ndash; you will probably have to manually re-order them.</p>

<p>These are provided as code files rather than as compiled dlls due to complications with security and AppDomains when referencing dlls in the type provider assembly. For now just add them in &ndash; you really don&rsquo;t want to be re-creating the code in there by hand.</p>

<p>3) Replace the contents of Library1.fs with something like this:</p>

<p>``` fsharp
module Mavnn.Blog.TypeProvider</p>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices</p>

<p>[<TypeProvider>]
type MavnnProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>So, that&rsquo;s great and it builds. We have a type provider class and an assembly that knows it&rsquo;s a type providing assembly. Unfortunately, it doesn&rsquo;t actually provide any types yet. Let&rsquo;s try it.</p>

<!--more-->


<p>Update Library1.fs in your solution with something that looks like this, and then we&rsquo;ll run through what&rsquo;s going on, and how to test it.</p>

<p>``` fsharp
module Mavnn.Blog.TypeProvider</p>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open System.Reflection</p>

<p>[<TypeProvider>]
type MavnnProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Mavnn.Blog.TypeProvider.Provided"
let asm = Assembly.GetExecutingAssembly()

let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true, 
                                    GetterCode = (fun args -&gt; &lt;@@ "Hello world" @@&gt;))
    myType.AddMember(myProp)
    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>First things first &ndash; it looks like it should provide a class with a static property, but how do we test it?</p>

<p>It turns out it&rsquo;s harder than it looks. If you reference your brand new type provider in Visual Studio, that instance of Visual Studio will promptly lock the dll file. Which means you can&rsquo;t recompile it. So referencing the dll from within the instance of Visual Studio you&rsquo;re using to develop it is a no go.</p>

<p>Fire up a second copy of Visual Studio (you went for the extra RAM option on your hardware, yes?) and create an F# project in it. Add an fsx file that looks something like this:</p>

<p>``` fsharp
// Your path may vary&hellip;</p>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Mavnn.Blog.TypeProvider.dll&rdquo;</h1>

<p>open Mavnn.Blog.TypeProvider.Provided</p>

<p>// Type <code>MyType.MyProperty</code> on next line down.
```</p>

<p>Start typing, and&hellip; hurrah! Intellisense on your new, provided type with static property. Evaluate the script in F# interactive for one of the longest &ldquo;Hello World&rdquo; programs you&rsquo;ve ever seen.</p>

<p><em>You will need to close this instance of Visual Studio every time you want to recompile the type provider.</em></p>

<h2>What&rsquo;s going on here?</h2>

<p>We&rsquo;re declaring a new namespace and detecting the current assembly so we can inject things into it. During our initializing for the type provider, we then add that namespace to the assembly (<code>this.AddNamespace(...)</code>) along with a type created in the slightly (at the moment) misnamed <code>createTypes</code> method.</p>

<p>In <code>createTypes</code> we&rsquo;re first creating a type (<code>MyType</code>) which will be a direct member of the namespace we&rsquo;re creating (we&rsquo;ll get onto nested types shortly), then we&rsquo;re creating a static property and adding it to the type. <code>AddNamespace</code> takes a list of types, so will add the one we have to a list and pass it back.</p>

<p><code>MyType</code>&rsquo;s underlying representation in the CLR has been defined as <code>obj</code>, which means that if you try and access it in a non-F# language it will appear to the compiler as an <code>object</code>.</p>

<p>All well and good&hellip; except for the rather bizarre <code>&lt;@@ ... @@&gt;</code> syntax in our static property. Obviously, in some way it&rsquo;s creating a get method for the property that returns <code>"Hello world"</code>, but how does it do it?</p>

<p>This syntax represents a <a href="http://msdn.microsoft.com/en-us/library/dd233212.aspx">code quotation</a>, and rather than being compiled into your program it will compile to an object that represents an expression.</p>

<p>Did that make your brain hurt? Mine too&hellip; I&rsquo;m not going to go into quotations in great detail here (partly as I don&rsquo;t understand them well enough!) but we&rsquo;ll need to cover a couple of basics.</p>

<p>To give you a flavour, the quotation <code>&lt;@@ 1 + 2 @@&gt;</code> compiles to <code>Quotations.Expr = Call (None, op_Addition, [Value (1), Value (2)])</code>. Not very exciting so far, but how about:</p>

<p>``` fsharp
let addI i =</p>

<pre><code>&lt;@@ 1 + (%%i) @@&gt;
</code></pre>

<p>```</p>

<p>This gives a function of <code>Expr -&gt; Expr</code>, and now we can do things like <code>let add2 = addI &lt;@@ 2 @@&gt;</code> (gives <code>val add2 : Expr = Call (None, op_Addition, [Value (1), Value (2)])</code>) or <code>let add2MultipliedByX x = addI &lt;@@ 2 * x @@&gt;</code> (gives <code>val add2MultipliedByX : x:int -&gt; Expr</code>) and what we get back is effectively the AST of the first F# expression with the second spliced in to evaluate as you will. So in our <code>GetterCode</code> above, we are actually providing the AST that will be compiled into the <code>get_MyPropertyMethod</code> of the type when it is created.</p>

<p>The second thing that you need to know about quotations for current purposes is that the thing evaluating them may or may not be able to handle the F# expression you&rsquo;ve created. Which again we&rsquo;ll get back to in a moment!</p>

<p>So far, our type isn&rsquo;t very exciting. You can&rsquo;t even construct an instance of it. Let&rsquo;s see what we can do about that, with a replacement <code>createTypes</code> method:</p>

<p>``` fsharp</p>

<pre><code>let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true, 
                                    GetterCode = fun args -&gt; &lt;@@ "Hello world" @@&gt;)
    myType.AddMember(myProp)

    let ctor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ "My internal state" :&gt; obj @@&gt;)
    myType.AddMember(ctor)

    let ctor2 = ProvidedConstructor(
                    [ProvidedParameter("InnerState", typeof&lt;string&gt;)],
                    InvokeCode = fun args -&gt; &lt;@@ (%%(args.[0]):string) :&gt; obj @@&gt;)
    myType.AddMember(ctor2)

    let innerState = ProvidedProperty("InnerState", typeof&lt;string&gt;,
                        GetterCode = fun args -&gt; &lt;@@ (%%(args.[0]) :&gt; obj) :?&gt; string @@&gt;)
    myType.AddMember(innerState)

    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>```</p>

<p>Now we can construct our type (in two ways, no less). As the underlying CLR type is an <code>object</code> we can store pretty much anything as the internal representation of an instance of our type. The <code>InvokeCode</code> parameter of the constructors needs to return a quotation that will return the internal representation of the object when it&rsquo;s evaluated. We&rsquo;re going to return a string (which we need to cast to an obj), and using the splicing syntax above we can inject the parameters of the constructor into the quotation (for the constructor which has a parameter).</p>

<p>Similarly, we also add a property (notice that we&rsquo;re not setting it to be a static property this time). Because this property is not static, the first item in the <code>args</code> Array is the instance of the type itself (similar to the way that you define an extension method). So we can splice that into our method quotation (remembering to cast it from <code>obj</code> to <code>string</code>) and expose the underlying state of the object for all the world to see.</p>

<p>And now you can do things like this:</p>

<p>``` fsharp
// Your path may vary&hellip;</p>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Mavnn.Blog.TypeProvider.dll&rdquo;</h1>

<p>open Mavnn.Blog.TypeProvider.Provided</p>

<p>let thing = MyType()
let thingInnerState = thing.InnerState</p>

<p>let thing2 = MyType(&ldquo;Some other text&rdquo;)
let thing2InnerState = thing2.InnerState</p>

<p>// val thing : Mavnn.Blog.TypeProvider.Provided.MyType = &ldquo;My internal state&rdquo;
// val thingInnerState : string = &ldquo;My internal state&rdquo;
// val thing2 : Mavnn.Blog.TypeProvider.Provided.MyType = &ldquo;Some other text&rdquo;
// val thing2InnerState : string = &ldquo;Some other text&rdquo;
```</p>

<h2>And the point is?</h2>

<p>Well &ndash; this is great, except the perceptive among you will have noticed that we&rsquo;re just generating a static type here. We could have just declared it using normal syntax.</p>

<p>So let&rsquo;s try going a step further. Let&rsquo;s say that we have some Json definitions of graph nodes types, each with a defined set of input and output &ldquo;ports&rdquo;. All of these graph bits are given to us as a Json array, and each Node type and port has a Guid identifier and a friendly name.</p>

<p>Our input JSON looks something like this:</p>

<p>``` json
[
   {</p>

<pre><code>  "Id":{
     "Name":"Simple",
     "UniqueId":"0ab82262-0ad3-47d3-a026-615b84352822"
  },
  "Ports":[
     {
        "Id":{
           "Name":"Input",
           "UniqueId":"4b69408e-82d2-4c36-ab78-0d2327268622"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Output",
           "UniqueId":"92ae5a96-6900-4d77-832f-d272329f8a90"
        },
        "Type":"output"
     }
  ]
</code></pre>

<p>   },
   {</p>

<pre><code>  "Id":{
     "Name":"Join",
     "UniqueId":"162c0981-4370-4db3-8e3f-149f13c001da"
  },
  "Ports":[
     {
        "Id":{
           "Name":"Input1",
           "UniqueId":"c0fea7ff-456e-4d4e-b5a4-9539ca134344"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Input2",
           "UniqueId":"4e93c3b1-11bc-422a-91b8-e53204368714"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Output",
           "UniqueId":"fb54728b-9602-4220-ba08-ad160d92d5a4"
        },
        "Type":"output"
     }
  ]
</code></pre>

<p>   },
   {</p>

<pre><code>  "Id":{
     "Name":"Split",
     "UniqueId":"c3e44941-9182-41c3-921c-863a82097ba8"
  },
  "Ports":[
     {
        "Id":{
           "Name":"Input",
           "UniqueId":"0ec2537c-3346-4503-9f5a-d0bb49e9e431"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Output1",
           "UniqueId":"77b5a50c-3d11-4a67-b14d-52d6246e78c5"
        },
        "Type":"output"
     },
     {
        "Id":{
           "Name":"Output2",
           "UniqueId":"d4d1e928-5347-4d51-be54-8650bdfe9bac"
        },
        "Type":"output"
     }
  ]
</code></pre>

<p>   }
]
```</p>

<p>Things start getting a bit more in depth here, so you might want to check out the full code for this post, available on <a href="https://github.com/mavnn/Mavnn.Blog.TypeProvider">GitHub</a>, and follow along in your favourite development environment.</p>

<p>We&rsquo;ll let someone else deal with the parsing &ndash; add a Nuget reference to <code>Newtonsoft.Json</code> to your type provider, and let&rsquo;s have a third reprise of <code>createTypes</code>.</p>

<p>First, we&rsquo;ll need some classes to deserialize the Json into. Out of the box Newtonsoft doesn&rsquo;t do a great job on F# core classes (although that&rsquo;s changing), so for the moment we&rsquo;ll create some classic OO style mutable types:</p>

<p>``` fsharp
type Id () =</p>

<pre><code>member val UniqueId = Guid() with get, set
member val Name = "" with get, set
</code></pre>

<p>type Port () =</p>

<pre><code>member val Id = Id() with get, set
member val Type = "" with get, set
</code></pre>

<p>type Node () =</p>

<pre><code>member val Id = Id() with get, set
member val Ports = Collections.Generic.List&lt;Port&gt;() with get, set
</code></pre>

<p>```</p>

<p>(Don&rsquo;t worry though, these aren&rsquo;t what we&rsquo;ll actually expose as the main interface.)</p>

<p>Turning our Json into the our new CLR types is straight forward:</p>

<p>``` fsharp
let nodes =</p>

<pre><code>JsonConvert.DeserializeObject&lt;seq&lt;Node&gt;&gt;(IO.File.ReadAllText(@"c:\Temp\Graph.json"))
</code></pre>

<p>```</p>

<p>Now the interesting part. To build a graph out of these nodes, we need to be able to do a few things.</p>

<p>Firstly, we need to be able to build a specific instance of a node type: which <code>Split</code> node is this?</p>

<p>Let&rsquo;s help ourselves out by having a concrete type as an the underlying type for our instances:</p>

<p>``` fsharp
type nodeInstance =</p>

<pre><code>{
    Node : Node
    InstanceId : Id
    Config : string
}
</code></pre>

<p>module private NodeInstance =</p>

<pre><code>let create node name guid config =
    { Node = node; InstanceId = Id(Name = name, UniqueId = guid); Config = config }  
</code></pre>

<p>```</p>

<p>And then constructing a more specific type with a constructor for each node type we&rsquo;ve read from the Json:</p>

<p>``` fsharp
let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof<nodeInstance>)
let ctor = ProvidedConstructor(</p>

<pre><code>        [
            ProvidedParameter("Name", typeof&lt;string&gt;)
            ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
            ProvidedParameter("Config", typeof&lt;string&gt;)
        ],
        InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
</code></pre>

<p>```</p>

<p>So now we can construct (look back at the json) a <code>Simple</code> node instance by using <code>let simple = Simple("simpleInstance", Guid.NewGuid(),"MyConfig")</code>. And it already has our <code>InstanceId</code>, <code>Config</code> and <code>Node</code> properties from the underlying type.</p>

<p>Good progress &ndash; but we don&rsquo;t have a nice way of representing the inputs and outputs? We want to be able to write some kind of connection builder function afterwards that won&rsquo;t allow you to connect to outputs to each other, or similar silliness, so we&rsquo;re going to need separate types for inputs and outputs.</p>

<p>``` fsharp
// Check out the excellent article at F# for Fun and Profit
// on using single case Discriminated Unions for data modelling
// <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/">http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/</a></p>

<p>type InputPort = | InputPort of Port
type OutputPort = | OutputPort of Port
```</p>

<p>And finally, we&rsquo;ll update our node creation function to add two subtypes to each node type called <code>Inputs</code> and <code>Outputs</code>, and then create properties on those objects to represent each port. Our full type creation for a node now looks something like this:</p>

<p>``` fsharp
let addInputPort (inputs : ProvidedTypeDefinition) (port : Port) =</p>

<pre><code>let port = ProvidedProperty(
                port.Id.Name, 
                typeof&lt;InputPort&gt;, 
                GetterCode = fun args -&gt; 
                    let id = port.Id.UniqueId.ToString()
                    &lt;@@ GetPort id @@&gt;)
inputs.AddMember(port)
</code></pre>

<p>let addOutputPort (outputs : ProvidedTypeDefinition) (port : Port) =</p>

<pre><code>let port = ProvidedProperty(
                port.Id.Name, 
                typeof&lt;OutputPort&gt;, 
                GetterCode = fun args -&gt; 
                    let id = port.Id.UniqueId.ToString()
                    &lt;@@ GetPort id @@&gt;)
outputs.AddMember(port)
</code></pre>

<p>let addPorts inputs outputs (portList : seq<Port>) =</p>

<pre><code>portList
|&gt; Seq.iter (fun port -&gt; 
                match port.Type with
                | "input" -&gt; addInputPort inputs port
                | "output" -&gt; addOutputPort outputs port
                | _ -&gt; failwithf "Unknown port type for port %s/%s" port.Id.Name (port.Id.UniqueId.ToString()))
</code></pre>

<p>let createNodeType id (node : Node) =</p>

<pre><code>let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
let ctor = ProvidedConstructor(
            [
                ProvidedParameter("Name", typeof&lt;string&gt;)
                ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
                ProvidedParameter("Config", typeof&lt;string&gt;)
            ],
            InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
nodeType.AddMember(ctor)

let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
outputs.AddMember(outputCtor)
outputs.HideObjectMethods &lt;- true

let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
inputs.AddMember(inputCtor)
inputs.HideObjectMethods &lt;- true
addPorts inputs outputs node.Ports

// Add the inputs and outputs types of nested types under the Node type
nodeType.AddMembers([inputs;outputs])

// Now add some instance properties to expose them on a node instance.
let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)

nodeType.AddMembers([inputPorts;outputPorts])

nodeType
</code></pre>

<p>```</p>

<p>Leaving only one final mystery. What are the <code>GetPort</code> and <code>GetNode</code> methods &ndash; and why am I using them in the quotations rather than just using something like <code>&lt;@@ node @@&gt;</code>?</p>

<p>Well, if you remember I mentioned earlier that the evaluation of a quotation is limited by the implementation of the evaluator used. The type provider files you included right at the beginning contain an evaluator that turn a quotation into IL instructions &ndash; but, it doesn&rsquo;t include support for literals of custom types. In fact, if you check in <a href="https://github.com/fsharp/FSharp.Data/blob/master/src/CommonProviderImplementation/ProvidedTypes.fs#L1876">the relevant part of ProvidedTypes.fs</a> you&rsquo;ll see that it&rsquo;s actually quite prescriptive.</p>

<p>So, what we do is we build a couple of private helper methods that know how to find the correct port or node from one of the types that is allowed &ndash; in this case, a <code>string</code>:</p>

<p>``` fsharp
let private nodes = JsonConvert.DeserializeObject&lt;seq<Node>>(IO.File.ReadAllText(@&ldquo;c:\Temp\Graph.json&rdquo;))</p>

<pre><code>                |&gt; Seq.map (fun n -&gt; n.Id.UniqueId.ToString(), n)
                |&gt; Map.ofSeq
</code></pre>

<p>let GetNode id =</p>

<pre><code>nodes.[id]
</code></pre>

<p>let private ports =</p>

<pre><code>nodes
|&gt; Map.toSeq
|&gt; Seq.map (fun (_, node) -&gt; node.Ports)
|&gt; Seq.concat
|&gt; Seq.map (fun p -&gt; p.Id.UniqueId.ToString(), p)
|&gt; Map.ofSeq
</code></pre>

<p>let GetPort id =</p>

<pre><code>ports.[id]
</code></pre>

<p>```</p>

<p>So, there you have it. A complete, working type provider that uses meta data supplied in Json format to create CLR types. Lots of things still to be added for production ready code (delayed loading, handling multiple ports with the same names, not hard coding the filename, etc).</p>

<p><img src="/images/typeprovider.png" alt="Winning..." /></p>

<p>Any questions or corrections, fire away. As mentioned, this is very much the first time I&rsquo;ve used type providers &ndash; but even this level of usage is providing a goodly amount of value for us.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[To Infinity and Beyond]]></title>
    <link href="http://blog.mavnn.co.uk/to-infinity/"/>
    <updated>2013-10-31T07:41:00+00:00</updated>
    <id>http://blog.mavnn.co.uk/to-infinity</id>
    <content type="html"><![CDATA[<p>So, a couple of weeks ago I went to the Brighton Functional Programmers meet up. It was a fun night, and at one point I ended up live coding in front of a room of functional programmers trying to give examples of lazy and strict evaluation.</p>

<p>The canonical go to tool for the job, is of course the infinite sequence and being stared at by a bunch of people and having syntax highlighting but no compiler, the first thing my brain pulled out of the air was this:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part1.fs'></script>
<noscript><pre><code>let ones =
    seq {
        while true do
            yield 1
    }
// seq [1; 1; 1; 1; ...]</code></pre></noscript></div>
</p>

<p>Which prompted one of the people attending (hi <a href="https://twitter.com/milessabin">Miles!</a>) to comment &ldquo;let&rsquo;s see that in Haskell without the bizarre looping generator&rdquo;. Roughly &ndash; I&rsquo;m slightly paraphrasing here given the couple of weeks in between. He has a bit of a point, this isn&rsquo;t the most functional looking sequence generator in the world, and it looks like quite a lot of code to just generate a lot of ones.</p>

<p>As always in these situations, I had of course thought of several other alternatives before I even reached my chair, so I thought I&rsquo;d have a quick survey of them and their advantages and disadvantages.</p>

<p>My first thought was that I&rsquo;d missed the obvious and succinct option of just generating a range. In F# (as in Haskell) the 1 .. 10 notation generates a list of the integers from 1 to 10. Unfortunately:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part2.fs'></script>
<noscript><pre><code>// Can't do this, unfortunately
// seq { 1 .. }
//
// or this:
// seq { 1 .. 0 .. 2 }
//
// Which I thought might be a nice hack.
</code></pre></noscript></div>
</p>

<p>Unlike Haskell, you can&rsquo;t have an unbounded range, nor can you set the &ldquo;step&rdquo; to zero to just keep on generating the same number. So you&rsquo;re limited to generating very big, but definitely not infinite sequences:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part3.fs'></script>
<noscript><pre><code>let notInfiniteOrOnes = seq { 1 .. System.Int32.MaxValue }
// seq [1; 2; 3; 4; ...]

let notInfinite = seq { for _ in 1 .. System.Int32.MaxValue -&gt; 1 }
// seq [1; 1; 1; 1; ...]
</code></pre></noscript></div>
</p>

<p>But hey! We&rsquo;re in functional world. So if we can&rsquo;t use sneaky built in syntax constructs, the next obvious choice is a recursive function:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part4.fs'></script>
<noscript><pre><code>let ones' =
    let rec gen () =
        seq {
            yield 1
            yield! gen ()
        }
    gen ()
// seq [1; 1; 1; 1; ...]
</code></pre></noscript></div>
</p>

<p>This is definitely infinite, and definitely functional in style. Bit verbose, of course, but it least it won&rsquo;t stack overflow as F# implements tail call recursion. It&rsquo;s verbose, but it does also have its advantages. It&rsquo;s trivial to pass things round in the recursive function (previous values from the sequence, etc) making this a very flexible way of generating sequences.</p>

<p>And, of course, let&rsquo;s not ignore the standard library. The <code>Seq</code> module gives us a couple of methods designed specifically for generating (potentially) infinite sequences.</p>

<p><code>Seq.initInfinite</code> just takes a function that returns a sequence value based on the index of that value:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part5.fs'></script>
<noscript><pre><code>let ones'' = Seq.initInfinite (fun _ -&gt; 1)
// seq [1; 1; 1; 1; ...]
</code></pre></noscript></div>
</p>

<p>As long as a simple mapping from index to value exists, this is both clear and concise. In theory, of course, it also suffers from the same issue as my range generators above: if your index exceeds the valid size of an Int32 you&rsquo;re out of luck.</p>

<p><code>Seq.unfold</code> may seem less intuitive, but in my mind is the more flexible and powerful solution. I tend to come across examples where it&rsquo;s easier to generate a sequence based on either some state or the previous term than by index, and that&rsquo;s exactly what unfold allows you to do:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part6.fs'></script>
<noscript><pre><code>let ones''' = Seq.unfold (fun _ -&gt; Some (1, ())) ()
// seq [1; 1; 1; 1; ...]
</code></pre></noscript></div>
</p>

<p>It will also happily generate sequences forever if your generating function allows.</p>

<p>So, how does it actually work? Let&rsquo;s look at a (slightly) more complex example that actually makes use of some state:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part7.fs'></script>
<noscript><pre><code>let moreInterestingUnfold =
    Seq.unfold
        (fun state -&gt;
            Some (state, state + 1)) 1
// seq [1; 2; 3; 4; ...]
</code></pre></noscript></div>
</p>

<p>What&rsquo;s going on here then? Well, <code>unfold</code> takes two arguments. The first is a function that takes a &lsquo;State and returns an Option&lt;&rsquo;T * 'State>. In our simple example above, both 'State and &rsquo;T are of type <code>int</code> but there&rsquo;s no requirement for them to be of the same type. If at any point the function returns <code>None</code>, the sequence ends. In our example, we always return <code>Some</code>, so our sequence is infinite (at least until it runs out of integers) and we&rsquo;re return a tuple of two values &ndash; the first of which will be used as the next term in the sequence, and the second which will become the new state.</p>

<p>The second argument to <code>unfold</code> is the starting state. In our case, this means the number that will be the first term in the sequence, and then we&rsquo;ll add one to it each time.</p>

<p>Let&rsquo;s round this out with an example that uses different types for the state and the terms of the sequence, which will hopefully now make some sense:</p>

<p><div><script src='https://gist.github.com/mavnn/7246744.js?file=Part8.fs'></script>
<noscript><pre><code>type Time =
    {
        Hour : int
        Minute : int
    }

let addMinute time =
    match time with
    | { Hour = 23; Minute = 59 } -&gt;
        { Hour = 0; Minute = 0 }
    | { Minute = 59 } -&gt;
        { Hour = time.Hour + 1; Minute = 0 }
    | _ -&gt;
        { Hour = time.Hour; Minute = time.Minute + 1 }

let unfold' =
    Seq.unfold
        (fun state -&gt;
            Some (sprintf &quot;%02d:%02d&quot; state.Hour state.Minute, addMinute state)
            ) { Hour = 22; Minute = 59 }
// seq [&quot;23:59&quot;; &quot;00:00&quot;; &quot;00:01&quot;; &quot;00:02&quot;; ...]
</code></pre></noscript></div>
</p>

<p>I&rsquo;m sure that you&rsquo;ve always needed a convenient way of cycling through every minute of the day repeatedly, with a nice readable string representation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing F# to Experienced Developers]]></title>
    <link href="http://blog.mavnn.co.uk/introducing-f-number-to-experienced-developers/"/>
    <updated>2013-10-14T12:30:00+01:00</updated>
    <id>http://blog.mavnn.co.uk/introducing-f-number-to-experienced-developers</id>
    <content type="html"><![CDATA[<p>So, as a follow up to <a href="" title="http://blog.mavnn.co.uk/teaching-f-number-to-c-number-devs/">this post</a> I&rsquo;m in the final stages of preparing a presentation for this Friday introducing an audience of (mostly) fairly experienced developers to F# and F# syntax. The main reason for this is to get a number of people up to speed enough on reading F# that they can have a better experience at <a href="" title="http://skillsmatter.com/event/scala/progressive-f-tutorials-2013">the Progressive F# Tutorials</a> at the end of the month. So the aim here isn&rsquo;t to get people fully autonomous and writing code <em>right now</em>, but to allow them to read the bulk of the example code in the tutorials and follow what&rsquo;s going on.</p>

<p>The general approach I&rsquo;ve gone for is to set up a Git repository that has a series of tagged snap shots I can check out as I work through the concepts I&rsquo;m planning to cover. This will enable me to actually demonstrate and run pieces of code, answer questions and make live modifications and then always jump back to a known starting point for the next section of the talk. Given the people involved have all done some .net development and I don&rsquo;t need to cover things like Visual Studio usage and projects, all of the code is contained in a single Program.fs file in a console app. I&rsquo;ve included the snapshot of the file from each tagged commit below, with a brief overview of what I&rsquo;m planning to introduce before skipping to the next snapshot.</p>

<p>With a full screen Visual Studio editing session, I should be able to make the code large enough to be visible and reasonably rapidly guide people to the areas where the code has changed.</p>

<p>A combination of the excellent <a href="http://papercut.codeplex.com/">PaperCut</a> project and a local &lsquo;http request to email&rsquo; service pretending to be an SMS sender, we should be able to see messages being generated by the code as we go along.</p>

<p>After the session, I&rsquo;m planning to mention <a href="https://github.com/ChrisMarinos/FSharpKoans">Chris Marinos' koans</a> and <a href="http://www.tryfsharp.org/">Try F#</a> (especially given that Rachel Reese is <a href="http://skillsmatter.com/podcast/scala/try-f-from-zero-to-data-science">running a session</a> at the tutorials for those who are going).</p>

<p>Please note that these are up here for comment and suggestions at this point &ndash; I&rsquo;ll be pushing up the actual Git repository and a screencast (I hope) after the event. The code is designed to be a prop for the talk rather than an independent resource &ndash; for that I&rsquo;d always point people to the koans/Try F# first.</p>

<p>So, show me the codez:</p>

<!--more-->


<h2>Tag &lsquo;1&rsquo;</h2>

<p>Nothing too exciting here :). This is just a place holder while giving the introduction, although I will also point out the lack of required boiler plate compared to C#.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part1.fs'></script>
<noscript><pre><code>// Let's send an email!
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;2&rsquo;</h2>

<p>Introduce the <code>open</code> keyword, <code>let</code> for value assignment, and give people a feel that they&rsquo;re not completely leaving their nice safe .net world behind.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part2.fs'></script>
<noscript><pre><code>// Let's send an email!

open System.Net.Mail

// We only use the 'new' keyword here because SmtpClient is disposable
let smtpClient = new SmtpClient(&quot;smtp.local&quot;)

// And given it's disposable, we should really dispose of it...
smtpClient.Dispose()</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;3&rsquo;</h2>

<p>Talk about functions, show parameter application, introduce the pipe operator.</p>

<p>Some discussion about type inference will probably happen here.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part3.fs'></script>
<noscript><pre><code>open System.Net.Mail

let smtpClient = new SmtpClient(&quot;smtp.local&quot;)

// This is a function
let sendMessage client message =
    // We'd better do something here to actually
    // send a message...
    printfn &quot;I haven't sent a mail message!&quot;
    ()

sendMessage smtpClient &quot;My message&quot;

smtpClient.Dispose()

// And we'll add this so we can see the output
// before it disappears
System.Console.ReadLine() |&gt; ignore
// This line would be the same as writing:
//
// ignore (System.Console.Readline())
//
// but you have to admit that this is a bit 
// more readable</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;4&rsquo;</h2>

<p>Introduce the <code>use</code> keyword, show property assignment with <code>&lt;-</code>.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part4.fs'></script>
<noscript><pre><code>open System.Net.Mail

let smtpClient = new SmtpClient(&quot;smtp.local&quot;)

let sendMessage client message =
    (* Because we used 'use' this will get
    disposed at the end of the declaring
    scope *)
    use mailMessage = new MailMessage(&quot;me@example.com&quot;, &quot;you@example.com&quot;)
    (* This is have you assign a parameter *)
    mailMessage.Subject &lt;- &quot;Message subject&quot;
    mailMessage.Body &lt;- message
    smtpClient.Send mailMessage
    printfn &quot;I've sent a mail message!&quot;

sendMessage smtpClient &quot;My message&quot;

smtpClient.Dispose()
System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;5&rsquo;</h2>

<p>List syntax and introduce the <code>Seq</code> module. Example of currying.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part5.fs'></script>
<noscript><pre><code>open System.Net.Mail

let smtpClient = new SmtpClient(&quot;smtp.local&quot;)

let sendMessage client message =
    use mailMessage = new MailMessage(&quot;me@example.com&quot;, &quot;you@example.com&quot;)
    mailMessage.Subject &lt;- &quot;Message subject&quot;
    mailMessage.Body &lt;- message
    smtpClient.Send mailMessage
    printfn &quot;I've sent a mail message!&quot;

(* But really, what you want computers for
is doing the same thing lots of times... *)
let myMessages =
    [
        &quot;My first message&quot;
        &quot;My second message&quot;
        &quot;My third and final message&quot;
    ]

myMessages
|&gt; Seq.iter (sendMessage smtpClient)
(* Let's have some vindaloo with that map *)

smtpClient.Dispose()
System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;6&rsquo;</h2>

<p>An async workflow. Turns out that <code>SmtpClient</code> is not as clean for that as you would hope &ndash; it&rsquo;s async send methods don&rsquo;t appear to be thread safe (wait, what?) and even the relatively recent looking <code>SendMailAsync</code> method returns a <code>Task</code> rather than a <code>Task&lt;'T&gt;</code>. Having said that, it shows that even in less than ideal circumstances, you can leverage the <code>async</code> stuff even when interfacing with older .net code from other languages.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part6.fs'></script>
<noscript><pre><code>open System.Net.Mail


(* But really, what you want computers for
is doing the same thing lots of times... 
at the same time! *)
let sendMessage message =
    async {
        // Move the client inside because...
        // have _you_ checked if it's thread safe?
        use smtpClient = new SmtpClient(&quot;smtp.local&quot;)
        use mailMessage = new MailMessage(&quot;me@example.com&quot;, &quot;you@example.com&quot;)
        mailMessage.Subject &lt;- &quot;Message subject&quot;
        mailMessage.Body &lt;- message
        do!
            smtpClient.SendMailAsync(mailMessage)
            |&gt; Async.AwaitIAsyncResult
            |&gt; Async.Ignore
        printfn &quot;I've sent a mail message!&quot;
    }

let myMessages =
    [
        &quot;My first message&quot;
        &quot;My second message&quot;
        &quot;My third and final message&quot;
    ]

myMessages
|&gt; Seq.map sendMessage
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; fun _ -&gt; printfn &quot;Finished all sends!&quot;

System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;7&rsquo;</h2>

<p>Tuples! Showing both construction and deconstruction syntax. Also discuss that this is how we pass multiple parameters to methods on classes.</p>

<p>In the live coding for this one, I&rsquo;ll make sure to demonstrate adding and removing brackets in different places.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part7.fs'></script>
<noscript><pre><code>open System.Net.Mail

let sendMessage messageDetails =
    async {
        let address, body = messageDetails
        use smtpClient = new SmtpClient(&quot;smtp.local&quot;)
        use mailMessage = new MailMessage(&quot;me@example.com&quot;, address)
        mailMessage.Subject &lt;- &quot;Message subject&quot;
        mailMessage.Body &lt;- body
        do!
            smtpClient.SendMailAsync(mailMessage)
            |&gt; Async.AwaitIAsyncResult
            |&gt; Async.Ignore
        printfn &quot;I've sent a mail message!&quot;
    }


(* But we probably don't want to send all of these
to the same person. *)
let myMessages =
    [
        &quot;first@example.com&quot;, &quot;My first message&quot;
        &quot;secord@example.com&quot;, &quot;My second message&quot;
        &quot;third@example.com&quot;, &quot;My third and final message&quot;
    ]

myMessages
|&gt; Seq.map sendMessage
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; fun _ -&gt; printfn &quot;Finished all sends!&quot;

System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;8&rsquo;</h2>

<p>Record syntax.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part8.fs'></script>
<noscript><pre><code>open System.Net.Mail

(* How about if I want to pass lots of different bits
of information in? *)
type messageDetails =
    {
        toAddress : string
        fromAddress : string
        body : string
    }

let sendMessage messageDetails =
    async {
        use smtpClient = new SmtpClient(&quot;smtp.local&quot;)
        use mailMessage = 
            new MailMessage(
                messageDetails.fromAddress,
                messageDetails.toAddress)
        mailMessage.Subject &lt;- &quot;Message subject&quot;
        mailMessage.Body &lt;- messageDetails.body
        do!
            smtpClient.SendMailAsync(mailMessage)
            |&gt; Async.AwaitIAsyncResult
            |&gt; Async.Ignore
        printfn &quot;I've sent a mail message!&quot;
    }

let myMessages =
    [
        { toAddress = &quot;first@example.com&quot;; fromAddress = &quot;official@example.com&quot;; body = &quot;My first message&quot; }
        { toAddress = &quot;second@example.com&quot;; fromAddress = &quot;personal@example.com&quot;; body = &quot;My second message&quot; }
        { toAddress = &quot;first@example.com&quot;; fromAddress = &quot;official@example.com&quot;; body = &quot;My third message&quot; }
    ]

myMessages
|&gt; Seq.map sendMessage
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; fun _ -&gt; printfn &quot;Finished all sends!&quot;

System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;9&rsquo;</h2>

<p>Use discriminated unions for modeling business inputs. In this case, building a MessageDetails class that can contain the details of either an email or an SMS send request.</p>

<p>Also has a 2nd, maybe slightly more idiomatic implementation of an async workflow.</p>

<p>I&rsquo;m hoping to get at least this far in the session. The rest of it would be nice, but if we get here then I&rsquo;ll be happy I&rsquo;ve covered at least the basics.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part9.fs'></script>
<noscript><pre><code>open System.IO
open System.Net
open System.Net.Mail

(* But some people have given us mobile
numbers rather than email addresses *)
type EmailDetails =
    {
        toAddress : string
        fromAddress : string
        body : string
    }

type SmsDetails =
    {
        toNumber : string
        fromNumber : string
        message : string
    }

type MessageDetails =
    | Email of EmailDetails
    | Sms of SmsDetails

let sendEmail messageDetails =
    async {
        use smtpClient = new SmtpClient(&quot;smtp.local&quot;)
        use mailMessage = 
            new MailMessage(
                messageDetails.fromAddress,
                messageDetails.toAddress)
        mailMessage.Subject &lt;- &quot;Message subject&quot;
        mailMessage.Body &lt;- messageDetails.body
        do!
            smtpClient.SendMailAsync(mailMessage)
            |&gt; Async.AwaitIAsyncResult
            |&gt; Async.Ignore
        printfn &quot;I've sent a mail message!&quot;
    }

let sendSms messageDetails =
    async {
        let http = HttpWebRequest.Create(&quot;http://sms.local&quot;) :?&gt; HttpWebRequest
        http.Method &lt;- &quot;POST&quot;
        let messagePayload =
            sprintf
                &quot;To: %s\nFrom: %s\nMessage: %s&quot;
                messageDetails.toNumber
                messageDetails.fromNumber
                messageDetails.message
        using 
            (http.GetRequestStream())
            (fun stream -&gt; 
                use sw = new StreamWriter(stream)
                sw.Write(messagePayload))
        let! response = http.GetResponseAsync() |&gt; Async.AwaitTask
        if (response :?&gt; HttpWebResponse).StatusCode &lt;&gt; HttpStatusCode.OK then
            failwith &quot;Http request failed!&quot;
        printfn &quot;I've sent an SMS!&quot;
    }

let sendMessage message =
    match message with
    | Email details -&gt; sendEmail details
    | Sms details -&gt; sendSms details

let myMessages =
    [
        Email { toAddress = &quot;first@example.com&quot;; fromAddress = &quot;official@example.com&quot;; body = &quot;My first message&quot; }
        Email { toAddress = &quot;second@example.com&quot;; fromAddress = &quot;personal@example.com&quot;; body = &quot;My second message&quot; }
        Email { toAddress = &quot;first@example.com&quot;; fromAddress = &quot;official@example.com&quot;; body = &quot;My third message&quot; }
        Sms { toNumber = &quot;+447777123123&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;Hello by sms&quot; }
        Sms { toNumber = &quot;+447777123124&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;Hello by sms x2&quot; }
        Sms { toNumber = &quot;+447777123123&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;Hello by sms x3&quot; }
    ]

myMessages
|&gt; Seq.map sendMessage
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; fun _ -&gt; printfn &quot;Finished all sends!&quot;

System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;10&rsquo;</h2>

<p>Validation with Active patterns.</p>

<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part10.fs'></script>
<noscript><pre><code>open System.IO
open System.Net
open System.Net.Mail

type EmailDetails =
    {
        toAddress : string
        fromAddress : string
        body : string
    }

type SmsDetails =
    {
        toNumber : string
        fromNumber : string
        message : string
    }

type MessageDetails =
    | Email of EmailDetails
    | Sms of SmsDetails

(* But what if some people have given us invalid data?

Our SMS sender requires full numbers with national
codes - let's add some validation! *)
let (|ValidSmsRequest|InvalidSmsRequest|) details =
    // Hmm. Bananas. My favourite.
    let regex = System.Text.RegularExpressions.Regex(@&quot;^\+\d\d&quot;)
    if regex.IsMatch(details.toNumber) &amp;&amp; regex.IsMatch(details.fromNumber) then
        ValidSmsRequest details
    else
        InvalidSmsRequest &quot;You must include the +xx country prefix on mobile numbers.&quot;

let sendEmail messageDetails =
    async {
        use smtpClient = new SmtpClient(&quot;smtp.local&quot;)
        use mailMessage = 
            new MailMessage(
                messageDetails.fromAddress,
                messageDetails.toAddress)
        mailMessage.Subject &lt;- &quot;Message subject&quot;
        mailMessage.Body &lt;- messageDetails.body
        do!
            smtpClient.SendMailAsync(mailMessage)
            |&gt; Async.AwaitIAsyncResult
            |&gt; Async.Ignore
        printfn &quot;I've sent a mail message!&quot;
    }

(* We've moved the SMS post logic into this method
without change - no validation here.

We've marked it private so no one else can call it
by mistake *)
let private postSms messageDetails =
    async {
        let http = HttpWebRequest.Create(&quot;http://sms.local&quot;) :?&gt; HttpWebRequest
        http.Method &lt;- &quot;POST&quot;
        let messagePayload =
            sprintf
                &quot;To: %s\nFrom: %s\nMessage: %s&quot;
                messageDetails.toNumber
                messageDetails.fromNumber
                messageDetails.message
        using 
            (http.GetRequestStream())
            (fun stream -&gt; 
                use sw = new StreamWriter(stream)
                sw.Write(messagePayload))
        let! response = http.GetResponseAsync() |&gt; Async.AwaitTask
        if (response :?&gt; HttpWebResponse).StatusCode &lt;&gt; HttpStatusCode.OK then
            failwith &quot;Http request failed!&quot;
        printfn &quot;I've sent an SMS!&quot;
    }

(* And this is where we do our validation *)
let sendSms messageDetails =
    match messageDetails with
    | ValidSmsRequest details -&gt; postSms details
    | InvalidSmsRequest error -&gt; async { printfn &quot;Sms sending error: %s&quot; error }

let sendMessage message =
    match message with
    | Email details -&gt; sendEmail details
    | Sms details -&gt; sendSms details

let myMessages =
    [
        Email { toAddress = &quot;first@example.com&quot;; fromAddress = &quot;official@example.com&quot;; body = &quot;My first message&quot; }
        Email { toAddress = &quot;second@example.com&quot;; fromAddress = &quot;personal@example.com&quot;; body = &quot;My second message&quot; }
        Email { toAddress = &quot;first@example.com&quot;; fromAddress = &quot;official@example.com&quot;; body = &quot;My third message&quot; }
        Sms { toNumber = &quot;+447777123123&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;Hello by sms&quot; }
        Sms { toNumber = &quot;+447777123124&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;Hello by sms x2&quot; }
        Sms { toNumber = &quot;+447777123123&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;Hello by sms x3&quot; }
        Sms { toNumber = &quot;447777123123&quot;; fromNumber = &quot;+447888321321&quot;; message = &quot;I won't be sent!&quot; }
        Sms { toNumber = &quot;+447777123123&quot;; fromNumber = &quot;+ab7888321321&quot;; message = &quot;Neither will I!&quot; }
        Sms { toNumber = &quot;Bob&quot;; fromNumber = &quot;+ab7888321321&quot;; message = &quot;..and I definitely won't!&quot; }
    ]

myMessages
|&gt; Seq.map sendMessage
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; fun _ -&gt; printfn &quot;Finished all sends!&quot;

System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>

<h2>Tag &lsquo;11&rsquo;</h2>

<p>The extra credit section! I very much doubt I&rsquo;ll get this far in a one hour session, but if I do this is just some fun playing with type providers. Also covers randomness such as:</p>

<ul>
<li>generating infinite sequences using <code>seq</code> expressions</li>
<li>double back tick identifiers</li>
<li>pattern matching with guards</li>
<li>a bit more of a workout of the <code>Seq</code> module</li>
<li>we can have a lot of discussion of lazy evaluation, because this code is just insanely broken without it</li>
</ul>


<p><div><script src='https://gist.github.com/mavnn/6973457.js?file=part11.fs'></script>
<noscript><pre><code>open System
open System.IO
open System.Net
open System.Net.Mail
open System.Text.RegularExpressions

type EmailDetails =
    {
        toAddress : string
        fromAddress : string
        body : string
    }

type SmsDetails =
    {
        toNumber : string
        fromNumber : string
        message : string
    }

type MessageDetails =
    | Email of EmailDetails
    | Sms of SmsDetails

let (|ValidSmsRequest|InvalidSmsRequest|) details =
    let regex = Regex(@&quot;^\+\d\d&quot;)
    if regex.IsMatch(details.toNumber) &amp;&amp; regex.IsMatch(details.fromNumber) then
        ValidSmsRequest details
    else
        InvalidSmsRequest &quot;You must include the +xx country prefix on mobile numbers.&quot;

let sendEmail messageDetails =
    async {
        use smtpClient = new SmtpClient(&quot;smtp.local&quot;)
        use mailMessage = 
            new MailMessage(
                messageDetails.fromAddress,
                messageDetails.toAddress)
        mailMessage.Subject &lt;- &quot;Message subject&quot;
        mailMessage.Body &lt;- messageDetails.body
        do!
            smtpClient.SendMailAsync(mailMessage)
            |&gt; Async.AwaitIAsyncResult
            |&gt; Async.Ignore
        printfn &quot;I've sent a mail message!&quot;
    }

let private postSms messageDetails =
    async {
        let http = HttpWebRequest.Create(&quot;http://sms.local&quot;) :?&gt; HttpWebRequest
        http.Method &lt;- &quot;POST&quot;
        let messagePayload =
            sprintf
                &quot;To: %s\nFrom: %s\nMessage: %s&quot;
                messageDetails.toNumber
                messageDetails.fromNumber
                messageDetails.message
        using 
            (http.GetRequestStream())
            (fun stream -&gt; 
                use sw = new StreamWriter(stream)
                sw.Write(messagePayload))
        let! response = http.GetResponseAsync() |&gt; Async.AwaitTask
        if (response :?&gt; HttpWebResponse).StatusCode &lt;&gt; HttpStatusCode.OK then
            failwith &quot;Http request failed!&quot;
        printfn &quot;I've sent an SMS!&quot;
    }

let sendSms messageDetails =
    match messageDetails with
    | ValidSmsRequest details -&gt; postSms details
    | InvalidSmsRequest error -&gt; async { printfn &quot;Sms sending error: %s&quot; error }

let sendMessage message =
    match message with
    | Email details -&gt; sendEmail details
    | Sms details -&gt; sendSms details
    
(* And now for something completely different...

Let's send a bunch of actors and celebrities a selection 
of astronomical data. Because, you know. Why not?

If you're running this code at home, you'll need
to install the nuget package from the packages.config
file *)
open FSharp.Data
let FreebaseKey =
    let rec getKey (dir : DirectoryInfo) =
        match dir.EnumerateFiles(&quot;freebase.key&quot;) with
        | files when Seq.isEmpty files -&gt; getKey (dir.Parent)
        | files -&gt; (Seq.head files).OpenText().ReadToEnd().Trim()
    let dir = DirectoryInfo(Directory.GetCurrentDirectory())
    getKey dir

type FreebaseProvider = FreebaseDataProvider&lt;Key=&quot;api key goes here&quot;&gt;

let freebase = FreebaseProvider.GetDataContext()

(* If you don't have an api key you can delete lines
88 to the end of this comment, and uncomment the line below.

It will limit how many times you can run the program
before it starts throwing authentication errors,
though - there's a fairly strict rate limit. *)
//let freebase = FreebaseData.GetDataContext()

let actors =
    freebase.``Arts and Entertainment``.Film.``Film actors``
    |&gt; Seq.filter (fun a -&gt; not &lt;| Seq.isEmpty a.``Film performances``)
    (* You get a (virtual) cookie if you can work out
    why I've added the filter below *)
    |&gt; Seq.filter (fun a -&gt; 
        (a.``Film performances`` |&gt; Seq.head)
            .Film.Name.[0 .. 0]
        |&gt; Regex(&quot;[a-zA-Z]&quot;).IsMatch)
    |&gt; Seq.filter (fun a -&gt; not &lt;| Seq.isEmpty a.``Country of nationality``)
    |&gt; Seq.take 20

let encode (str : string) =
    let clean = Regex(&quot;\W&quot;)
    clean.Replace(str, &quot;-&quot;)

let emailAddresses =
    seq { for actor in actors -&gt; 
            let name = actor.Name |&gt; encode
            let domain =
                (actor.``Film performances`` |&gt; Seq.head).Film.Name
                |&gt; encode
            let countryCode =
                match (actor.``Country of nationality`` |&gt; Seq.head).``ISO Alpha 2`` with
                | alpha when Seq.isEmpty alpha -&gt;
                    &quot;com&quot;
                | alpha when (Seq.head alpha).ToLower() = &quot;us&quot; -&gt;
                    &quot;com&quot;
                | alpha -&gt; sprintf &quot;co.%s&quot; &lt;| (Seq.head alpha).ToLower()
            sprintf &quot;%s@%s.%s&quot;
                name
                domain
                countryCode }

(* We're going to need 20 planets for our 20 celebrities,
so we'll repeat the planets as many times as we need *)
let planets =
    seq {
        while true do
            yield! freebase.``Science and Technology``.Astronomy.Planets
    }

let messages =
    seq { for planet in planets -&gt;
            sprintf &quot;&quot;&quot;Hi there!
We thought you might be interested to know that:

The planet %s has:
%d moons!
An average orbital velocity of %Am/s!

And is also known as:
%s

Regards,

Astro
                &quot;&quot;&quot;
                planet.Name
                (planet.``Orbited by`` |&gt; Seq.length)
                planet.``Average Orbital Speed``
                (planet.``Also known as`` |&gt; String.concat &quot;, &quot;) }

let combineAddressAndMessage (address, message) =
    Email {
        toAddress = address
        fromAddress = &quot;astro@random.org&quot;
        body = message
    }

let myMessages =
    Seq.zip emailAddresses messages
    |&gt; Seq.map combineAddressAndMessage

myMessages
|&gt; Seq.map sendMessage
|&gt; Async.Parallel
|&gt; Async.RunSynchronously
|&gt; fun _ -&gt; printfn &quot;Finished all sends!&quot;

System.Console.ReadLine() |&gt; ignore
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Teaching F# to C# Devs]]></title>
    <link href="http://blog.mavnn.co.uk/teaching-f-number-to-c-number-devs/"/>
    <updated>2013-09-17T11:12:00+01:00</updated>
    <id>http://blog.mavnn.co.uk/teaching-f-number-to-c-number-devs</id>
    <content type="html"><![CDATA[<p>So, in a fit of enthusiasm my boss bought 15 tickets to the <a href="" title="http://skillsmatter.com/event/scala/progressive-f-tutorials-2013">London Progressive F# Tutorials</a> when he saw the early birds pricing (did I mention it&rsquo;s nice working here?). Several of the people who have been assigned tickets have asked to go largely because they are new to F#, so I&rsquo;ve been asked to put together a starter session to teach them the basics. I&rsquo;ve tried this <a href="" title="http://blog.mavnn.co.uk/an-introduction-to-f-screencast-and-pdf-slide">once before</a> and it was a fairly successful session (F# was adopted as a official supported language in the company partly due to feedback following it). But it was still pretty rough around the edges, and as normal with these things, you always want to do them better the next time round&hellip;</p>

<p>So, with a target audience of curious, experienced C# devs I&rsquo;m wondering about the best approach. The initial session needs to fit in an hour, although I can do individual follow ups afterwards.</p>

<p>My current thinking is to take a block of C# code (smtp sender?) that is fairly straight forward but &lsquo;production ready&rsquo; in the sense that it includes error handling, logging, etc. Then do a straight re-write in F# live coding. And then start refactoring to more idiomatic F# as we go along.</p>

<p>Features I feel would be important to cover:</p>

<ul>
<li>Basic syntax (let, functions, if &hellip; then, etc)</li>
<li>Common idioms (|>, Seq.map)</li>
<li>At least one computational expression (probably an error handling one; simpler than async in some ways)</li>
<li>Several examples of using the match statements</li>
<li>&hellip;which probably means at least one DU, possibly for error handling</li>
<li>Records and { &hellip; with &hellip; } expressions</li>
</ul>


<p>I&rsquo;ve got a week or two to prepare, so what I&rsquo;m really hoping for at this point is suggestions and ideas from people for how to improve this as a session idea, things that threw you when you first started writing F# you think should be covered, whether you think this is a stupid idea for a session from the concept up, etc. Once the session is completed I&rsquo;ll be posting the slides and hopefully a screen cast of it as I did last time for use by <a href="" title="http://fsharp.org">fsharp.org</a>.</p>

<p>Suggestions on the piece of C# code to translate would also be appreciated &ndash; either in terms of ideas of the type of code, or actual open source code that would serve as a code starting point.</p>
]]></content>
  </entry>
  
</feed>
