<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2015-05-06T13:10:14+01:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ecumenical APIs]]></title>
    <link href="http://blog.mavnn.co.uk/ecumenical-apis/"/>
    <updated>2015-05-06T10:44:16+01:00</updated>
    <id>http://blog.mavnn.co.uk/ecumenical-apis</id>
    <content type="html"><![CDATA[<p>One of the big sells of shared runtime functional languages such as F#, Scala
and Clojure is that you can carrying on using the surrounding library ecosystem
and your existing code. The different paradigm occasionally causes a little
pain, but there are plenty of blog posts about how to wrap OO interfaces in a
functionally friendly way.</p>

<p>This is not one of those blog posts. This is about making sure that your
colleages who are consuming your shiny new code in an imperative language
(generally C# in my case) don&rsquo;t threaten to defenistrate you.</p>

<p>At <a href="http://15below.com">15below</a> we&rsquo;ve recently had need in some of our services
of taking a distributed lock between servers. There are many services available
designed for doing this, but after some deliberation we decided that we didn&rsquo;t
want to add a new piece of infrastructure purely for this one purpose. So
<a href="http://15below.github.io/Sproc.Lock">Sproc.Lock</a> was born: SQL Server based
distributed locking.</p>

<p>In this post, I&rsquo;m not going to talk about the design of the service. What I&rsquo;m
going to write about is how I engineered the API to be pleasent to use from both
C# and F#, giving a idiomatic interface from both languages.</p>

<!-- more -->


<h2>The original interface (F#)</h2>

<p>The F# interface was written first, and follows a pattern that will feel
immediately familiar to an F# programmer. Our lock can be of 3 types (global,
organisation or environment) and so we have a discriminated union (<code>Lock</code>)
representing these three options.</p>

<p>(I&rsquo;ve removed the implementations of the various bits to leave the shape of the
code clear)</p>

<p>``` fsharp
/// Type representing a Lock that has definitely been acquired. Locks are
/// IDisposable; disposing the lock will ensure it is released.
type Lock =</p>

<pre><code> /// A lock that applies globally across the lock server
 | Global of ...
 /// A lock scoped to a specific organisation
 | Organisation of ...
 /// A lock scoped to a particular environment belonging to a particular organisation
 | Environment of ...
 /// The LockId acquired. Useful in combination when getting one of a list of locks to determine which was free.
 member lock.LockId =
     ...
 /// Disposing releases the lock
 member lock.Dispose () =
     ...
 interface IDisposable with
     /// Disposing releases the lock
     member lock.Dispose () =
        lock.Dispose()
</code></pre>

<p>```</p>

<p>The lock is <code>IDisposable</code> to take advantage of .net&rsquo;s most common resource
management idiom. You can release a lock by disposing it.</p>

<p>Then, of course, when we try and acquire a lock we may or may not be able to &ndash;
the whole point of locks is that you cannot obtain them if someone else has
locked it already, after all.</p>

<p>So we have a second discriminated union (<code>LockResult</code>) wrapping the first,
with (again) three potential cases:</p>

<p>``` fsharp
/// A type representing the possible results of attempting to acquire a lock.
type LockResult =</p>

<pre><code> /// A lock was successfully acquired
 | Locked of Lock
 /// No lock was available
 | Unavailable
 /// The attempt to acquire a lock caused an error in SQL Server
 | Error of int
 /// Disposing a lock result disposes the lock if it was acquired, and has no effect otherwise
 member x.Dispose () =
    match x with
    | Locked l -&gt; l.Dispose()
    | Unavailable -&gt; ()
    | Error _ -&gt; ()
 interface IDisposable with
    member x.Dispose () =
        x.Dispose()
</code></pre>

<p>```</p>

<p>Again, this is <code>IDisposable</code> so that you can just dispose of your overall
<code>LockResult</code> object which makes a lot of the code cleaner.</p>

<p>So: how do we get a <code>LockResult</code>? Well, we have a set of functions for getting
locks. Let&rsquo;s have a look at the skeleton of one of them:</p>

<p>``` fsharp
// val GetOrganisationLock : string &ndash;> string &ndash;> TimeSpan &ndash;> string &ndash;> LockResult
let GetOrganisationLock connString organisation (maxDuration : TimeSpan) lockIdentifier =</p>

<pre><code>...
</code></pre>

<p>```</p>

<p>What&rsquo;s this doing? Well, it&rsquo;s going to (try and) create a lock scoped to a
particular database and organisation with a particular ID, returning a
<code>LockResult</code>.</p>

<p>From an API design point of view, what&rsquo;s interesting here is the order of the
arguments. <a href="https://en.wikipedia.org/wiki/Currying">Currying</a> enables easy
partial application, and here it is very likely that the application will want
to take all locks from the same database (making the first parameter) and
reasonably likely that it will always want them scoped to the same organisation
(second parameter). This is a common pattern in languages that allow for easy
currying, and invariably a consumer of this library in F# will end up with a
partially applied helper function looking something like this:</p>

<p>``` fsharp
// val getLock : string &ndash;> LockResult
let getLock =</p>

<pre><code>GetOrganisationLock "myDbConnString" "OrgName" (TimeSpan.FromMinutes 5.)
</code></pre>

<p>```</p>

<p>We also have a set of helper functions for common operations we might want to
carry out on locks, all of which take a higher order function as part of their
arguments. Let&rsquo;s have a look at <code>AwaitLock</code> which will wait for a lock to
become available for a specified length of time, rather then returning
immediately with an <code>Unavailable</code> result:</p>

<p>``` fsharp
// val AwaitLock : TimeSpan &ndash;> (unit &ndash;> LockResult) &ndash;> LockResult
let AwaitLock (timeOut : TimeSpan) getLock =</p>

<pre><code>...
</code></pre>

<p>// Using it using the helper above:
let awaitMyLock identifier =</p>

<pre><code>AwaitLock (TimeSpan.FromSeconds 2.) (getLock identifier)
</code></pre>

<p>```</p>

<p>If we then want (say) to wait up to 2 seconds for one of a list of possible
locks to become available, we can then compose this function with the
<code>OneOfLocks</code> function:</p>

<p>``` fsharp
// val OneOfLocks : (&lsquo;a &ndash;> LockResult) &ndash;> seq&lt;'a> &ndash;> LockResult
let OneOfLocks getLock lockIds =</p>

<pre><code>...
</code></pre>

<p>// Using it using await helper:
let pickLock () =</p>

<pre><code>OneOfLocks awaitMyLock ["LockId1";"LockId2"] 
</code></pre>

<p>```</p>

<p>I&rsquo;m sure the comments will disagree, but I&rsquo;m actually pretty happy with this as
an F# interface to this library. It&rsquo;s not strictly pure, but that&rsquo;s an option in
F#, and the combination of composable functions and careful choice of parameter
order make for concise and readable code.</p>

<p>So, we&rsquo;re done &ndash; right?</p>

<p>Unfortunately not. This code would be truely horrible to use from C#, and we
still use a lot of C# here &ndash; some of our (stranger?) developers even prefer
it. Why would it be so nasty?</p>

<ul>
<li>Consuming discriminated unions from C# is verbose to the point of unusable</li>
<li>Partial application is a pain in C#, and no one wants to repeat the connection
string everytime they want a lock</li>
<li>Function composition is possible in C# but is not idiomatic and may make the
capabilities of the library unclear</li>
</ul>


<h2>API Take 2: the &ldquo;OO&rdquo; namespace</h2>

<p>In thinking about the kind of API I would expect for a locking library in C#, a
few things immediately sprang to mind:</p>

<ul>
<li>I would expect some kind of configurable provider object or factory</li>
<li>Out of flow returns are normally signalled by exceptions</li>
<li>Function composition only for more unusual calling options</li>
</ul>


<p>Wrapping the functional API turned out to be reasonably simple. A couple of
custom exception types and the <code>OOise</code> method later (I love that function
name, even if I say so myself) we can easily wrap our functional API in
something that makes sense in C# land &ndash; they either return an acquired,
<code>IDisposable</code> lock or throw.</p>

<p><code>` fsharp
/// Exception thrown by</code>LockProvider`` if none of the specified locks are available.
type LockUnavailableException (message) =</p>

<pre><code>inherit System.Exception(message)
</code></pre>

<p>/// Exception thrown by <code>LockProvider</code> if a lock request errors on SQL Server.
/// <code>LockErrorCode</code> is the SQL error response.
type LockRequestErrorException (errorCode) as this =</p>

<pre><code>inherit System.Exception(sprintf "Error code: %d" errorCode)
do
    this.Data.Add(box "ErrorCode", box errorCode)
member x.LockErrorCode
    with get () =
        x.Data.["ErrorCode"] |&gt; unbox&lt;int&gt;
</code></pre>

<p>let private OOise lockId getLock =</p>

<pre><code>match getLock lockId with
| Locked l -&gt; l
| Unavailable -&gt; raise &lt;| LockUnavailableException(sprintf "Lock %s was unavailable." lockId)
| Error i -&gt; raise &lt;| LockRequestErrorException i
</code></pre>

<p>```</p>

<p>Then, a simple <code>LockProvider</code> class allows for all the normal patterns we&rsquo;ve
come to know (and in some cases love) such as dependency injection:</p>

<p>``` fsharp
type LockProvider (connString : string) =</p>

<pre><code>member x.GlobalLock (lockId, maxDuration) =
    GetGlobalLock connString maxDuration |&gt; OOise lockId
member x.OrganisationLock (lockId, organisation, maxDuration) =
    // Rest of the implementations snipped
    ...
member x.EnvironmentLock (lockId, organisation, environment, maxDuration) =
    ...
member x.AwaitGlobalLock (lockId, maxDuration, timeOut) =
    ...
member x.AwaitOrganisationLock (lockId, organisation, maxDuration, timeOut) =
    ...
member x.AwaitEnvironmentLock (lockId, organisation, environment, maxDuration, timeOut) =
    ...
/// Build a ``System.Func`` that returns a lock based on lockId and provide a list of lockIds.
/// If any of the locks are available, it will pick one of the available locks at random.
member x.OneOf&lt;'t&gt; (getLock : System.Func&lt;'t, Lock&gt;, lockIds) =
    ...
/// Build a ``System.Func`` that returns a lock based on lockId and provide a list of lockIds.
/// If any of the locks are available, it will pick one of the available locks at random.
/// If none are available it will wait until one is, or ``timeOut`` has passed.
member x.AwaitOneOf&lt;'t&gt; (getLock : System.Func&lt;'t, Lock&gt;, lockIds, timeOut) =
    ...
</code></pre>

<p>```</p>

<p>As you can see, by the time we get to the <code>OneOf</code> members, we&rsquo;re pretty much
forced into taking higher order functions to avoid a combinatorial explosion of
members (not that that always seems to deter OO API designers&hellip;). Other than
that, I think we&rsquo;re left with an API which will immediately make sense to a C#
developer: you can new up a <code>LockProvider</code>, you have a specified list of
exception types to expect, and you can easily intellisense your way around all
of the available options.</p>

<p>Our C# consuming code ends up looking a bit like this:</p>

<p>``` csharp
using System;
using Sproc.Lock.OO;</p>

<p>namespace MyApp
{</p>

<pre><code>class Thing
{
    static void DoLockRequiringWork()
    {
        var provider = new LockProvider("sql connection string");
        try
        {
            using (var lock2 = provider.GlobalLock("MyAppLock", TimeSpan.FromMinutes(5.0)))
            {
                // If I get here, I have a lock!
                // Doing stuff!
            } // Lock released when Disposed
        }
        catch (LockUnavailableException)
        {
            // Could not get the lock
            throw;
        }
        catch (LockRequestErrorException)
        {
            // Getting the lock threw an error
            throw;
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Note the very different parameter order, placing the parameters that change most
frequently at the beginning of the list as you would normally expect in C#. This
makes a surprisingly large difference to how easy the code is to consume.</p>

<p>Again: quite nice, if I do say so myself.</p>

<p>So there you have it &ndash; want to take play nicely the whole .net ecosystem? Be
kind to your consumers, and build them an ecumenical API!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing ProvidedType.fs by Example]]></title>
    <link href="http://blog.mavnn.co.uk/testing-providedtype-dot-fs/"/>
    <updated>2015-02-16T12:12:56+00:00</updated>
    <id>http://blog.mavnn.co.uk/testing-providedtype-dot-fs</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/fsprojects/FSharp.TypeProviders.StarterPack">Type Provider Starter Pack</a> was designed with two purposes initially. Firstly, to be a canonical repository for the ProvidedTypes files which provide a source file based API for creating type providers. And secondly, to be a set of tutorials and examples for people wanting to dip their toes into building type providers for the first time.</p>

<p>To be honest, it&rsquo;s not been doing a complete job of either:</p>

<ul>
<li>I think most people are using it as the source of ProvidedTypes.fs and .fsi now days, but it didn&rsquo;t provide any infrastructure or testing for progressing the library.</li>
<li>The &ldquo;examples&rdquo; were limited to a link to my <a href="/type-providers-from-the-ground-up/">tutorial on building type providers</a></li>
</ul>


<p>Today, that&rsquo;s changed. And I need your help!</p>

<h3>Testing ProvidedTypes</h3>

<p>Once I started thinking about it, it became clear that the code needed for basic type provider examples, and the code needed to test ProvidedTypes.fs were basically identical.</p>

<p>So I implemented a system for compiling and testing example .fsx scripts within the Starter Pack repository.</p>

<p>Want to help out? As long as you have some basic git and F# knowledge, it&rsquo;s easy!</p>

<!-- more -->


<h4>Fork the repository and pull down a clone</h4>

<h4>Add an example to the <code>/examples</code> directory</h4>

<p>Structure the example as below and save it as an .fsx file:</p>

<p>``` fsharp</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;../src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;../src/ProvidedTypes.fs&rdquo;</h1>

<h1>endif</h1>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open System.Reflection</p>

<p>[<TypeProvider>]
type BasicProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "StaticProperty.Provided"
let asm = Assembly.GetExecutingAssembly()

let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true,
                                    GetterCode = (fun args -&gt; &lt;@@ "Hello world" @@&gt;))
    myType.AddMember(myProp)
    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>The <code>#if INTERACTIVE</code> block at the top will allow you to write your example in Visual Studio, without us requiring a separate project for each example provider.</p>

<h4>Add a set of tests in a .fsx script in the <code>/examples</code> directory</h4>

<p>The test file for the example above looks like this, and again should be saved as an .fsx file:</p>

<p>``` fsharp</p>

<h1>if INTERACTIVE</h1>

<h1>r @&ldquo;../packages/Nunit.Runners/tools/nunit.framework.dll&rdquo;</h1>

<h1>r @&ldquo;../test/StaticProperty.dll&rdquo;</h1>

<h1>endif</h1>

<p>open NUnit.Framework
open StaticProperty.Provided</p>

<p>[<Test>]
let <code>Static property should have been created</code> () =</p>

<pre><code>Assert.AreEqual("Hello world", MyType.MyProperty)
</code></pre>

<p>```</p>

<p>Note the two #r references at the top. Remember what you choose to call the dll!</p>

<h4>Hooking up the examples so they get built and tested</h4>

<p>The main build file is where the magic happens &ndash; <a href="https://github.com/fsprojects/FSharp.TypeProviders.StarterPack/blob/master/build.fsx">build.fsx</a> in the root directory.</p>

<p>Squirrelled away in there is a target called <code>Examples</code>. It&rsquo;s contents look like this:</p>

<p>``` fsharp
let examples =</p>

<pre><code>[
    {
        Name = "StaticProperty"
        ProviderSourceFiles = ["StaticProperty.fsx"]
        TestSourceFiles = ["StaticProperty.Tests.fsx"]
    }
    {
        Name = "ErasedWithConstructor"
        ProviderSourceFiles = ["ErasedWithConstructor.fsx"]
        TestSourceFiles = ["ErasedWithConstructor.Tests.fsx"]
    }
]
</code></pre>

<p>let testNunitDll = testDir @@ &ldquo;nunit.framework.dll&rdquo;</p>

<p>do</p>

<pre><code>if File.Exists testNunitDll then
    File.Delete testNunitDll
File.Copy (nunitDir @@ "nunit.framework.dll", testNunitDll)
</code></pre>

<p>let fromExampleDir filenames =</p>

<pre><code>filenames
|&gt; List.map (fun filename -&gt; exampleDir @@ filename)
</code></pre>

<p>examples
|> List.iter (fun example &ndash;></p>

<pre><code>    // Compile type provider
    let output = testDir @@ example.Name + ".dll"
    let setOpts = fun def -&gt; { def with Output = output; FscTarget = FscTarget.Library }
    Fsc setOpts (List.concat [pt;fromExampleDir example.ProviderSourceFiles])

    // Compile test dll
    let setTestOpts = fun def -&gt;
        { def with 
            Output = testDir @@ example.Name + ".Tests.dll"
            FscTarget = FscTarget.Library
            References = [output;nunitDir @@ "nunit.framework.dll"] }
    Fsc setTestOpts (fromExampleDir example.TestSourceFiles)
)
</code></pre>

<p>```</p>

<p>You will need to add your example to the <code>examples</code> list at the top of the target. <code>Name</code> is the name of the dll that will be produced for your type provider. <code>ProviderSourceFiles</code> is the fsx file with your type provider example code. And <code>TestSourceFiles</code> is the code of your tests.</p>

<p>If you check further down, the call to the compiler to compile your provider will automatically prepend the ProvidedTypes files, so there&rsquo;s no need to list those. And the call to the compiler to run your tests will have references added for the provider you just built and <code>nunit.framework.dll</code>.</p>

<p>So what are you waiting for? Get writing some examples!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RX Solutions]]></title>
    <link href="http://blog.mavnn.co.uk/rx-solutions/"/>
    <updated>2015-02-09T14:15:45+00:00</updated>
    <id>http://blog.mavnn.co.uk/rx-solutions</id>
    <content type="html"><![CDATA[<p>This post contains solutions to the <a href="/exploring-reactive-extensions/">Reactive Extensions practical</a> post.</p>

<!--more-->


<p>The base program looks like this (as in the previous post):</p>

<p>``` csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reactive;
using System.Reactive.Linq;
using ReactiveTester.Shared;</p>

<p>namespace EventTester
{</p>

<pre><code>class Program
{
    static void Handler(Tuple&lt;Guid, string&gt; tuple)
    {
        Console.WriteLine("{0} - {1}", tuple.Item1, tuple.Item2);
    }

    static void Error(Exception e)
    {
        var err = Console.OpenStandardError();
        using (var writer = new System.IO.StreamWriter(err, Console.OutputEncoding))
        {
            writer.WriteLine("{0}", e);
        }
    }

    static void Main(string[] args)
    {
        // Nice docs (although Java): http://reactivex.io/RxJava/javadoc/rx/Observable.html
        // The challenge:
        // The ChangeReceiver will fire an event every time a change is received.
        // Events can be:
        // "Ignore!" -&gt; don't do anything
        // "Change!" -&gt; send notification to staff and customers
        // "StaffOnly!" -&gt; send notification to staff
        // "CustomerOnly!" -&gt; send notification to customer only
        //
        // Staff must be notified within 3 seconds.
        // Customers most be notified between 5 and 7 seconds.
        using(var pub = new ChangeReceiver("tcp://*:5555"))
        {
            Console.WriteLine("Listening...");

            var staffSender = new NotificationSender("tcp://localhost:5556");
            var customerSender = new NotificationSender("tcp://localhost:5557");

            var obs = Observable.FromEventPattern&lt;Tuple&lt;Guid, string&gt;&gt;(pub, "ChangeRecieved").Select(ep =&gt; ep.EventArgs);
            obs.Subscribe&lt;Tuple&lt;Guid, string&gt;&gt;(Handler);
            obs.Select(t =&gt; t.Item1).Subscribe(guid =&gt; customerSender.Send(guid));

            //var err = Observable.FromEventPattern&lt;Exception&gt;(pub, "OnError").Select(ep =&gt; ep.EventArgs);
            //err.Subscribe&lt;Exception&gt;(Error);

            pub.Start();
            Console.ReadLine();
            Console.WriteLine("Closing down.");
        }
    }
}
</code></pre>

<p>}
```</p>

<p>None of the teams bothered with helper methods or anything refined like that &ndash; they only had about 40 minutes to produce anything it all. So, in each of the following cases, replace line 50 in the original code block with the submitted solution.</p>

<h3>Attempt 1:</h3>

<p>Simple, readable and minimalistic, our first contenders went with this.</p>

<p>``` csharp
obs.Where(t=>t.Item2 == &ldquo;StaffOnly!&rdquo; || t.Item2 == &ldquo;Change!&rdquo;).Select(t => t.Item1).Subscribe(guid => staffSender.Send(guid));</p>

<p>obs.Where(t=>t.Item2 == &ldquo;CustomerOnly!&rdquo; || t.Item2 == &ldquo;Change!&rdquo;).Delay(TimeSpan.FromSeconds(5)).Select(t => t.Item1).Subscribe(guid => customerSender.Send(guid));
```</p>

<p>As you can see, staff are notified immediately on either a <code>StaffOnly!</code> or <code>Change!</code> event &ndash; while customer events are delayed 5 seconds.</p>

<h3>Attempt 2:</h3>

<p>Group 2 played with RX&rsquo;s <code>GroupBy</code> method, which creates an Observable of Observables &ndash; each one of which only gets events that match the partitioning function.</p>

<p>Interesting stuff, although probably slightly overkill with 4 pre-known options.</p>

<p>```csharp
obs.GroupBy(x => x.Item2)</p>

<pre><code>.Subscribe(o =&gt;
{
    o.Where(x =&gt; x.Item2 == "StaffOnly!" || x.Item2 == "Change!")
        .Select(x =&gt; x.Item1)
        .Subscribe(staffSender.Send);
    o.Where(x =&gt; x.Item2 == "CustomerOnly!" || x.Item2 == "Change!")
        .Select(t =&gt; t.Item1)
        .Delay(TimeSpan.FromSeconds(6))
        .Subscribe(customerSender.Send);
});
</code></pre>

<p>```</p>

<p>It also still does the job fine.</p>

<h3>Attempt 3:</h3>

<p>With high points on pragmatism and clarity, group 3 just went with the absolute simplest solution. Just have 4 separate observables:</p>

<p><code>csharp
obs.Where(t =&gt; t.Item2.Equals("StaffOnly!")).Subscribe(staffOnly =&gt; staffSender.Send(staffOnly.Item1));
obs.Where(t =&gt; t.Item2.Equals("CustomerOnly!")).Delay(TimeSpan.FromSeconds(5)).Subscribe(customerOnly =&gt; customerSender.Send(customerOnly.Item1));
obs.Where(t =&gt; t.Item2.Equals("Change!")).Delay(TimeSpan.FromSeconds(5)).Subscribe(s =&gt; customerSender.Send(s.Item1));
obs.Where(t =&gt; t.Item2.Equals("Change!")).Subscribe(s =&gt; staffSender.Send(s.Item1));
</code></p>

<p>There&rsquo;s obviously much more to RX than you can learn in a single 1 hour practical session, but hopefully this gives you a feel and (if you followed along) takes away some of the fear of trying out this useful part of the .net ecosystem.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploring Reactive Extensions]]></title>
    <link href="http://blog.mavnn.co.uk/exploring-reactive-extensions/"/>
    <updated>2015-02-09T13:01:36+00:00</updated>
    <id>http://blog.mavnn.co.uk/exploring-reactive-extensions</id>
    <content type="html"><![CDATA[<p>The <a href="http://rx.codeplex.com/">Reactive Extensions</a> project is &ldquo;a library for composing asynchronous and event-based programs using observable sequences and LINQ-style query operators&rdquo;. That doesn&rsquo;t immediately give most people an intuitive grasp of exactly what it is &ndash; but it&rsquo;s a useful addition to the toolset so we put together a practical for people to experiment with.</p>

<p>At it&rsquo;s simplest, RX (as it&rsquo;s called&hellip; the Nuget package you&rsquo;re looking for is <a href="https://www.nuget.org/packages/Rx-Main">Rx-Main</a>, obviously!) allows you to create an <code>IObservable</code> object which you can then&hellip; erm&hellip; observe.</p>

<!--more-->


<p><code>IObservable</code> objects can, in turn, be observed by other <code>IObservable</code>s via a series of extension methods, and they will react when the original observable publishes a change. Hence &ldquo;Reactive Extensions&rdquo;. These extensions include all the normal Linq like things you&rsquo;ve come to know and expect in .net (<code>.Where</code> for filtering, <code>.Select</code> for mapping, etc) and also a selection of time based extensions which are the real meat of the reactive programming model. Things like <code>.Delay</code>, which
holds changes for a period of time before passing them on to subscribers. Or <code>.Throttle</code>, which throttles how quickly events can be passed through, and throws away events that are occurring too rapidly.</p>

<p>The best explanation of the various methods I&rsquo;ve seen is actually the <a href="http://reactivex.io/RxJava/javadoc/">reactivex.io javadocs</a>, which have diagram pictorially depicting the effect of each method. Although it&rsquo;s for Java, the method names are the same. For example, the <a href="http://reactivex.io/RxJava/javadoc/">sample method</a> comes with the following diagram:</p>

<p><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.png" alt="Sample method image" /></p>

<p>It shows quite nicely that sample will pick the last event of each interval (if there are any), and publish on only that.</p>

<p>The final part of the puzzle, once you&rsquo;ve done all your filtering, mapping, delaying and sampling is to hook up a Publish callback on your final <code>IObservable</code>.</p>

<p>Let&rsquo;s get to the example code!</p>

<h3>The scenario</h3>

<p>``` csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reactive;
using System.Reactive.Linq;
using ReactiveTester.Shared;</p>

<p>namespace EventTester
{</p>

<pre><code>class Program
{
    static void Handler(Tuple&lt;Guid, string&gt; tuple)
    {
        Console.WriteLine("{0} - {1}", tuple.Item1, tuple.Item2);
    }

    static void Error(Exception e)
    {
        var err = Console.OpenStandardError();
        using (var writer = new System.IO.StreamWriter(err, Console.OutputEncoding))
        {
            writer.WriteLine("{0}", e);
        }
    }

    static void Main(string[] args)
    {
        // Nice docs (although Java): http://reactivex.io/RxJava/javadoc/rx/Observable.html
        // The challenge:
        // The ChangeReceiver will fire an event every time a change is received.
        // Events can be:
        // "Ignore!" -&gt; don't do anything
        // "Change!" -&gt; send notification to staff and customers
        // "StaffOnly!" -&gt; send notification to staff
        // "CustomerOnly!" -&gt; send notification to customer only
        //
        // Staff must be notified within 3 seconds.
        // Customers most be notified between 5 and 7 seconds.
        using(var pub = new ChangeReceiver("tcp://*:5555"))
        {
            Console.WriteLine("Listening...");

            var staffSender = new NotificationSender("tcp://localhost:5556");
            var customerSender = new NotificationSender("tcp://localhost:5557");

            var obs = Observable.FromEventPattern&lt;Tuple&lt;Guid, string&gt;&gt;(pub, "ChangeRecieved").Select(ep =&gt; ep.EventArgs);
            obs.Subscribe&lt;Tuple&lt;Guid, string&gt;&gt;(Handler);
            obs.Select(t =&gt; t.Item1).Subscribe(guid =&gt; customerSender.Send(guid));

            //var err = Observable.FromEventPattern&lt;Exception&gt;(pub, "OnError").Select(ep =&gt; ep.EventArgs);
            //err.Subscribe&lt;Exception&gt;(Error);

            pub.Start();
            Console.ReadLine();
            Console.WriteLine("Closing down.");
        }
    }
}
</code></pre>

<p>}
```</p>

<p>The challenge was to complete the C# program above.</p>

<p>Want to follow along at home? The <a href="https://github.com/mavnn/RX-Practical">example code is on github</a>. Mind out &ndash; it&rsquo;s a bit big, as I included all of the binaries to get people going faster. The file in question is in the <code>EventTester</code> project as <code>Program.cs</code>.</p>

<p>The other program in the project (<code>ReactiveTester</code>) is test server. Right click on the solution, &ldquo;Set StartUp projects&rdquo; to run both on start up and hit <code>F5</code>. You should get two consoles pop up, something like this:</p>

<p><img src="/images/Reactive1.PNG" alt="/images/Reactive1.PNG" /></p>

<p>What&rsquo;s going on here? Well, as company <a href="http://15below.com">15below</a> deal with travel passenger communications, so the example stays close to home. The &ldquo;server&rdquo; (ReactiveTester, on the right) is masquerading as both an IROP (irregular operations, i.e. your flight has been cancelled due to insufficient chicken sarnies) system and as the staff and travellers who need to be told about events that are happening.</p>

<p>We&rsquo;re skipping any business logic identifying event types here, so for our purposes there are 4 types of events the system can issue.</p>

<ul>
<li>&ldquo;Ignore!&rdquo; &ndash;> we don&rsquo;t care about these</li>
<li>&ldquo;Change!&rdquo; &ndash;> both staff and travellers should be told about these</li>
<li>&ldquo;StaffOnly!&rdquo; &ndash;> only staff need to know about these ones</li>
<li>&ldquo;CustomerOnly!&rdquo; &ndash;> staff don&rsquo;t care about these, only tell the customer</li>
</ul>


<p>Our C# program then has a <code>ChangeReceiver</code> type that fires an event when a change is received, and a <code>NotificationSender</code> type it can use to send notifications out with. In reality, these go back to <code>ReactiveTester</code> that will then tell you if the notification arrived within the allowed window for either customer or staff.</p>

<p>The practical kicked off with the code at the state above. As you can see at line 48 we&rsquo;ve hooked up an observable object to the ChangeReceiver&rsquo;s ChangeReceived event &ndash; now we can observe events. We&rsquo;ve then hooked up a subscriber that fires the <code>Handler</code> method (line 14) which prints all changes to the command line. And a second subscriber that first maps the identifier/message tuple to the identifier and then sends a customer notification.</p>

<p>But wait&hellip;! Our test server keeps on saying &ldquo;Customer: early&rdquo;? And &ldquo;No guid xxx found&rdquo;? What gives?</p>

<p>Well&hellip; most travel companies are very keen for their staff to know about service alterations before customers. So the requirements we&rsquo;ve been given are that staff should be notified within 3 seconds &ndash; but customers only between 5 and 7 seconds. (In real life, these timings would probably be in minutes, obviously).</p>

<p>And the missing guid warnings are because the customers only care about some of the event types (see above). And, of course, the staff aren&rsquo;t getting any notifications at all, so their always complaining about them being late.</p>

<p>Your mission, should you choose to accept it: make everyone happy!</p>

<p>We had 3 teams take up the challenge; I&rsquo;ve posted their solutions in <a href="/rx-solutions/">a separate solutions post</a> to avoid accidental spoilers :)</p>

<p>P.S. A couple of people were interested in how the server worked. It&rsquo;s my very first attempt at writing both <a href="https://github.com/Hopac/Hopac">Hopac</a> and <a href="https://github.com/zeromq/fszmq">fszmq</a> (an F# zeromq wrapper library). I&rsquo;m hugely impressed by both, but wouldn&rsquo;t recommend my code in that repository as an introduction to either!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Persistent Data Structures]]></title>
    <link href="http://blog.mavnn.co.uk/persistent-data-structures/"/>
    <updated>2015-02-02T15:36:51+00:00</updated>
    <id>http://blog.mavnn.co.uk/persistent-data-structures</id>
    <content type="html"><![CDATA[<p>In last week&rsquo;s <a href="/keeping-up-with-the-latest-hammer/">Developer Education session</a> at <a href="http://15below.com">15below</a> we had a look at immutable and persistent data structures, and why you&rsquo;d want to use them.</p>

<blockquote><p>TL;DR version: are you writing performance critical, real time code? Do you have less memory available than a low end smart phone? No?</p>

<p>Use immutable data types everywhere you can.</p></blockquote>

<p>The session was inspired by <a href="https://twitter.com/ScottWlaschin">Scott Wlaschin</a>&rsquo;s excellent <a href="http://fsharpforfunandprofit.com/posts/is-your-language-unreasonable/">is your programming language unreasonable?</a> post. If you haven&rsquo;t read it yet, go and do so &ndash; it&rsquo;s much better than the rest of this post, and you can always come back here later if you remember.</p>

<p>One of the points that Scott raises is that code written with mutable data structures (ones that you can change after they&rsquo;ve been created) is very hard to reason about. In the very literal sense of working out the reason why things happen.</p>

<!-- more -->


<p>So we kicked off with a couple of examples of the dangers of mutability. Consider the following C# code.</p>

<p>``` csharp
static void Main(string[] args)
{</p>

<pre><code>var mercurial = new List&lt;string&gt; { "Bob" };
DoWork(mercurial);

if (mercurial.First() == "Bob")
{
    Console.WriteLine("Yay! We have Bob!");
}

DoSomeOtherWork();
// Actually get around to doing some work.
if (mercurial.First() == "Bob")
{
    Console.WriteLine("Success");
}
else
{
    Console.WriteLine("Oops, I updated {0}'s record by mistake.", mercurial.First());
}

Console.ReadLine();
</code></pre>

<p>}
```</p>

<p>Does it update Bob&rsquo;s record, or someone else&rsquo;s? Well &ndash; this is Scott&rsquo;s point. We&rsquo;ve passed the mutable <code>mercurial</code> object (here a <code>List</code>, but it could be anything mutable) into a function (<code>DoWork</code>), and now we don&rsquo;t know what will be done to it. Even if we check that it has the value we were expecting (line 6) there&rsquo;s no guarantee that it won&rsquo;t be changed under our nose. Which in fact, it is, because the rest of the code looks like this:</p>

<p>``` csharp
private static void DoSomeOtherWork()
{</p>

<pre><code>System.Threading.Thread.Sleep(500);
</code></pre>

<p>}</p>

<p>private static async void DoWork(List<string> Mercurial)
{</p>

<pre><code>new Immutable.Thing("Hello world", 1);
await Task.Delay(100);
Mercurial.Clear();
Mercurial.Add("Fred");
</code></pre>

<p>}
```</p>

<p>This example is clearly contrived &ndash; but these kinds of bugs crop up in code a lot, and it doesn&rsquo;t even need to be asynchronous for it to happen.</p>

<p>We then discussed equality, and the fact that it can be very hard to decide what equality means for a mutable object. Is a customer object the same as another customer object because they both have the same Id? Because they&rsquo;re both the same object in memory? Because they have the same value in all of their fields? What happens if one of the fields is changed? Overriding equality in .net <a href="http://visualstudiomagazine.com/articles/2011/02/01/equality-in-net.aspx">is not trivial</a>. Edit: found a
better article on the subject of <a href="http://www.aaronstannard.com/overriding-equality-in-dotnet/">C# equality</a> by Aaron Stannard.</p>

<p>Immutable objects cannot be changed, which means that they are nearly always defined as having value based equality. If all of the fields are equal, the object is equal &ndash; and it can&rsquo;t change, so you don&rsquo;t have to worry about it shifting under you. This is such a useful property (especially if you&rsquo;re loading data from another source that you want to run comparisons on) that we&rsquo;ve even had occasions here where we&rsquo;ve considered implementing our data types as <a href="https://msdn.microsoft.com/en-us/library/dd233184.aspx">F# records</a> even when writing C# services.</p>

<p>For example, you can define an F# record like this:</p>

<p>``` fsharp
// Yes, this is the entire file
module Immutable</p>

<p>type Thing =</p>

<pre><code>{
    One : string
    Two : int
}
</code></pre>

<p>```</p>

<p>And then use it from C# like this:</p>

<p>``` csharp
// You do need to reference the project with Thing in
static bool UseRecordTypeFromCSharp()
{</p>

<pre><code>var myThing = new Immutable.Thing("Hello", 11);
var myThing2 = new Immutable.Thing("Hello", 11);

return myThing == myThing2; // Always returns true
</code></pre>

<p>}
```</p>

<p>If all you need is an immutable collection, rather than an immutable
object with nice value based properties then you don&rsquo;t even need to
leave the comfort of your C# window. Microsoft themselves have bought
into the concept of immutable data structures sufficiently to release
an <a href="https://msdn.microsoft.com/en-us/library/dn385366%28v=vs.110%29.aspx">Immutable Collections</a> library.</p>

<h3>But what about the memory? Think of the RAM, the poor RAM!</h3>

<p>We also discussed the downsides of immutable data types. There are two concerns which are raised most frequently. The first is performance &ndash; in .net, using immutable data structures and then doing a lot of transforms on the data will create a lot of objects. This can have a significant effect in very performance critical areas of your code. This is a valid concern where performance is paramount, and the normal way around this is to wrap a private mutable object (or raw array, for
that matter) in a function that does all of your heavy manipulation. In that way you can take advantage of the speed of imperative coding techniques whilst keeping their scope small enough to reason about the effects.</p>

<p>Of course, even if <strong>speed</strong> isn&rsquo;t of paramount importance &ndash; what about <strong>memory</strong>? After all, these allocations must be adding up on the memory side of things as well, no?</p>

<p>Well, not as much as you might think, for two reasons. One is that if your code is asynchronous, you&rsquo;re almost certainly taking copies of your mutable data structures all over the place anyway to guarantee thread safety. Well, either that or you&rsquo;re taking a lot of locks, and you&rsquo;re back into performance issues.</p>

<p>The second, and much more interesting, reason is that a very bright guy called Chris Okasaki realised back in 1996 (despite the recent surge of interest in functional programming, it&rsquo;s not new&hellip;) that you can take advantage of the fact that an object is immutable to avoid copying all of it when a new, similar object is required.</p>

<p>For example, if you add a new object to the end of an immutable list, the new list you get back doesn&rsquo;t need to be a complete copy &ndash; it can just be the single new item with a pointer back to the original list. To the person using the list, it appears to be a three item list and they are none the wiser. Because it&rsquo;s immutable, the first two values never change, so it&rsquo;s never a concern to you whether your list is a completely new one, or a &ldquo;pointer&rdquo; list. Okasaki called these data
types &ldquo;persistent&rdquo; data types as they &ldquo;persist&rdquo; a previous version of themselves when &ldquo;modified&rdquo;. You can read more about them in a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">surprisingly complete wikipedia article</a>.</p>

<p>In .net land, both the F# immutable records and collections, and the <code>System.Collections.Immutable</code> library from Microsoft mentioned above are persistent data types. So unless you&rsquo;re extremely memory constrained, you should be good to go.</p>

<p>And there you have it. An introduction to immutable data types: officially approved for use almost everywhere by your local Technical Architect.</p>
]]></content>
  </entry>
  
</feed>
