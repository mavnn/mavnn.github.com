<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2015-05-21T16:33:52+01:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Serialization in .net]]></title>
    <link href="http://blog.mavnn.co.uk/serialization-in-net/"/>
    <updated>2015-05-20T16:11:28+01:00</updated>
    <id>http://blog.mavnn.co.uk/serialization-in-net</id>
    <content type="html"><![CDATA[<p>Leaving the confines of your own process&rsquo;s safe little memory space is always a potentially painful moment
when you&rsquo;re coding up an up. Whether it&rsquo;s receiving data from the outside world, passing a message over
RabbitMQ to an other in house service, or writing an audit trail that needs to be accessible for the next
20 years, there&rsquo;s a bunch of considerations that need to be taken into account when you hit the joys of
serialization and deserialization.</p>

<!-- more -->


<h2>Mirror, mirror on the wall</h2>

<p>First up on the list is whether or not to use reflection. For those of you who aren&rsquo;t aware, reflection
is a way of inspecting the properties of your .net code at runtime, and various serialization libraries
take advantage of this to try and make your life easier.</p>

<p>The best known example of this is <a href="http://www.newtonsoft.com/json">Json.NET</a> &ndash; which will take any .net
object and try and create a Json representation of it &ndash; or vice versa.</p>

<p>``` csharp
Product product = new Product();
product.Name = &ldquo;Apple&rdquo;;
product.Expiry = new DateTime(2008, 12, 28);
product.Sizes = new string[] { &ldquo;Small&rdquo; };</p>

<p>string json = JsonConvert.SerializeObject(product);
// {
//   &ldquo;Name&rdquo;: &ldquo;Apple&rdquo;,
//   &ldquo;Expiry&rdquo;: &ldquo;2008-12-28T00:00:00&rdquo;,
//   &ldquo;Sizes&rdquo;: [
//     &ldquo;Small&rdquo;
//   ]
// }
```</p>

<p>This is a common technique, but it does have a few problems.</p>

<h3>Versioning</h3>

<p>The &ldquo;schema&rdquo; here is actually the underlying .net type that you are serializing &ndash; this can be great for
quick to implement communications between .net services which can share a &ldquo;messages&rdquo; dll with the type in.</p>

<p>Unfortunately, this also plays merry havoc in any scenario where your messages might persist
between versions of your messaging dll. Saving these objects to a document store for example, or trying to run two versions of a service at once (required for seamless deployment)
connected to a messaging bus.</p>

<p>Because .net will only allow you to have one version of an assembly loaded at once, you can&rsquo;t
easily build a way of deserializing the old format.</p>

<h3>Uglyness</h3>

<p>This might sound like a purely aesthetic consideration, and therefore beneath us
technical types but the result of automatic serialization is often ugly and strange
looking. And to be fair, it isn&rsquo;t normally a huge problem for as long as you&rsquo;re working
in a .net to .net scenario. But if, for example, you&rsquo;re writing an API to be consumed
from JavaScript your UI developers (which is probably still you, right?) will curse your
name forever more if you go this route. As well as this, as there&rsquo;s no schema, it&rsquo;s very
hard to tell in any other language whether the object you&rsquo;ve created will make it through
the deserialization process when it hits .net land again.</p>

<h3>Runtime failure</h3>

<p>That <code>JsonConvert.SerializeObject</code> method up there: it&rsquo;s generic. Which means it will
take any .net object you want to throw at it.</p>

<p>Unfortunately, the number of .net objects it can actually serialize is quite a bit more
restricted than &ldquo;any .net object you want to throw at it&rdquo;. And it has no way of telling
you that until run time, when it will just throw an exception, which can be pretty painful.</p>

<h3>When to use?</h3>

<p>Only use reflection based serialization in situations where you know the serialized
representation will be transient, and where you can test your serialization works at
runtime in advance. Additional, be very suspicious of using reflection based serialization
in any scenario where anything outside the .net ecosystem will need to access the data.</p>

<p>Typical scenarios:</p>

<ul>
<li>Caching</li>
<li>Inter-process communication in distributed systems</li>
<li>Message bus communications (only if you can guarantee the messages are transient)</li>
</ul>


<p>Avoid for:</p>

<ul>
<li>Permanent persistence</li>
<li>Defining APIs to be used from outside .net</li>
</ul>


<h3>Recommended implementation</h3>

<p>If you are doing reflection based serialization in .net, you want to use
<a href="https://nessos.github.io/FsPickler/">FsPickler</a>. It covers binary, json, bson and xml
serialization in a single library, is faster than Json.NET and successfully serializes
more types than Json.NET. What&rsquo;s not to like?</p>

<h2>Attribute all the things!</h2>

<p>As well as just trying to guess how to serialize things with reflection in .net,
there is also the <a href="https://msdn.microsoft.com/en-us/library/system.serializableattribute%28v=vs.110%29.aspx">Serializable</a> attribute that allows you to then serialize to a variety
of formats using the <code>System.Runtime.Serialization</code> name space. This a few advantages
over the raw reflection technique in theory (you can mark specific fields not to be serialized, for example) but to be blunt if you&rsquo;re going to go to this amount of effort you may
as well go for one of the safer options below.</p>

<h3>When to use?</h3>

<p>When you&rsquo;re using a Microsoft library that requires you to.</p>

<h2>Safety with (type) class</h2>

<p>If you happen to be working in F#, then <a href="https://msdn.microsoft.com/en-us/library/dd233203.aspx">member constraints</a> allow you to try a more flexible and type safe way of expressing
serialization &ndash; in exchange for a little more work.</p>

<p>As an example, the Chiron library allows you to do things like this:</p>

<p>``` fsharp
open Chiron
open Chiron.Operators</p>

<p>type InnerRecord =</p>

<pre><code>{
    Start : System.DateTime
    Id : System.Guid
}
static member FromJson (_ : InnerRecord) =
    (fun s i -&gt; { Start = s; Id = i })
    &lt;!&gt; Json.read "startTime"
    &lt;*&gt; Json.read "identity"
static member ToJson innerRecord =
    Json.write "startTime" innerRecord.Start
    *&gt; Json.write "identity" innerRecord.Id
</code></pre>

<p>type OuterRecord =</p>

<pre><code>{
    Name : string
    Inner : InnerRecord
}
static member FromJson (_ : OuterRecord) =
    (fun n i -&gt; { Name = n; Inner = i })
    &lt;!&gt; Json.read "name"
    &lt;*&gt; Json.read "inner"
static member ToJson outerRecord =
    Json.write "name" outerRecord.Name
    *&gt; Json.write "inner" outerRecord.Inner
</code></pre>

<p>{
  Name = &ldquo;my object&rdquo;
  Inner = {</p>

<pre><code>        Start = System.DateTime(2015, 5, 21)
        Id = System.Guid.NewGuid()
      }
</code></pre>

<p>}
|> Json.serialize
|> Json.format
// Your json goes here
```</p>

<p>A few interesting things to note here. Firstly, as you&rsquo;ve probably guessed, the magic
of telling Chiron how to serialize and deserialize things happens in the <code>ToJson</code> and
<code>FromJson</code> methods. What might not be so obvious is that if these methods are not
implemented with the correct signature, than <code>Json.serialize</code> will not compile when
fed the erroneous object. Which does wonders for eliminating run time errors!</p>

<p>Also, if you look carefully at the To and From methods you&rsquo;ll see that there&rsquo;s no need
for the fields in the Json and the .net object to have the same name. In fact, you can
apply what ever logic you want within them, allowing you to match a specific schema,
allow for different versions of the serialized data to be deserialized or just generally
make the serialized version prettier to use from other places.</p>

<p>You do, of course, have to actually write the From and To methods, which is definitely
more work. Having said that, it&rsquo;s not quite as bad as it sounds though: as you can see
from the <code>OuterRecord</code> type with it&rsquo;s <code>InnerRecord</code> field, and can nest the To and
From methods nicely &ndash; and the type system will check that your object is serializable
all the way down. Nice.</p>

<h3>When to use?</h3>

<p>Any time when you might have to persist data between versions, or process data during
the serialization/deserialization process &ndash; and you can specify your data types in F#.</p>

<h3>Recommended implementation</h3>

<p><a href="https://github.com/mausch/Fleece">Fleece</a> and <a href="https://github.com/xyncro/chiron/">Chiron</a>
both implement these techniques. Fleece is a more established library that has been tested
for longer, but I have had some performance issues with it in libraries with a lot of types
that implement To and From methods. Chiron is a little bit&hellip; cutting edge in age, but
has always been fast and reliable for me so far.</p>

<p>We currently use Fleece in one of our projects, and have provided some support to improving
the testing of Chiron as it looks like a hopeful alternative.</p>

<h2>All the rest</h2>

<p>I&rsquo;m sure that there are other ways of tackling these problems &ndash; for example, for our
customer facing &ldquo;business&rdquo; APIs we&rsquo;re moving to specifying our API using hand crafted
XSD and WSDL files and then autogenerating code behind. This assumes, of course, you
have some reason to be using SOAP. But if you do, it works an awful lot better than
trying to autogenerate the schema from the code &ndash; a path that&rsquo;s lead me to worlds of
pain both as the consumer and producer of the schemas.</p>

<p>But the routes above are the most common paths that I&rsquo;ve come across as a .net developer
and I&rsquo;ve often discovered them being used in the &ldquo;wrong&rdquo; places. Retroactively having to
version reflection based APIs is a particular pain point that I&rsquo;d recommend avoiding if
you possibly can!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[API Design Workshop]]></title>
    <link href="http://blog.mavnn.co.uk/api-design-workshop/"/>
    <updated>2015-05-07T15:35:51+01:00</updated>
    <id>http://blog.mavnn.co.uk/api-design-workshop</id>
    <content type="html"><![CDATA[<p>Designing an API is hard.</p>

<p>You want to actually apply the
<a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a> &ndash;
but you&rsquo;re the person who wrote the code. You&rsquo;re unlikely to be astonished. So
you&rsquo;re trying to think how someone who didn&rsquo;t know what you know would think &ndash;
which is never an easy starting point!</p>

<p>Similarly, you&rsquo;re trying to create the
<a href="http://blog.codinghorror.com/falling-into-the-pit-of-success/">pit of success</a>
for users. Which means trying to make it <em>very hard</em> to do the wrong thing with
your API. Preferably, in strongly typed languages, this should include using the
type system to
<a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">make illegal states unrepresentable</a>
so that code that compiles is very likely to work.</p>

<p>In general, the core libraries for .net are not bad at API design, but there are
a few places where this isn&rsquo;t true. As an exercise, we at
<a href="http://www.15below.com/">15below</a> are going to take one of them, split into
teams and spend an hour or so seeing what alternatives we can come up with. Feel
free to follow along at home, and if you do give it a try ping me a code snippet
and I&rsquo;ll post it up with our internal attempts in a week or so.</p>

<!-- more -->


<h2>The API</h2>

<p>Lots of things can be represented as streams of data. Files, network
connections, compressed archives, chunks of memory&hellip; the list goes on.</p>

<p>So .net provides us with the <a href="https://msdn.microsoft.com/en-us/library/system.io.stream%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396"><code>System.IO.Stream</code> class</a>.</p>

<p>Which is great and all&hellip; except that not all streams are equal. For example,
your function might need write access to a stream, and not all streams are
writable. You can check easily enough, but the only way of flagging to the user
you need write access is via comments or naming conventions. The same is true
for requiring the ability to read from the stream or seek to specific locations
with in it.</p>

<h2>The challenge</h2>

<p>Have a look through the interface provided by <code>System.IO.Stream</code>. Create a
skeleton of an API that could implement the same functionality, be reasonably
easy to use and tries to make illegal states unrepresentable as much as
possible. Note: this API does <em>not</em> have to be functional.</p>

<p>Try adding a few example methods that make use of your API (hint: your design
will probably be better if you write these first).</p>

<p>Maybe you want to try using interfaces and
<a href="http://stackoverflow.com/questions/3663739/method-parameter-with-multiple-interface-restrictions">multiple interface constraints</a>. Or
you have some clever idea for representing things with
<a href="http://fsharpforfunandprofit.com/posts/discriminated-unions/">discriminated unions</a>. Or
maybe you just know that there&rsquo;s a better core library out there with a nicer
representation you can rip off whole sale! Who knows?</p>

<p>Post your work up somewhere it can be seen on the internet and ping me a link,
and we&rsquo;ll go over the submissions and write up a commentary over the next week
or two.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ecumenical APIs]]></title>
    <link href="http://blog.mavnn.co.uk/ecumenical-apis/"/>
    <updated>2015-05-06T10:44:16+01:00</updated>
    <id>http://blog.mavnn.co.uk/ecumenical-apis</id>
    <content type="html"><![CDATA[<p>One of the big sells of shared runtime functional languages such as F#, Scala
and Clojure is that you can carrying on using the surrounding library ecosystem
and your existing code. The different paradigm occasionally causes a little
pain, but there are plenty of blog posts about how to wrap OO interfaces in a
functionally friendly way.</p>

<p>This is not one of those blog posts. This is about making sure that your
colleagues who are consuming your shiny new code in an imperative language
(generally C# in my case) don&rsquo;t threaten to defenestrate you.</p>

<p>At <a href="http://15below.com">15below</a> we&rsquo;ve recently had need in some of our services
of taking a distributed lock between servers. There are many services available
designed for doing this, but after some deliberation we decided that we didn&rsquo;t
want to add a new piece of infrastructure purely for this one purpose. So
<a href="http://15below.github.io/Sproc.Lock">Sproc.Lock</a> was born: SQL Server based
distributed locking.</p>

<p>In this post, I&rsquo;m not going to talk about the design of the service. What I&rsquo;m
going to write about is how I engineered the API to be pleasent to use from both
C# and F#, giving a idiomatic interface from both languages.</p>

<!-- more -->


<h2>The original interface (F#)</h2>

<p>The F# interface was written first, and follows a pattern that will feel
immediately familiar to an F# programmer. Our lock can be of 3 types (global,
organisation or environment) and so we have a discriminated union (<code>Lock</code>)
representing these three options.</p>

<p>(I&rsquo;ve removed the implementations of the various bits to leave the shape of the
code clear)</p>

<p>``` fsharp
/// Type representing a Lock that has definitely been acquired. Locks are
/// IDisposable; disposing the lock will ensure it is released.
type Lock =</p>

<pre><code> /// A lock that applies globally across the lock server
 | Global of ...
 /// A lock scoped to a specific organisation
 | Organisation of ...
 /// A lock scoped to a particular environment belonging to a particular organisation
 | Environment of ...
 /// The LockId acquired. Useful in combination when getting one of a list of locks to determine which was free.
 member lock.LockId =
     ...
 /// Disposing releases the lock
 member lock.Dispose () =
     ...
 interface IDisposable with
     /// Disposing releases the lock
     member lock.Dispose () =
        lock.Dispose()
</code></pre>

<p>```</p>

<p>The lock is <code>IDisposable</code> to take advantage of .net&rsquo;s most common resource
management idiom. You can release a lock by disposing it.</p>

<p>Then, of course, when we try and acquire a lock we may or may not be able to &ndash;
the whole point of locks is that you cannot obtain them if someone else has
locked it already, after all.</p>

<p>So we have a second discriminated union (<code>LockResult</code>) wrapping the first,
with (again) three potential cases:</p>

<p>``` fsharp
/// A type representing the possible results of attempting to acquire a lock.
type LockResult =</p>

<pre><code> /// A lock was successfully acquired
 | Locked of Lock
 /// No lock was available
 | Unavailable
 /// The attempt to acquire a lock caused an error in SQL Server
 | Error of int
 /// Disposing a lock result disposes the lock if it was acquired, and has no effect otherwise
 member x.Dispose () =
    match x with
    | Locked l -&gt; l.Dispose()
    | Unavailable -&gt; ()
    | Error _ -&gt; ()
 interface IDisposable with
    member x.Dispose () =
        x.Dispose()
</code></pre>

<p>```</p>

<p>Again, this is <code>IDisposable</code> so that you can just dispose of your overall
<code>LockResult</code> object which makes a lot of the code cleaner.</p>

<p>So: how do we get a <code>LockResult</code>? Well, we have a set of functions for getting
locks. Let&rsquo;s have a look at the skeleton of one of them:</p>

<p>``` fsharp
// val GetOrganisationLock : string &ndash;> string &ndash;> TimeSpan &ndash;> string &ndash;> LockResult
let GetOrganisationLock connString organisation (maxDuration : TimeSpan) lockIdentifier =</p>

<pre><code>...
</code></pre>

<p>```</p>

<p>What&rsquo;s this doing? Well, it&rsquo;s going to (try and) create a lock scoped to a
particular database and organisation with a particular ID, returning a
<code>LockResult</code>.</p>

<p>From an API design point of view, what&rsquo;s interesting here is the order of the
arguments. <a href="https://en.wikipedia.org/wiki/Currying">Currying</a> enables easy
partial application, and here it is very likely that the application will want
to take all locks from the same database (making the first parameter) and
reasonably likely that it will always want them scoped to the same organisation
(second parameter). This is a common pattern in languages that allow for easy
currying, and invariably a consumer of this library in F# will end up with a
partially applied helper function looking something like this:</p>

<p>``` fsharp
// val getLock : string &ndash;> LockResult
let getLock =</p>

<pre><code>GetOrganisationLock "myDbConnString" "OrgName" (TimeSpan.FromMinutes 5.)
</code></pre>

<p>```</p>

<p>We also have a set of helper functions for common operations we might want to
carry out on locks, all of which take a higher order function as part of their
arguments. Let&rsquo;s have a look at <code>AwaitLock</code> which will wait for a lock to
become available for a specified length of time, rather then returning
immediately with an <code>Unavailable</code> result:</p>

<p>``` fsharp
// val AwaitLock : TimeSpan &ndash;> (unit &ndash;> LockResult) &ndash;> LockResult
let AwaitLock (timeOut : TimeSpan) getLock =</p>

<pre><code>...
</code></pre>

<p>// Using it using the helper above:
let awaitMyLock identifier =</p>

<pre><code>AwaitLock (TimeSpan.FromSeconds 2.) (getLock identifier)
</code></pre>

<p>```</p>

<p>If we then want (say) to wait up to 2 seconds for one of a list of possible
locks to become available, we can then compose this function with the
<code>OneOfLocks</code> function:</p>

<p>``` fsharp
// val OneOfLocks : (&lsquo;a &ndash;> LockResult) &ndash;> seq&lt;'a> &ndash;> LockResult
let OneOfLocks getLock lockIds =</p>

<pre><code>...
</code></pre>

<p>// Using it using await helper:
let pickLock () =</p>

<pre><code>OneOfLocks awaitMyLock ["LockId1";"LockId2"] 
</code></pre>

<p>```</p>

<p>I&rsquo;m sure the comments will disagree, but I&rsquo;m actually pretty happy with this as
an F# interface to this library. It&rsquo;s not strictly pure, but that&rsquo;s an option in
F#, and the combination of composable functions and careful choice of parameter
order make for concise and readable code.</p>

<p>So, we&rsquo;re done &ndash; right?</p>

<p>Unfortunately not. This code would be truely horrible to use from C#, and we
still use a lot of C# here &ndash; some of our (stranger?) developers even prefer
it. Why would it be so nasty?</p>

<ul>
<li>Consuming discriminated unions from C# is verbose to the point of unusable</li>
<li>Partial application is a pain in C#, and no one wants to repeat the connection
string everytime they want a lock</li>
<li>Function composition is possible in C# but is not idiomatic and may make the
capabilities of the library unclear</li>
</ul>


<h2>API Take 2: the &ldquo;OO&rdquo; namespace</h2>

<p>In thinking about the kind of API I would expect for a locking library in C#, a
few things immediately sprang to mind:</p>

<ul>
<li>I would expect some kind of configurable provider object or factory</li>
<li>Out of flow returns are normally signalled by exceptions</li>
<li>Function composition only for more unusual calling options</li>
</ul>


<p>Wrapping the functional API turned out to be reasonably simple. A couple of
custom exception types and the <code>OOise</code> method later (I love that function
name, even if I say so myself) we can easily wrap our functional API in
something that makes sense in C# land &ndash; they either return an acquired,
<code>IDisposable</code> lock or throw.</p>

<p><code>` fsharp
/// Exception thrown by</code>LockProvider`` if none of the specified locks are available.
type LockUnavailableException (message) =</p>

<pre><code>inherit System.Exception(message)
</code></pre>

<p>/// Exception thrown by <code>LockProvider</code> if a lock request errors on SQL Server.
/// <code>LockErrorCode</code> is the SQL error response.
type LockRequestErrorException (errorCode) as this =</p>

<pre><code>inherit System.Exception(sprintf "Error code: %d" errorCode)
do
    this.Data.Add(box "ErrorCode", box errorCode)
member x.LockErrorCode
    with get () =
        x.Data.["ErrorCode"] |&gt; unbox&lt;int&gt;
</code></pre>

<p>let private OOise lockId getLock =</p>

<pre><code>match getLock lockId with
| Locked l -&gt; l
| Unavailable -&gt; raise &lt;| LockUnavailableException(sprintf "Lock %s was unavailable." lockId)
| Error i -&gt; raise &lt;| LockRequestErrorException i
</code></pre>

<p>```</p>

<p>Then, a simple <code>LockProvider</code> class allows for all the normal patterns we&rsquo;ve
come to know (and in some cases love) such as dependency injection:</p>

<p>``` fsharp
type LockProvider (connString : string) =</p>

<pre><code>member x.GlobalLock (lockId, maxDuration) =
    GetGlobalLock connString maxDuration |&gt; OOise lockId
member x.OrganisationLock (lockId, organisation, maxDuration) =
    // Rest of the implementations snipped
    ...
member x.EnvironmentLock (lockId, organisation, environment, maxDuration) =
    ...
member x.AwaitGlobalLock (lockId, maxDuration, timeOut) =
    ...
member x.AwaitOrganisationLock (lockId, organisation, maxDuration, timeOut) =
    ...
member x.AwaitEnvironmentLock (lockId, organisation, environment, maxDuration, timeOut) =
    ...
/// Build a ``System.Func`` that returns a lock based on lockId and provide a list of lockIds.
/// If any of the locks are available, it will pick one of the available locks at random.
member x.OneOf&lt;'t&gt; (getLock : System.Func&lt;'t, Lock&gt;, lockIds) =
    ...
/// Build a ``System.Func`` that returns a lock based on lockId and provide a list of lockIds.
/// If any of the locks are available, it will pick one of the available locks at random.
/// If none are available it will wait until one is, or ``timeOut`` has passed.
member x.AwaitOneOf&lt;'t&gt; (getLock : System.Func&lt;'t, Lock&gt;, lockIds, timeOut) =
    ...
</code></pre>

<p>```</p>

<p>As you can see, by the time we get to the <code>OneOf</code> members, we&rsquo;re pretty much
forced into taking higher order functions to avoid a combinatorial explosion of
members (not that that always seems to deter OO API designers&hellip;). Other than
that, I think we&rsquo;re left with an API which will immediately make sense to a C#
developer: you can new up a <code>LockProvider</code>, you have a specified list of
exception types to expect, and you can easily intellisense your way around all
of the available options.</p>

<p>Our C# consuming code ends up looking a bit like this:</p>

<p>``` csharp
using System;
using Sproc.Lock.OO;</p>

<p>namespace MyApp
{</p>

<pre><code>class Thing
{
    static void DoLockRequiringWork()
    {
        var provider = new LockProvider("sql connection string");
        try
        {
            using (var lock2 = provider.GlobalLock("MyAppLock", TimeSpan.FromMinutes(5.0)))
            {
                // If I get here, I have a lock!
                // Doing stuff!
            } // Lock released when Disposed
        }
        catch (LockUnavailableException)
        {
            // Could not get the lock
            throw;
        }
        catch (LockRequestErrorException)
        {
            // Getting the lock threw an error
            throw;
        }
    }
}
</code></pre>

<p>}
```</p>

<p>Note the very different parameter order, placing the parameters that change most
frequently at the beginning of the list as you would normally expect in C#. This
makes a surprisingly large difference to how easy the code is to consume.</p>

<p>Again: quite nice, if I do say so myself.</p>

<p>So there you have it &ndash; want to play nicely the whole .net ecosystem? Be
kind to your consumers, and build them an ecumenical API!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing ProvidedType.fs by Example]]></title>
    <link href="http://blog.mavnn.co.uk/testing-providedtype-dot-fs/"/>
    <updated>2015-02-16T12:12:56+00:00</updated>
    <id>http://blog.mavnn.co.uk/testing-providedtype-dot-fs</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/fsprojects/FSharp.TypeProviders.StarterPack">Type Provider Starter Pack</a> was designed with two purposes initially. Firstly, to be a canonical repository for the ProvidedTypes files which provide a source file based API for creating type providers. And secondly, to be a set of tutorials and examples for people wanting to dip their toes into building type providers for the first time.</p>

<p>To be honest, it&rsquo;s not been doing a complete job of either:</p>

<ul>
<li>I think most people are using it as the source of ProvidedTypes.fs and .fsi now days, but it didn&rsquo;t provide any infrastructure or testing for progressing the library.</li>
<li>The &ldquo;examples&rdquo; were limited to a link to my <a href="/type-providers-from-the-ground-up/">tutorial on building type providers</a></li>
</ul>


<p>Today, that&rsquo;s changed. And I need your help!</p>

<h3>Testing ProvidedTypes</h3>

<p>Once I started thinking about it, it became clear that the code needed for basic type provider examples, and the code needed to test ProvidedTypes.fs were basically identical.</p>

<p>So I implemented a system for compiling and testing example .fsx scripts within the Starter Pack repository.</p>

<p>Want to help out? As long as you have some basic git and F# knowledge, it&rsquo;s easy!</p>

<!-- more -->


<h4>Fork the repository and pull down a clone</h4>

<h4>Add an example to the <code>/examples</code> directory</h4>

<p>Structure the example as below and save it as an .fsx file:</p>

<p>``` fsharp</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;../src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;../src/ProvidedTypes.fs&rdquo;</h1>

<h1>endif</h1>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open System.Reflection</p>

<p>[<TypeProvider>]
type BasicProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "StaticProperty.Provided"
let asm = Assembly.GetExecutingAssembly()

let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true,
                                    GetterCode = (fun args -&gt; &lt;@@ "Hello world" @@&gt;))
    myType.AddMember(myProp)
    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>The <code>#if INTERACTIVE</code> block at the top will allow you to write your example in Visual Studio, without us requiring a separate project for each example provider.</p>

<h4>Add a set of tests in a .fsx script in the <code>/examples</code> directory</h4>

<p>The test file for the example above looks like this, and again should be saved as an .fsx file:</p>

<p>``` fsharp</p>

<h1>if INTERACTIVE</h1>

<h1>r @&ldquo;../packages/Nunit.Runners/tools/nunit.framework.dll&rdquo;</h1>

<h1>r @&ldquo;../test/StaticProperty.dll&rdquo;</h1>

<h1>endif</h1>

<p>open NUnit.Framework
open StaticProperty.Provided</p>

<p>[<Test>]
let <code>Static property should have been created</code> () =</p>

<pre><code>Assert.AreEqual("Hello world", MyType.MyProperty)
</code></pre>

<p>```</p>

<p>Note the two #r references at the top. Remember what you choose to call the dll!</p>

<h4>Hooking up the examples so they get built and tested</h4>

<p>The main build file is where the magic happens &ndash; <a href="https://github.com/fsprojects/FSharp.TypeProviders.StarterPack/blob/master/build.fsx">build.fsx</a> in the root directory.</p>

<p>Squirrelled away in there is a target called <code>Examples</code>. It&rsquo;s contents look like this:</p>

<p>``` fsharp
let examples =</p>

<pre><code>[
    {
        Name = "StaticProperty"
        ProviderSourceFiles = ["StaticProperty.fsx"]
        TestSourceFiles = ["StaticProperty.Tests.fsx"]
    }
    {
        Name = "ErasedWithConstructor"
        ProviderSourceFiles = ["ErasedWithConstructor.fsx"]
        TestSourceFiles = ["ErasedWithConstructor.Tests.fsx"]
    }
]
</code></pre>

<p>let testNunitDll = testDir @@ &ldquo;nunit.framework.dll&rdquo;</p>

<p>do</p>

<pre><code>if File.Exists testNunitDll then
    File.Delete testNunitDll
File.Copy (nunitDir @@ "nunit.framework.dll", testNunitDll)
</code></pre>

<p>let fromExampleDir filenames =</p>

<pre><code>filenames
|&gt; List.map (fun filename -&gt; exampleDir @@ filename)
</code></pre>

<p>examples
|> List.iter (fun example &ndash;></p>

<pre><code>    // Compile type provider
    let output = testDir @@ example.Name + ".dll"
    let setOpts = fun def -&gt; { def with Output = output; FscTarget = FscTarget.Library }
    Fsc setOpts (List.concat [pt;fromExampleDir example.ProviderSourceFiles])

    // Compile test dll
    let setTestOpts = fun def -&gt;
        { def with 
            Output = testDir @@ example.Name + ".Tests.dll"
            FscTarget = FscTarget.Library
            References = [output;nunitDir @@ "nunit.framework.dll"] }
    Fsc setTestOpts (fromExampleDir example.TestSourceFiles)
)
</code></pre>

<p>```</p>

<p>You will need to add your example to the <code>examples</code> list at the top of the target. <code>Name</code> is the name of the dll that will be produced for your type provider. <code>ProviderSourceFiles</code> is the fsx file with your type provider example code. And <code>TestSourceFiles</code> is the code of your tests.</p>

<p>If you check further down, the call to the compiler to compile your provider will automatically prepend the ProvidedTypes files, so there&rsquo;s no need to list those. And the call to the compiler to run your tests will have references added for the provider you just built and <code>nunit.framework.dll</code>.</p>

<p>So what are you waiting for? Get writing some examples!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RX Solutions]]></title>
    <link href="http://blog.mavnn.co.uk/rx-solutions/"/>
    <updated>2015-02-09T14:15:45+00:00</updated>
    <id>http://blog.mavnn.co.uk/rx-solutions</id>
    <content type="html"><![CDATA[<p>This post contains solutions to the <a href="/exploring-reactive-extensions/">Reactive Extensions practical</a> post.</p>

<!--more-->


<p>The base program looks like this (as in the previous post):</p>

<p>``` csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reactive;
using System.Reactive.Linq;
using ReactiveTester.Shared;</p>

<p>namespace EventTester
{</p>

<pre><code>class Program
{
    static void Handler(Tuple&lt;Guid, string&gt; tuple)
    {
        Console.WriteLine("{0} - {1}", tuple.Item1, tuple.Item2);
    }

    static void Error(Exception e)
    {
        var err = Console.OpenStandardError();
        using (var writer = new System.IO.StreamWriter(err, Console.OutputEncoding))
        {
            writer.WriteLine("{0}", e);
        }
    }

    static void Main(string[] args)
    {
        // Nice docs (although Java): http://reactivex.io/RxJava/javadoc/rx/Observable.html
        // The challenge:
        // The ChangeReceiver will fire an event every time a change is received.
        // Events can be:
        // "Ignore!" -&gt; don't do anything
        // "Change!" -&gt; send notification to staff and customers
        // "StaffOnly!" -&gt; send notification to staff
        // "CustomerOnly!" -&gt; send notification to customer only
        //
        // Staff must be notified within 3 seconds.
        // Customers most be notified between 5 and 7 seconds.
        using(var pub = new ChangeReceiver("tcp://*:5555"))
        {
            Console.WriteLine("Listening...");

            var staffSender = new NotificationSender("tcp://localhost:5556");
            var customerSender = new NotificationSender("tcp://localhost:5557");

            var obs = Observable.FromEventPattern&lt;Tuple&lt;Guid, string&gt;&gt;(pub, "ChangeRecieved").Select(ep =&gt; ep.EventArgs);
            obs.Subscribe&lt;Tuple&lt;Guid, string&gt;&gt;(Handler);
            obs.Select(t =&gt; t.Item1).Subscribe(guid =&gt; customerSender.Send(guid));

            //var err = Observable.FromEventPattern&lt;Exception&gt;(pub, "OnError").Select(ep =&gt; ep.EventArgs);
            //err.Subscribe&lt;Exception&gt;(Error);

            pub.Start();
            Console.ReadLine();
            Console.WriteLine("Closing down.");
        }
    }
}
</code></pre>

<p>}
```</p>

<p>None of the teams bothered with helper methods or anything refined like that &ndash; they only had about 40 minutes to produce anything it all. So, in each of the following cases, replace line 50 in the original code block with the submitted solution.</p>

<h3>Attempt 1:</h3>

<p>Simple, readable and minimalistic, our first contenders went with this.</p>

<p>``` csharp
obs.Where(t=>t.Item2 == &ldquo;StaffOnly!&rdquo; || t.Item2 == &ldquo;Change!&rdquo;).Select(t => t.Item1).Subscribe(guid => staffSender.Send(guid));</p>

<p>obs.Where(t=>t.Item2 == &ldquo;CustomerOnly!&rdquo; || t.Item2 == &ldquo;Change!&rdquo;).Delay(TimeSpan.FromSeconds(5)).Select(t => t.Item1).Subscribe(guid => customerSender.Send(guid));
```</p>

<p>As you can see, staff are notified immediately on either a <code>StaffOnly!</code> or <code>Change!</code> event &ndash; while customer events are delayed 5 seconds.</p>

<h3>Attempt 2:</h3>

<p>Group 2 played with RX&rsquo;s <code>GroupBy</code> method, which creates an Observable of Observables &ndash; each one of which only gets events that match the partitioning function.</p>

<p>Interesting stuff, although probably slightly overkill with 4 pre-known options.</p>

<p>```csharp
obs.GroupBy(x => x.Item2)</p>

<pre><code>.Subscribe(o =&gt;
{
    o.Where(x =&gt; x.Item2 == "StaffOnly!" || x.Item2 == "Change!")
        .Select(x =&gt; x.Item1)
        .Subscribe(staffSender.Send);
    o.Where(x =&gt; x.Item2 == "CustomerOnly!" || x.Item2 == "Change!")
        .Select(t =&gt; t.Item1)
        .Delay(TimeSpan.FromSeconds(6))
        .Subscribe(customerSender.Send);
});
</code></pre>

<p>```</p>

<p>It also still does the job fine.</p>

<h3>Attempt 3:</h3>

<p>With high points on pragmatism and clarity, group 3 just went with the absolute simplest solution. Just have 4 separate observables:</p>

<p><code>csharp
obs.Where(t =&gt; t.Item2.Equals("StaffOnly!")).Subscribe(staffOnly =&gt; staffSender.Send(staffOnly.Item1));
obs.Where(t =&gt; t.Item2.Equals("CustomerOnly!")).Delay(TimeSpan.FromSeconds(5)).Subscribe(customerOnly =&gt; customerSender.Send(customerOnly.Item1));
obs.Where(t =&gt; t.Item2.Equals("Change!")).Delay(TimeSpan.FromSeconds(5)).Subscribe(s =&gt; customerSender.Send(s.Item1));
obs.Where(t =&gt; t.Item2.Equals("Change!")).Subscribe(s =&gt; staffSender.Send(s.Item1));
</code></p>

<p>There&rsquo;s obviously much more to RX than you can learn in a single 1 hour practical session, but hopefully this gives you a feel and (if you followed along) takes away some of the fear of trying out this useful part of the .net ecosystem.</p>
]]></content>
  </entry>
  
</feed>
