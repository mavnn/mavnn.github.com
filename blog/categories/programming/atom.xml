<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2014-10-08T11:48:43+01:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functionally SOLID 2]]></title>
    <link href="http://blog.mavnn.co.uk/functionally-solid-2/"/>
    <updated>2014-05-09T13:43:02+01:00</updated>
    <id>http://blog.mavnn.co.uk/functionally-solid-2</id>
    <content type="html"><![CDATA[<p><em>This post follows on directly from <a href="/going-functionally-solid">Going Functionally SOLID</a></em></p>

<p>In our first session looking at <a href="http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29">SOLID</a> and functional programming, we tried to apply some SOLID principles to an example piece of code.</p>

<p>We ended up with a set of interfaces like those below, and robot classes could then implement the interfaces to define their capabilities and state. I mentioned the example code was for a giant robot game, yes?</p>

<!-- more -->


<p>```fsharp
type IDestructable =</p>

<pre><code>abstract Armour : int
abstract Dodge : int
abstract Hits : int
abstract Destroyed : bool
abstract TakeDamage : int -&gt; IDestructable
</code></pre>

<p>type IWalk =</p>

<pre><code>abstract Walk : Direction * int -&gt; Location
</code></pre>

<p>type IJump =</p>

<pre><code>abstract Jump : Direction * int -&gt; Location
</code></pre>

<p>type IFly =</p>

<pre><code>abstract Fly : Direction * int -&gt; Location
</code></pre>

<p>type IHazWeapon =</p>

<pre><code>abstract Fire : IDestructable * int -&gt; IDestructable
</code></pre>

<p>type IHazWeapons =</p>

<pre><code>abstract WMDs : List&lt;IHazWeapon&gt;
</code></pre>

<p>type IHazCannon =</p>

<pre><code>inherit IHazWeapon
</code></pre>

<p>type IHazMissiles =</p>

<pre><code>inherit IHazWeapon
</code></pre>

<p>type ITransforming =</p>

<pre><code>abstract Mode : string
abstract ``Transform!`` : string -&gt; ITransforming
</code></pre>

<p>```</p>

<p>For anyone who&rsquo;s worked with SOLID OO code before, this should be looking fairly familiar, and it should be obvious how you could build a class that accepted implementations of these interfaces in it&rsquo;s constructor and then carried the state of the robot (location, hits remaining, etc) around as mutable fields.</p>

<p>But&hellip; this is a turn based game, and we&rsquo;ve decided that we want to use a <a href="en.wikipedia.org/wiki/Minimax">minimax</a> approach to choosing moves for the computer player. Minimax is effectively a tree search, which means that implementing it looks like it would be a prime moment for a bit of concurrency. Each branch of the tree can be calculated independently, after all.</p>

<p>Unfortunately&hellip; our SOLID OO approach is not looking very thread safe. Functional programming revolves around the idea that code is <a href="http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29">referentially transparent</a> and that data types are <a href="http://en.wikipedia.org/wiki/Immutable_object">immutable</a>. These two properties immediately lead to thread safe code.</p>

<p>So the rest of the session was spent trying out how different parts of the API code be modelled in a more functional way &ndash; splitting out state into separate immutable value objects, using functions in the place of single method interfaces and playing with discriminated unions (not strictly functional programming related, but they do seem to crop up regularly in functional style languages).</p>

<p>The end results, raw from the discussion, are below. A bit of a mix of the &ldquo;interface&rdquo; and experiments in how you would use it. I think it came out quite nicely, showing how all of the SOLID principles (apart from maybe &ldquo;L&rdquo;!) fall out naturally in nicely designed functional code just as they do in good OO code. In fact some of them, such as &ldquo;Interface Segregation&rdquo; and &ldquo;Single Responsibility&rdquo; are things you almost have to work to avoid &ndash; they both fall out naturally from passing around
pure functions to implement behaviour.</p>

<p>```fsharp
type Destructable =</p>

<pre><code>{
    Armour : int
    Dodge : int
    Hits : int
    Destroyed : bool
}
</code></pre>

<p>// Interface segregation and
// Single responsibility at work
type WeaponFunc =</p>

<pre><code>Destructable -&gt; int -&gt; Destructable
</code></pre>

<p>type Weapon =</p>

<pre><code>| Missile of WeaponFunc
| Cannon of WeaponFunc
</code></pre>

<p>type MoveFunc =</p>

<pre><code>Location -&gt; (Direction * int) -&gt; Location
</code></pre>

<p>type Move =</p>

<pre><code>| Run of MoveFunc
| Jump of MoveFunc
| Fly of MoveFunc
</code></pre>

<p>type Robot =</p>

<pre><code>{
    Id : string
    MovementTypes : Move list
    Weapons : Weapon list
    Location : Location
    DamageStatus : Destructable
}
</code></pre>

<p>// Dependency inversion!
let GiantRobo =</p>

<pre><code>{
    Id = "GiantRobo"
    MovementTypes = [ Run &lt;| fun l m -&gt; l ]
    Weapons = [ Cannon &lt;| fun d i -&gt; d ]
    Location = { Position = (0, 0); Altitude = 0 }
    DamageStatus = { Armour = 10; Dodge = 5; Hits = 100; Destroyed = false }
}
</code></pre>

<p>// Open/closed principle via higher order
// functions
let makeFly runFunc l m =</p>

<pre><code>let newPosition = runFunc l m
{ newPosition with Altitude = 100 }
</code></pre>

<p>let TinyRobo =</p>

<pre><code>{
    Id = "TinyRobo"
    MovementTypes = [ Run &lt;| fun l m -&gt; { l with Position = (10, 10) } ]
    Weapons = [ Cannon &lt;| fun d i -&gt; d ]
    Location = { Position = (0, 0); Altitude = 0 }
    DamageStatus = { Armour = 10; Dodge = 5; Hits = 100; Destroyed = false }
}
</code></pre>

<p>// Separating behaviour and state
module BlowThingsUp =</p>

<pre><code>let TakeDamage destructable damage =
    let newHits = destructable.Hits - damage
    {   destructable with
            Hits = newHits
            Destroyed = newHits &lt;= 0
    }
</code></pre>

<p>// Different possibilities for
// extending that would normally be handled
// by inheritance in OO
module TransformVF1 =</p>

<pre><code>let transform robot =
    {
        robot with
            MovementTypes = [Fly &lt;| fun l m -&gt; { l with Altitude = 100 }]
    }
</code></pre>

<p>type TransformFunc =</p>

<pre><code>Robot -&gt; Robot
</code></pre>

<p>type RobotModel =</p>

<pre><code>| NormalRobot of Robot
| TransformingRobot of Robot * TransformFunc
</code></pre>

<p>type MaybeTransformFunc =</p>

<pre><code>MaybeTransformingRobot -&gt; MaybeTransformingRobot
</code></pre>

<p>and MaybeTransformingRobot =</p>

<pre><code>{
    Id : string
    MovementTypes : Move list
    Weapons : Weapon list
    Location : Location
    DamageStatus : Destructable
    Transform : MaybeTransformFunc option
}
</code></pre>

<p>let Transform mtr =</p>

<pre><code>match mtr.Transform with
| None -&gt;
    mtr
| Some trans -&gt;
    trans mtr
</code></pre>

<p>```</p>

<p>Enjoy, and comments welcome &ndash; this was live coded in a group environment, so I&rsquo;m sure plenty of opportunities for nicer code were missed!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Going Functionally SOLID]]></title>
    <link href="http://blog.mavnn.co.uk/going-functionally-solid/"/>
    <updated>2014-04-11T11:45:47+01:00</updated>
    <id>http://blog.mavnn.co.uk/going-functionally-solid</id>
    <content type="html"><![CDATA[<p><em>The one giant robot every programmer should know and love! Meet Big O!</em></p>

<p><img src="/images/Big_o.jpg" alt="Big O" /></p>

<p><em>For all your algorithmic complexity needs. And any giant mecha in need of a good pounding.</em></p>

<p>And now, back to your regularly scheduled blog post&hellip;</p>

<p>Inspired both by <a href="http://blog.ploeh.dk/2014/03/10/solid-the-next-step-is-functional/">Mark Seemann&rsquo;s excellent blog post</a> and by my ongoing campaign to introduce functional programming techniques to <a href="http://www.15below.com/">15below</a> developers who aren&rsquo;t familiar with them yet, I decided it was time to run a mini-series on applying good principles like <a href="http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29">SOLID</a> in a functional world.</p>

<p>We run weekly one hour &ldquo;Developer Education&rdquo; sessions. For this series I started with a badly written piece of code (it came naturally, given I had limited prep time&hellip;) in a style of someone who has kind of heard about SOLID and functional programming:</p>

<ul>
<li><strong>SOLID</strong>: &ldquo;So, eh, I need some interfaces and things. Concrete bad, interface good. In wonder what the whole DI thing is?&rdquo;</li>
<li><strong>Functional</strong>: &ldquo;And, erm. Chainable functions? Fluent APIs, maybe? That&rsquo;s kind of functional, right?&rdquo;</li>
</ul>


<!-- More -->


<p>And then we had a open house suggesting modifications to the code where I made the changes live as we went along. In this first session, we only got as far as making the code a bit more solid &ndash; tune back in next month for the make it functional session..</p>

<p>Deciding that we needed a more interesting example domain than sending emails for once, I decided to go the whole hog. Below you&rsquo;ll find the before and after versions of &ldquo;HeavyGearSOLID&rdquo;&rsquo;s unit representation code.</p>

<p>Because everything is better with giant robots.</p>

<p>The session was a fun change of pace from other things we&rsquo;ve done, and sparked off a nice bit of discussion (although not as much as I hoped&hellip; heckle more, 15below people!). I&rsquo;m quite looking forward to the next part of the series.</p>

<h2>Before</h2>

<p><code>` fsharp
namespace</code>メタルギアソリッド``</p>

<p>open System
open Utils</p>

<p>type IMecha =</p>

<pre><code>abstract Walk : Direction * int -&gt; IMecha
abstract Jump : Direction * int -&gt; IMecha
abstract Fly : Direction * int -&gt; IMecha
abstract Position : int * int
abstract Hits : int
abstract Destroyed : bool
abstract Dodge : int
abstract Armour : int
abstract TakeDamage : int -&gt; IMecha
abstract FireCannon : IMecha * int -&gt; IMecha
abstract FireMissiles : IMecha * int -&gt; IMecha
</code></pre>

<p>type GiantRobo (position) =</p>

<pre><code>let _position = ref position
let _hits = ref 100
let _destroyed = ref false
let _dodge = ref 5
let _armour = ref 20
let rand = Random()
interface IMecha with
    member x.Walk (dir, distance) =
        let iMecha = x :&gt; IMecha
        if distance &gt; 4 then
            failwith "GiantRobo is slow!"
        else
            _position := Move (!_position) dir distance
            iMecha
    member x.Jump (_, _) =
        raise &lt;| NotImplementedException("GiantRobo can't jump")
    member x.Fly (_, _) =
        raise &lt;| NotImplementedException("GiantRobo can't fly")
    member x.Position =
        !_position
    member x.Hits =
        !_hits                        
    member x.Destroyed =
        !_destroyed
    member x.Dodge =
        !_dodge
    member x.Armour =
        !_armour
    member x.TakeDamage damage =
        _hits := !_hits - damage
        _destroyed := !_hits &lt;= 0
        x :&gt; IMecha
    member x.FireCannon (target, roll) =
        if roll &gt; target.Dodge then
            target.TakeDamage (max 0 (60 - target.Armour))
        else
            target
    member x.FireMissiles (target, roll) =
        raise &lt;| NotImplementedException("Giant Robo has no missiles")
</code></pre>

<p>type ITransformingMecha =</p>

<pre><code>inherit IMecha
abstract Mode : string
abstract ``Transform!`` : string -&gt; ITransformingMecha
</code></pre>

<p>type VF1 (position) =</p>

<pre><code>let _position = ref position
let _hits = ref 50
let _destroyed = ref false
let _dodge = ref 10
let _armour = ref 10
let _mode = ref "Battroid"
interface ITransformingMecha with
    member x.Walk (dir, distance) =
        let iMecha = x :&gt; IMecha
        if !_mode = "Fighter" then failwith "No legs in Fighter mode!"
        if distance &gt; 6 then
            failwith "VF-1 isn't that fast!"
        else
            _position := Move (!_position) dir distance
            iMecha
    member x.Jump (dir, distance) =
        let iMecha = x :&gt; IMecha
        if !_mode = "Fighter" then failwith "Jumping in Fighter mode makes no sense!"
        let maxDistance =
            match !_mode with
            | "GERWALK" -&gt; 8
            | "Battroid" -&gt; 6
            | _ -&gt; failwith "No good"
        if distance &gt; maxDistance then
            failwith "VF-1 isn't that fast!"
        else
            _position := Move (!_position) dir distance
            iMecha
    member x.Fly (dir, distance) =
        let iMecha = x :&gt; IMecha
        if !_mode = "Battroid" then failwith "Battroid mode can't fly"
        let maxDistance =
            match !_mode with
            | "Fighter" -&gt; 20
            | "GERWALK" -&gt; 15
            | _ -&gt; failwith "No good"
        if distance &gt; maxDistance then
            failwith "VF-1 isn't that fast!"
        else
            _position := Move (!_position) dir distance
            iMecha
    member x.Position =
        !_position
    member x.Hits =
        !_hits                        
    member x.Destroyed =
        !_destroyed
    member x.Dodge =
        !_dodge
    member x.Armour =
        !_armour
    member x.TakeDamage damage =
        _hits := !_hits - damage
        _destroyed := !_hits &lt;= 0
        x :&gt; IMecha
    member x.FireCannon (target, roll) =
        if roll &gt; target.Dodge then
            target.TakeDamage (max 0 (20 - target.Armour))
        else
            target
    member x.FireMissiles (target, roll) =
        if roll &gt; (target.Dodge / 2) then
            target.TakeDamage (max 0 (60 - target.Armour))
        else
            target
    member x.Mode =
        !_mode
    member x.``Transform!`` mode =
        match mode with
        | "Fighter" -&gt;
            _mode := "Fighter"
        | "GERWALK" -&gt;
            _mode := "GERWALK"
        | "Battroid" -&gt;
            _mode := "Battroid"
        | _ -&gt;
            failwith "Not a valid VF-1 mode"
        x :&gt; ITransformingMecha
</code></pre>

<p>```</p>

<h2>After</h2>

<p><code>` fsharp
namespace</code>メタルギアソリッド``</p>

<p>open System
open Utils</p>

<p>type Location =</p>

<pre><code>{
    Position : int * int
    Altitude : int
}
</code></pre>

<p>type IDestructable =</p>

<pre><code>abstract Armour : int
abstract Dodge : int
abstract Hits : int
abstract Destroyed : bool
abstract TakeDamage : int -&gt; IDestructable
</code></pre>

<p>type IWalk =</p>

<pre><code>abstract Walk : Direction * int -&gt; Location
</code></pre>

<p>type IJump =</p>

<pre><code>abstract Jump : Direction * int -&gt; Location
</code></pre>

<p>type IFly =</p>

<pre><code>abstract Fly : Direction * int -&gt; Location
</code></pre>

<p>type IHazWeapon =</p>

<pre><code>abstract Fire : IDestructable * int -&gt; IDestructable
</code></pre>

<p>type IHazWeapons =</p>

<pre><code>abstract WMDs : List&lt;IHazWeapon&gt;
</code></pre>

<p>type IHazCannon =</p>

<pre><code>inherit IHazWeapon
</code></pre>

<p>type IHazMissiles =</p>

<pre><code>inherit IHazWeapon
</code></pre>

<p>type NormalDestructable (hits, dodge, armour) =</p>

<pre><code>let _hits = ref 100
let _destroyed = ref false
let _dodge = ref 5
let _armour = ref 20
interface IDestructable with
    member x.Hits =
        !_hits                        
    member x.Destroyed =
        !_destroyed
    member x.Dodge =
        !_dodge
    member x.Armour =
        !_armour
    member x.TakeDamage damage =
        _hits := !_hits - damage
        _destroyed := !_hits &lt;= 0
        x :&gt; IDestructable
</code></pre>

<p>type GiantRobo (position, destructable : #IDestructable) =</p>

<pre><code>let _position = ref position
member x.Position =
    !_position
interface IWalk with
    member x.Walk (dir, distance) =
        if distance &gt; 4 then
            failwith "GiantRobo is slow!"
        else
            { Position = Move (!_position) dir distance; Altitude = 0 }
interface IDestructable with
    member x.Hits = destructable.Hits
    member x.Destroyed = destructable.Destroyed
    member x.Dodge = destructable.Dodge
    member x.Armour = destructable.Armour
    member x.TakeDamage damage = destructable.TakeDamage damage
interface IHazWeapons with
    member x.WMDs =
        [{ new IHazCannon with 
            member x.Fire (target, roll) =
                if roll &gt; target.Dodge then
                    target.TakeDamage (max 0 (60 - target.Armour))
                else
                    target }]
</code></pre>

<p>type ITransforming =</p>

<pre><code>abstract Mode : string
abstract ``Transform!`` : string -&gt; ITransforming
</code></pre>

<p>type VF1 (position) =</p>

<pre><code>let _position = ref position
let _mode = ref "Battroid"
member x.Position =
    !_position
interface IWalk with
    member x.Walk (dir, distance) =
        if !_mode = "Fighter" then failwith "No legs in Fighter mode!"
        if distance &gt; 6 then
            failwith "VF-1 isn't that fast!"
        else
            { Position = Move (!_position) dir distance; Altitude = 0 }
interface IJump with
    member x.Jump (dir, distance) =
        if !_mode = "Fighter" then failwith "Jumping in Fighter mode makes no sense!"
        let maxDistance =
            match !_mode with
            | "GERWALK" -&gt; 8
            | "Battroid" -&gt; 6
            | _ -&gt; failwith "No good"
        if distance &gt; maxDistance then
            failwith "VF-1 isn't that fast!"
        else
            { Position = Move (!_position) dir distance; Altitude = 0 }
interface IFly with
    member x.Fly (dir, distance) =
        if !_mode = "Battroid" then failwith "Battroid mode can't fly"
        let maxDistance =
            match !_mode with
            | "Fighter" -&gt; 20
            | "GERWALK" -&gt; 15
            | _ -&gt; failwith "No good"
        if distance &gt; maxDistance then
            failwith "VF-1 isn't that fast!"
        else
            { Position = Move (!_position) dir distance; Altitude = 0 }
interface IHazWeapons with
    member x.WMDs =
        [
            { new IHazCannon with
                member x.Fire (target, roll) =
                    if roll &gt; target.Dodge then
                        target.TakeDamage (max 0 (20 - target.Armour))
                    else
                        target };
             { new IHazMissiles with
                member x.Fire (target, roll) =
                    if roll &gt; (target.Dodge / 2) then
                        target.TakeDamage (max 0 (60 - target.Armour))
                    else
                        target }
        ]
interface ITransforming with
    member x.Mode =
        !_mode
    member x.``Transform!`` mode =
        match mode with
        | "Fighter" -&gt;
            _mode := "Fighter"
        | "GERWALK" -&gt;
            _mode := "GERWALK"
        | "Battroid" -&gt;
            _mode := "Battroid"
        | _ -&gt;
            failwith "Not a valid VF-1 mode"
        x :&gt; ITransforming
</code></pre>

<p>```</p>

<p><em>This series continues in the imaginatively named &ldquo;<a href="/functionally-solid-2/">Functionally SOLID 2</a>&rdquo;</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Providers From the First Floor]]></title>
    <link href="http://blog.mavnn.co.uk/type-providers-from-the-first-floor/"/>
    <updated>2014-03-19T21:06:05+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-providers-from-the-first-floor</id>
    <content type="html"><![CDATA[<p><em>This post follows on directly from my previous post <a href="http://blog.mavnn.co.uk/type-providers-from-the-ground-up/">Type Providers from the Ground Up</a>. I highly recommend that you read that first, and check out the relevant example code from GitHub.</em></p>

<p><em>It&rsquo;s also a bit epic&hellip; grab yourself a coffee before you start.</em></p>

<p>So we have a working type provider now. Unfortunately, we&rsquo;re missing out on at least two major features that your new type provider will almost certainly want to make use of.</p>

<p>The first is that in our example, we&rsquo;re reading the metadata that defines our types from a fixed file location. In almost every real life case, you will want to be able to parametrize your provider to specify where this instance is getting it&rsquo;s metadata from.</p>

<p>The second is that in many cases getting the metadata will be slow, and the number of types available to generate may be very large. In these situations, you really want to be able to only generate the types that are required as they are requested, especially because this will reduce the size of the final compiled output. This is particularly important for type providers that read from large network based data sources like the Freebase provider.</p>

<p>We&rsquo;ll take the second first, because it&rsquo;s easy &ndash; and we like easy&hellip;</p>

<!-- more -->


<h2>Generating types on demand</h2>

<p>This is in many ways one of the features that makes type providers uniquely powerful compared to code generation. Because the types are being requested by the compiler as needed, type providers can give meaningful access to literally infinite type hierarchies.</p>

<p>So, does all this power come with great cost and complexity? Not really, no.</p>

<p>Let&rsquo;s take the our node creation function, with some bits snipped out:</p>

<p>``` fsharp
let createNodeType id (node : Node) =</p>

<pre><code>let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
// ... snip constructors

let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
outputs.AddMember(outputCtor)
outputs.HideObjectMethods &lt;- true

let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
inputs.AddMember(inputCtor)
inputs.HideObjectMethods &lt;- true
addPorts inputs outputs node.Ports

// Add the inputs and outputs types of nested types under the Node type
nodeType.AddMembers([inputs;outputs])

// Now add some instance properties to expose them on a node instance.
let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)

nodeType.AddMembers([inputPorts;outputPorts])

nodeType
</code></pre>

<p>```</p>

<p>To make the ports deferred, we simply change the <code>AddMembers</code> call at the end to <code>AddMembersDelayed</code> and wrap the creation of the array in a function that takes <code>unit</code>.</p>

<p>It ends up looking like this:</p>

<p>``` fsharp
let createNodeType id (node : Node) =</p>

<pre><code>let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
// ... snip out the constructor again...

let addInputOutput () =
    let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
    let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    outputs.AddMember(outputCtor)
    outputs.HideObjectMethods &lt;- true

    let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
    let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    inputs.AddMember(inputCtor)
    inputs.HideObjectMethods &lt;- true
    addPorts inputs outputs node.Ports

    // Add the inputs and outputs types of nested types under the Node type
    nodeType.AddMembers([inputs;outputs])

    // Now add some instance properties to expose them on a node instance.
    let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                        GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                        GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    [inputPorts;outputPorts]

nodeType.AddMembersDelayed(addInputOutput)

nodeType
</code></pre>

<p>```</p>

<p>Now the input and output ports of a node will only be generated the first time that the compiler needs them available. If you don&rsquo;t use a particular node in your program, then the compiler will never generate it&rsquo;s ports, and they will not be including in your final build output.</p>

<p>Of course, in this case we&rsquo;re pre-loading all of our metadata anyway, but hopefully this gives you an idea.</p>

<h2>Parametrizing the Data Source</h2>

<p>Currently, we&rsquo;re reading the json that&rsquo;s generating our types like this:</p>

<p>``` fsharp
let private nodes = JsonConvert.DeserializeObject&lt;seq<Node>>(IO.File.ReadAllText(@&ldquo;c:\Temp\Graph.json&rdquo;))</p>

<pre><code>                |&gt; Seq.map (fun n -&gt; n.Id.UniqueId.ToString(), n)
                |&gt; Map.ofSeq
</code></pre>

<p>```</p>

<p>Lovely.</p>

<p>Now, you&rsquo;ll probably of noticed from playing with other type providers that they allow you to do funky things like:</p>

<p><code>fsharp
type myThing = FancyProvider&lt;"configStringThing"&gt;
</code></p>

<p>This is actually one of the things that kept me going for longest in writing my first type provider, and I have to admit I&rsquo;m still not fully certain why it&rsquo;s done this way.</p>

<p>At the moment, if we strip out all of the type creation logic, our type provider looks like this:</p>

<p>``` fsharp
[<TypeProvider>]
type MavnnProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Mavnn.Blog.TypeProvider.Provided"
let asm = Assembly.GetExecutingAssembly()

// ... massive snip

let createNodeType id (node : Node) =
    let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
    // ... more snipped here ...

let createTypes () =
    nodes |&gt; Map.map createNodeType |&gt; Map.toList |&gt; List.map (fun (k, v) -&gt; v)

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>```</p>

<p>As you can see, we add the types to the namespace during the initialization of the MavnnProvider type.</p>

<p>This is no good if we want to add parameters &ndash; after all, we don&rsquo;t know what they are yet. And the same provider might be used several times with different parameters. Also, when we create our provided type (<code>let nodeType = ...</code>) we&rsquo;re putting into a fixed space in the assemblies namespace. Again, this is no good if we want to be able to use more than one of our provider with different parameters.</p>

<p>To get around these issues, we create a &ldquo;parent&rdquo; provided type within the type provider which will host an isolated namespace for each parametrized provider instance:</p>

<p><code>fsharp
let mavnnProvider = ProvidedTypeDefinition(asm, ns, "MavnnProvider", Some(typeof&lt;obj&gt;))
</code></p>

<p>Then we define some &lsquo;static parameters&rsquo; and call the <code>DefineStaticParameters</code> method on the parent provided type, still within the construction of the type provider:</p>

<p>``` fsharp
let parameters = [ProvidedStaticParameter(&ldquo;PathToJson&rdquo;, typeof<string>)]</p>

<p>do mavnnProvider.DefineStaticParameters(parameters, fun typeName args &ndash;></p>

<pre><code>let pathToJson = args.[0] :?&gt; string
// ... do all our type creation logic in here ...
)
</code></pre>

<p>```</p>

<p>&hellip; and then we amend the base TypeProvider type so that the only type it adds to the namespace is the <code>mavnnProvider</code> type:</p>

<p><code>fsharp
// was: do this.AddNamespace(ns, createTypes())
do this.AddNamespace(ns, [mavnnProvider])
</code></p>

<p>At this point, we&rsquo;re creating an independent environment for each instance of the type provider. Unfortunately we need to make several changes to the type creation logic to make this work.</p>

<p>Firstly, we loaded quite a few things globally in the original version &ndash; things like the node list now need to happen within the context of <code>DefineStaticParameters</code>. You&rsquo;ll also notice that <code>DefineStaticParameters</code> gets given a <code>typeName</code> as one of the parameters on the callback. This is a compiler generated type name for this instance of the which is passed in when a parameterised provider is defined, and the callback method needs to return a provided type with that name.</p>

<p>So, for example:</p>

<p>``` fsharp
// In a script file called: Script.fsx</p>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Newtonsoft.Json.dll&rdquo;</h1>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Mavnn.Blog.TypeProvider.dll&rdquo;</h1>

<p>open System
open Mavnn.Blog.TypeProvider.Provided</p>

<p>type thisOne = MavnnProvider&lt;&ldquo;c:\Temp\Graph.json&rdquo;>
```</p>

<p>Will pass in <code>"Script.thisOne" [| box "c:\Temp\Graph.json" |]</code> to the callback method, and expect to get back a provided type. So the first thing we&rsquo;ll do in the callback is create the new type which we will then add all of our nodes to.</p>

<p>Keeping all of the amendments separate in your head just gets harder and harder at this point, so let&rsquo;s just few the final annotated method and get an overview of the final result. It&rsquo;s long, but hopefully worth it!</p>

<p>``` fsharp
do mavnnProvider.DefineStaticParameters(parameters, fun typeName args &ndash;></p>

<pre><code>// All args arrive as type obj - you'll need to cast them back to what
// you specified for actual usage
let pathToJson = args.[0] :?&gt; string

// This is the type that is going to host all the other types
// and get returned at the end of the method
let provider = ProvidedTypeDefinition(asm, ns, typeName, Some typeof&lt;obj&gt;, HideObjectMethods = true)

// ---------- set up ----------
// This section contains all the methods that where previously global
// to the module, but now need to be constrained to this instance of
// the provider
let nodes = JsonConvert.DeserializeObject&lt;seq&lt;Node&gt;&gt;(IO.File.ReadAllText(pathToJson))
            |&gt; Seq.map (fun n -&gt; n.Id.UniqueId.ToString(), n)
            |&gt; Map.ofSeq

let GetNode id =
    nodes.[id]

let ports =
    nodes
    |&gt; Map.toSeq
    |&gt; Seq.map (fun (_, node) -&gt; node.Ports)
    |&gt; Seq.concat
    |&gt; Seq.map (fun p -&gt; p.Id.UniqueId.ToString(), p)
    |&gt; Map.ofSeq

let GetPort id =
    ports.[id]

let addInputPort (inputs : ProvidedTypeDefinition) (port : Port) =
    let port = ProvidedProperty(
                    port.Id.Name, 
                    typeof&lt;InputPort&gt;, 
                    GetterCode = fun args -&gt; 
                        let id = port.Id.UniqueId.ToString()
                        &lt;@@ GetPort id |&gt; InputPort @@&gt;)
    inputs.AddMember(port)

let addOutputPort (outputs : ProvidedTypeDefinition) (port : Port) =
    let port = ProvidedProperty(
                    port.Id.Name, 
                    typeof&lt;OutputPort&gt;, 
                    GetterCode = fun args -&gt; 
                        let id = port.Id.UniqueId.ToString()
                        &lt;@@ GetPort id |&gt; OutputPort @@&gt;)
    outputs.AddMember(port)

let addPorts inputs outputs (portList : seq&lt;Port&gt;) =
    portList
    |&gt; Seq.iter (fun port -&gt; 
                    match port.Type with
                    | "input" -&gt; addInputPort inputs port
                    | "output" -&gt; addOutputPort outputs port
                    | _ -&gt; failwithf "Unknown port type for port %s/%s" port.Id.Name (port.Id.UniqueId.ToString()))


// ---------- end set up ----------

let createNodeType id (node : Node) =
    let nodeType = ProvidedTypeDefinition(node.Id.Name, Some typeof&lt;nodeInstance&gt;)
    let ctor = ProvidedConstructor(
                [
                    ProvidedParameter("Name", typeof&lt;string&gt;)
                    ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
                    ProvidedParameter("Config", typeof&lt;string&gt;)
                ],
                InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
    nodeType.AddMember(ctor)

    let addInputOutput () =
        let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
        let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        outputs.AddMember(outputCtor)
        outputs.HideObjectMethods &lt;- true

        let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
        let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        inputs.AddMember(inputCtor)
        inputs.HideObjectMethods &lt;- true
        addPorts inputs outputs node.Ports

        // Add the inputs and outputs types of nested types under the Node type
        nodeType.AddMembers([inputs;outputs])

        // Now add some instance properties to expose them on a node instance.
        let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                            GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                            GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        [inputPorts;outputPorts]

    nodeType.AddMembersDelayed(addInputOutput)

    provider.AddMember(nodeType)

// And this is where we actually interate through the loaded nodes,
// using createNodeType to add each one to the parent provider type.
let createTypes pathToJson =
    nodes |&gt; Map.map createNodeType |&gt; Map.toList |&gt; List.iter (fun (k, v) -&gt; v)

createTypes pathToJson

// And then we return our fully populated provider.
provider)
</code></pre>

<p>```</p>

<p>Let&rsquo;s just check this all still works&hellip;</p>

<p><img src="/images/tp-oh-no.png" alt="Losing!" /></p>

<p>Ah. No. No, it doesn&rsquo;t.</p>

<p>This is where type provider development can get a bit more frustrating. The compiler allows the code above to compile &ndash; it&rsquo;s completely valid F# that looks like it should do the right thing. But now, our quotations are doing something different; and evaluating them at runtime fails.</p>

<p>Let&rsquo;s take a look at the constructor that&rsquo;s throwing the error:</p>

<p><code>fsharp
InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
</code></p>

<p>Previously, <code>GetNode</code> was referring to a public method in the type provider assembly. But if you look above now, it&rsquo;s actually a private method with in the type provider class that we are closing over. But our generated type is in the assembly that&rsquo;s being created, not in the type provider assembly so <em>it can&rsquo;t access this method</em>. Even if it was in the same assembly, this method is actually private to the class, so we&rsquo;d still be stuck. Bearing that in mind, let&rsquo;s try a
rewrite to see if we can get all of our quotations into better shape.</p>

<p>What are our options? Well, we can either capture all private state in types that the quotation evaluator knows about (<code>string</code>, mostly!). Or we can make sure that any methods called in the quotations are public.</p>

<p>The first gives us a cleaner interface for the outside world (the <code>GetNode</code> method should never really have been public in the first place), so let&rsquo;s give it a try.</p>

<p>In our first version of the type provider, we were using the <code>GetNode</code> method to avoid having to embed the <code>Node</code> in the constructor directly. But how would we go about putting the node in directly? We need something that creates an <code>Expr&lt;Node&gt;</code>; but <code>Node</code> isn&rsquo;t a completely trivial type &ndash; it&rsquo;s members (<code>Id</code> and <code>Ports</code>) are made of more complex types themselves. Let&rsquo;s start with a simpler challenge, and see if we can make an <code>Expr&lt;Id&gt;</code>.</p>

<p>We already know that:</p>

<p><code>fsharp
let embeddedId (identifier : Id) = &lt;@ identifier @&gt;
</code></p>

<p>isn&rsquo;t going to work. The expression evaluator won&rsquo;t know what to do with the <code>Id</code> type. But <code>Id</code>&rsquo;s constructor is a public method, as is the <code>Guid</code> constructor. Let&rsquo;s try it:</p>

<p>``` fsharp
let private embeddedId (id : Id) =</p>

<pre><code>let guid = sprintf "%A" (id.UniqueId)
let name = id.Name
&lt;@ Id(UniqueId = Guid(guid), Name = name) @&gt;
</code></pre>

<p>```</p>

<p>Cool. It works, and even has the right signature. Looks like we might be getting somewhere. The <code>Port</code> type is nearly as straight forward:</p>

<p>``` fsharp
let private embeddedPort (port : Port) =</p>

<pre><code>let idExpr = embeddedId port.Id
let type' = port.Type
&lt;@ Port(Id = %idExpr, Type = type') @&gt;
</code></pre>

<p>```</p>

<p>We&rsquo;re using our embeddedId method to &lsquo;lift&rsquo; the port&rsquo;s <code>Id</code> into an expression, and then splicing that expression into a call to create a new port.</p>

<p>We&rsquo;re on a roll! Just need to do the same for the <code>Node</code> type itself, with it&rsquo;s&hellip; <code>List</code> of <code>Port</code>s. Ah.</p>

<p>There&rsquo;s probably a more elegant way of doing this, but given this is a functional first language, let&rsquo;s grab the first tool that springs to mind.</p>

<p>Recursion.</p>

<p>``` fsharp
let private embeddedNode (node : Node) =</p>

<pre><code>let idExpr = embeddedId node.Id
let portsExpr adder = 
    &lt;@
        let outPorts = Collections.Generic.List&lt;Port&gt;()
        (%adder) outPorts
        outPorts
    @&gt;
let adder =
    let portExprs =
        Seq.map (fun port -&gt; embeddedPort port) (node.Ports)
        |&gt; Seq.toList
    let rec builder expr remaining =
        match remaining with
        | h::t -&gt;
            builder
                &lt;@ fun (ports : Collections.Generic.List&lt;Port&gt;) -&gt;
                        (%expr) ports
                        ports.Add(%h) @&gt;
                t
        | [] -&gt;
            expr
    builder
        &lt;@ fun (ports : Collections.Generic.List&lt;Port&gt;) -&gt; () @&gt;
        portExprs
&lt;@ Node(Id = %idExpr, Ports = (%portsExpr adder)) @&gt;
</code></pre>

<p>```</p>

<p>So, from the top down. <code>portsExpr</code> creates a quotation that takes an <code>adder</code> quotation (<code>Expr&lt;List&lt;Port&gt;&gt; -&gt; unit</code>) and returns an <code>Expr&lt;List&lt;Port&gt;&gt;</code>. This is what we&rsquo;re going to use in our <code>Node</code> construction quotation; but first we need the <code>adder</code>; some kind of magic method that takes a List and adds each of the ports from the node that&rsquo;s being passed into <code>embeddedNode</code>. I&rsquo;ve built it as a recursive function; the &lsquo;zero&rsquo; state that&rsquo;s passed in looks like this:</p>

<p><code>fsharp
&lt;@ fun (ports : Collections.Generic.List&lt;Port&gt;) -&gt; () @&gt;
</code></p>

<p>This is what will happen if the port list on the input node is empty. If it&rsquo;s not empty, we repeated build up nested calls to:</p>

<p>``` fsharp
&lt;@ fun (ports : Collections.Generic.List<Port>) &ndash;></p>

<pre><code>    (%expr) ports
    ports.Add(%h) @&gt;
</code></pre>

<p>```</p>

<p>Where <code>h</code> is the next port from the list. By the end of the process we have a chain of anonymous functions, each in turn closing over the quotation of a port from the input. Finally, we can splice that into the expression that actually creates our node.</p>

<p>Now we can use our new <code>embeddedX</code> expressions in our provided constructors and methods; for example, the constructor above becomes:</p>

<p>``` fsharp
let ctor = ProvidedConstructor(</p>

<pre><code>        [
            ProvidedParameter("Name", typeof&lt;string&gt;)
            ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
            ProvidedParameter("Config", typeof&lt;string&gt;)
        ],
        InvokeCode =
            fun [name;unique;config] -&gt; 
                let nodeExpr = embeddedNode &lt;| GetNode id
                &lt;@@ NodeInstance.create (%nodeExpr) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
</code></pre>

<p>```</p>

<p>Can you see the difference? Now, rather than closing over the <code>GetNode</code> method, we&rsquo;re closing over the quotation of the node that it returns.</p>

<p>With a sense of deja vu, let&rsquo;s just check this all works&hellip;</p>

<p><img src="/images/tp_quotations.png" alt="Winning!" /></p>

<p>And somewhat surprisingly &ndash; it does.</p>

<p>If you want to see and play with the code, the version for this post can be found in <a href="https://github.com/mavnn/Mavnn.Blog.TypeProvider/tree/FirstFloor">the FirstFloor branch of the project on GitHub</a>.</p>

<p>As with the first post in the series, let me know your questions and comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single file websites with Suave]]></title>
    <link href="http://blog.mavnn.co.uk/single-file-websites-with-suave/"/>
    <updated>2014-02-28T09:54:46+00:00</updated>
    <id>http://blog.mavnn.co.uk/single-file-websites-with-suave</id>
    <content type="html"><![CDATA[<blockquote><p>As of a few days ago, the embedded module <a href="https://github.com/SuaveIO/suave/pull/100/files">was merged</a> into Suave master. Enjoy!</p></blockquote>

<p>I&rsquo;m a great fan of <a href="http://suave.io/">Suave</a> for simple web development in F#. I highly recommend checking out the site for details, but in the mean time I&rsquo;d like to share a little trick I&rsquo;ve been using for rapid prototyping that I&rsquo;m finding very useful.</p>

<p>The Suave.Http module contains a few helpers for serving static files from disk. Unfortunately, depending on use case and deployment strategy, relying on the location of a bunch of files on disk can be problematic.</p>

<p>So (open source to the rescue!) I cracked open the code and wrote a small alternative implementation that serves files from the current assembly&rsquo;s embedded resources. I&rsquo;m finding it especially useful for single page JavaScript apps where you have a small number of resources and then a lot of end points providing api functionality.</p>

<p>Setting up your website looks something like this:</p>

<p>``` fsharp
module Website
open System
open Suave.Http
open Suave.Types
open Embedded</p>

<p>let app =</p>

<pre><code>choose [
    // serve the embedded index.html for "/"
    GET &gt;&gt;= url "/" &gt;&gt;= resource "index.html"
    // check if the request matches the name of an embedded resource
    // if it does, serve it up with a reasonable cache
    GET &gt;&gt;= browse_embedded
    // If it doesn't, try and trigger your api end points
    GET &gt;&gt;= url "/json" &gt;&gt;== (fun _ -&gt; serveJson &lt;| makeData())
    GET &gt;&gt;= url "/carrier" &gt;&gt;== (fun _ -&gt; getCarrierCodes ())
    // Nothing else has worked - 404
    NOT_FOUND "Sorry, couldn't find your page"
]
</code></pre>

<p>web_server default_config app
```</p>

<p>And the embedded module looks like this:</p>

<p>``` fsharp
module Embedded</p>

<p>open System
open System.IO
open System.Reflection
open Suave
open Suave.Http
open Suave.Types
open Suave.Socket</p>

<p>let private ass = Assembly.GetExecutingAssembly()</p>

<p>let private resources =</p>

<pre><code>ass.GetManifestResourceNames()
</code></pre>

<p>let private CACHE_CONTROL_MAX_AGE = 600</p>

<p>let private lastModified = DateTime.UtcNow</p>

<p>let private send_embedded resourceName r =</p>

<pre><code>let write_embedded file (r : HttpRequest) = async {
  use s = ass.GetManifestResourceStream(resourceName)

  if s.Length &gt; 0L then
    do! async_writeln r.connection (sprintf "Content-Length: %d" s.Length) r.line_buffer

  do! async_writeln r.connection "" r.line_buffer

  if s.Length &gt; 0L then
    do! transfer_x r.connection s }

async { do! response_f 200 "OK" (write_embedded resourceName) r } |&gt; succeed
</code></pre>

<p>let resource resourceName =</p>

<pre><code>if resources |&gt; Array.exists ((=) resourceName) then
  let send_it _ = 
    let mimes = mime_type &lt;| IO.Path.GetExtension resourceName
    #if DEBUG
    set_mime_type mimes 
    &gt;&gt; send_embedded (resourceName)
    #else
    set_header "Cache-Control" (sprintf "max-age=%d" CACHE_CONTROL_MAX_AGE)
    &gt;&gt; set_header "Last-Modified" (lastModified.ToString("R"))
    &gt;&gt; set_header "Expires" (DateTime.UtcNow.AddSeconds(float(CACHE_CONTROL_MAX_AGE)).ToString("R")) 
    &gt;&gt; set_mime_type mimes 
    &gt;&gt; send_embedded (resourceName)
    #endif
  warbler ( fun (r:HttpRequest) -&gt;
    let modified_since = (r.headers ? ``if-modified-since`` )
    match modified_since with
    | Some v -&gt; let date = DateTime.Parse v
                if lastModified &gt; date then send_it ()
                else NOT_MODIFIED
    | None   -&gt; send_it ())
else
  never
</code></pre>

<p>let browse_embedded : WebPart =</p>

<pre><code>warbler (fun req -&gt; resource (req.url.TrimStart([| '/' |])))
</code></pre>

<p>```</p>

<p><a href="https://twitter.com/ad3mar">@ad3mar</a> if you feel like rolling this into Suave, you can consider it licenced under what ever is most convenient. An official licence file would make me much happier using Suave in production, by the way (hint, hint).</p>

<p>Edit: ad3mar has pointed out in the comments that Suave is already Apache2 licensed, I just failed to find the file last time I looked.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Provider ProTip]]></title>
    <link href="http://blog.mavnn.co.uk/type-provider-protip/"/>
    <updated>2014-01-10T12:15:15+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-provider-protip</id>
    <content type="html"><![CDATA[<p>While type providers are incredibly powerful, the ProvidedTypes api for creating them is sometimes a bit rough around the edges. And not always as functional as you might hope.</p>

<p>At some point I&rsquo;d like to do something about that, but for the moment I&rsquo;m just going to collect a few helpful tips and hints (mostly for own reference).</p>

<p>Tip one is in the case where you have XmlDocs to add to ProvidedTypes, ProvidedMethods and ProvidedProperties; in our case we have an optional description field in our metadata and the boiler plate was getting tiresome.</p>

<p>``` fsharp
let inline addDoc (desc : Descriptor) def =</p>

<pre><code>match desc.Description with
| Some d -&gt;
    (^T : (member AddXmlDoc : string -&gt; unit) (def, d))
| None -&gt; ()
</code></pre>

<p>```</p>

<p>This function takes a <code>Descriptor</code> with a <code>string option</code> Description field and any <code>def</code> with an AddXmlDoc member with the noted signature &ndash; and adds description as the xml doc if it exists.</p>
]]></content>
  </entry>
  
</feed>
