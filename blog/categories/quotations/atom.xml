<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quotations | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/quotations/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2015-02-16T12:42:32+00:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cutting Quotations Down to Size]]></title>
    <link href="http://blog.mavnn.co.uk/cutting-quotations-down-to-size/"/>
    <updated>2014-10-07T21:30:58+01:00</updated>
    <id>http://blog.mavnn.co.uk/cutting-quotations-down-to-size</id>
    <content type="html"><![CDATA[<blockquote><p>This is part 2 in my quotations series, following on from <a href="/tap/">Tap, Tap, Tapping on the Door</a>.</p></blockquote>

<p>As promised in the first part of this series, here we&rsquo;re going to take a look at manipulating quotations. I mean, we&rsquo;ve got this <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> &ndash; now what are we going to do with it?</p>

<p>Let&rsquo;s start with something fairly straightforward; <a href="http://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a>.</p>

<p>First, let&rsquo;s get a look at how some boolean expressions are represented in quotations.</p>

<p>Firing up F# Interactive, we&rsquo;ll feed a few in and see what happens:</p>

<p>```fsharp
&lt;@@ true @@>;;
(* val it : Expr =</p>

<pre><code>  Value (true)
    {CustomAttributes = [NewTuple (Value ("DebugRange"),
          NewTuple (Value ("stdin"), Value (4), Value (4), Value (4), Value (8)))];
     Type = System.Boolean;} *)
</code></pre>

<p>```</p>

<p>Hmm. That&rsquo;s&hellip; not as nice as we might want. The custom attributes are being added by F# interactive for debugging purposes, but hopefully the general shape is clear: our expression consists of a single value of <code>true</code>.</p>

<p>I&rsquo;ll cut out the custom attributes from now on to make reading things a bit easier.</p>

<p>Next!</p>

<!-- more -->


<p>```fsharp
&lt;@@ true &amp;&amp; true @@>;;
(* val it : Expr =</p>

<pre><code>  IfThenElse (Value (true), Value (true), Value (false))
    {CustomAttributes = ...;
     Type = System.Boolean;} *)
</code></pre>

<p>```</p>

<p>So. Looks like someone has decided to represent the <code>&amp;&amp;</code> operator with the expression tree of an <code>if</code> statement. Useful in some ways; after all, any logic we can apply to an <code>&amp;&amp;</code> operator will equally apply to a logically equivalent <code>if</code> statement. Checking the <a href="http://msdn.microsoft.com/en-us/library/ee370408.aspx">MSDN documentation for Expr.IfThenElse</a> tells if that the 3 values above are <code>guard</code>, <code>thenExpr</code> and <code>elseExpr</code>. Which kind of makes sense; our <code>&lt;@@ true &amp;&amp; true @@&gt;</code> is being turned (loosely) into <code>if true then true else false</code> &ndash; which is equivalent.</p>

<p>Let&rsquo;s put something other than plain boolean constants in to see if we can make it clearer.</p>

<p>```fsharp
&lt;@@ &ldquo;b&rdquo; = &ldquo;b&rdquo; &amp;&amp; &ldquo;t&rdquo; = &ldquo;t&rdquo; @@>;;
(* val it : Expr =</p>

<pre><code>  IfThenElse (Call (None, op_Equality, [Value ("b"), Value ("b")]),
            Call (None, op_Equality, [Value ("t"), Value ("t")]), Value (false))
    {CustomAttributes = ...;
     Type = System.Boolean;} *)
</code></pre>

<p>```</p>

<p>Looks hopeful. As a last check, let&rsquo;s take advantage of the fact that quotations are structurally comparable to double check our understanding:</p>

<p><code>fsharp
&lt;@@ if "b" = "b" then "t" = "t" else false @@&gt; = &lt;@@ "b" = "b" &amp;&amp; "t" = "t" @@&gt;;;
(* val it : bool = true *)
</code></p>

<p>Awesome!</p>

<p>I&rsquo;m going to take a wild punt that the <code>||</code> operator does something similar:</p>

<p><code>fsharp
&lt;@@ if "b" = "t" then true else "t" = "b" @@&gt; = &lt;@@ "b" = "t" || "t" = "b" @@&gt;;;
(* val it : bool = true *)
</code></p>

<p>And it does. Excellent.</p>

<p>We&rsquo;ve now got an idea what the expression trees are going to look like, but how do we go about manipulating them? The answer is the answer we always hope for when traversing data structure in F#: pattern matching.</p>

<p>The <code>Expr</code> types are all recognized by a set of <a href="http://msdn.microsoft.com/en-us/library/ee370259.aspx">active patterns</a> in the <code>Microsoft.FSharp.Quotations.Patterns</code> module. The only problem is that there are about 40 cases in the active patterns, and at the moment we&rsquo;re only interested in one: the <code>IfThenElse</code> case.</p>

<p>That&rsquo;s sounding rather verbose for a language that&rsquo;s normally as succinct as F# and fortunately the language designers agreed. As well as the specific cases in the main <code>Patterns</code> module, there are a number of other modules under the <code>Microsoft.FSharp.Quotations</code> namespace that contain &ldquo;broader&rdquo; active patterns, and helper methods for rebuilding expressions.</p>

<p>Let&rsquo;s take the broadest set, from the <code>ExprShape</code> module, and have a look at a method that takes in an expression, recursively works it way through the tree, and rebuilds it exactly as it was before:</p>

<p>```fsharp
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape</p>

<p>let rec id q =</p>

<pre><code>match q with
| ShapeVar v -&gt; Expr.Var v
| ShapeLambda (v, e) -&gt; Expr.Lambda(v, id e)
| ShapeCombination (o, es) -&gt;
    RebuildShapeCombination(o, es |&gt; List.map id)
</code></pre>

<p>```</p>

<p>So, as we recurse down there are three possibilities for our expression on any one pass through the <code>id</code> function:</p>

<ul>
<li>We&rsquo;ve hit a <code>Var</code>: this is a leaf node holding a variable, we&rsquo;re done with this branch of the tree.</li>
<li>We&rsquo;ve hit a lambda function, with a variable being bound and an expression representing the body of the function. We apply <code>id</code> to the body to continue recursing down.</li>
<li>We&rsquo;ve hit something else; anything else. The <code>ShapeCombination</code> pattern knows how to take the structure apart, and the <code>RebuildShapeCombination</code> method from the same module knows how to use the object <code>ShapeCombination</code> spits to put it back together again. In the mean time, we still apply <code>id</code> to all the sub-expressions of the combination, whatever they may be.</li>
</ul>


<p>(As an aside, don&rsquo;t actually call your functions <code>id</code> &ndash; there&rsquo;s already a function called that in the standard library.)</p>

<p>Of course, on it&rsquo;s own that&rsquo;s not very exciting. But how about if before moving onto these very broad shapes, we first check some specific cases?</p>

<p>Let&rsquo;s see if we can detect <code>true</code> literals within an expression.</p>

<p>```fsharp
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape
open Microsoft.FSharp.Quotations.Patterns</p>

<p>let rec detectTrue q =</p>

<pre><code>match q with
| Value (o, t) when t = typeof&lt;bool&gt; &amp;&amp; (o :?&gt; bool) = true -&gt;
    true
| ShapeVar _ -&gt;
    false
| ShapeLambda (_, e) -&gt;
    detectTrue e
| ShapeCombination (o, es) -&gt;
    es
    |&gt; List.map detectTrue
    |&gt; List.fold (||) false
</code></pre>

<p>```</p>

<p>The <code>Value</code> pattern gives us an object representing a literal and it&rsquo;s type as a tuple. We&rsquo;ll add a guard condition to the pattern to specify that we&rsquo;re only interested when the type is <code>bool</code> and (taking advantage of short circuiting to make sure we don&rsquo;t try and cast if it&rsquo;s not a bool!) when the value is <code>true</code>. After that, we move back to our broader patterns, but this time we&rsquo;re happy to throw away most of the information at each step as we&rsquo;re not interested in
reconstructing the tree afterwards.</p>

<p>Loading up the function in F# Interactive, we can feed it some test inputs and see how we&rsquo;re doing.</p>

<p><code>fsharp
detectTrue &lt;@@ fun x -&gt; true @@&gt;;;
(* val it : bool = true *)
detectTrue &lt;@@ fun x -&gt; false @@&gt;;;
(* val it : bool = false *)
detectTrue &lt;@@ fun x -&gt; false || true @@&gt;;;
(* val it : bool = true *)
detectTrue &lt;@@ fun x y -&gt; y || x true @@&gt;;;
(* val it : bool = true *)
detectTrue &lt;@@ fun x y -&gt; y || x = true @@&gt;;;
(* val it : bool = true *)
detectTrue &lt;@@ "bob" @@&gt;;;
(* val it : bool = false *)
</code></p>

<p>Looking good.</p>

<p>Looks like we need just one final step before we start playing with the rules of boolean algebra; let&rsquo;s check we can detect the <code>||</code> and <code>&amp;&amp;</code> operators.</p>

<p>First, let&rsquo;s give ourselves some helper active patterns of our own to detect literal <code>true</code> and <code>false</code> values:</p>

<p>```fsharp
open Microsoft.FSharp.Quotations
open Microsoft.FSharp.Quotations.ExprShape
open Microsoft.FSharp.Quotations.Patterns</p>

<p>let (|True'|_|) expr =</p>

<pre><code>match expr with
| Value (o, t) when t = typeof&lt;bool&gt; &amp;&amp; (o :?&gt; bool) = true -&gt;
    Some expr
| _ -&gt;
    None
</code></pre>

<p>let (|False'|_|) expr =</p>

<pre><code>match expr with
| Value (o, t) when t = typeof&lt;bool&gt; &amp;&amp; (o :?&gt; bool) = false -&gt;
    Some expr
| _ -&gt;
    None
</code></pre>

<p>```</p>

<p>Now, let&rsquo;s add some more for <code>||</code> and <code>&amp;&amp;</code>:</p>

<p>```fsharp
let (|Or'|_|) expr =</p>

<pre><code>match expr with
| IfThenElse (left, True' _, right) -&gt;
    Some (left, right)
| _ -&gt;
    None
</code></pre>

<p>let (|And'|_|) expr =</p>

<pre><code>match expr with
| IfThenElse (left, right, False' _) -&gt;
    Some (left, right)
| _ -&gt;
    None
</code></pre>

<p>```</p>

<p>Because you can nest patterns within a pattern match, here we&rsquo;re only matching <code>IfThenElse</code> expressions where the &lsquo;then&rsquo; clause (<code>||</code>) is always <code>true</code> or the &lsquo;else&rsquo; clause (<code>&amp;&amp;</code>) is always <code>false</code>.</p>

<p>And now, with all our pieces in place, let&rsquo;s pick one of the rules of boolean algebra and see if we can apply it. Commutativity sounds like it&rsquo;s probably the simplest:</p>

<p>```fsharp
let commute quote =</p>

<pre><code>match quote with
| Or' (left, right) -&gt;
    &lt;@@ %%right || %%left @@&gt;
| And' (left, right) -&gt;
    &lt;@@ %%right &amp;&amp; %%left @@&gt;
| _ -&gt;
    quote
</code></pre>

<p>```</p>

<p>Pretty simple: if we see a <code>&amp;&amp;</code> or a <code>||</code> as the top expression in a quotation, swap the arguments. There&rsquo;s no recursion, so we won&rsquo;t go through the tree swapping every <code>&amp;&amp;</code> or <code>||</code> expression, although we could if we wanted&hellip;</p>

<p>For example:</p>

<p>```fsharp
// basic usage
&lt;@@ true || false @@> = commute &lt;@@ false || true @@>;;
(<em> val it : bool = true </em>)
&lt;@@ &ldquo;bob&rdquo; = &ldquo;fred&rdquo; || &ldquo;fred&rdquo; = &ldquo;bob&rdquo; @@> = commute &lt;@@ &ldquo;fred&rdquo; = &ldquo;bob&rdquo; || &ldquo;bob&rdquo; = &ldquo;fred&rdquo; @@>;;
(<em> val it : bool = true </em>)</p>

<p>// only operates at the top level though
&lt;@@ fun x &ndash;> true || false @@> = commute &lt;@@ fun x &ndash;> false || true @@>;;
(<em> val it : bool = false </em>)
```</p>

<p>A nice simple function, to apply a nice simple rule. Generally you&rsquo;ll want to choose when to apply something like the <code>commute</code> function, hence not making it recursive. But what about something like the identity law?</p>

<p>The identity law states that <code>true &amp;&amp; x = x</code> and <code>false || x = x</code> for all x. This looks like it might allow us to remove redundant statements from our boolean expressions without changing the logical result, and if we&rsquo;re interested in carrying out this operation at all we almost certainly want to apply it recursively down through the expression.</p>

<p>Time to break out our broad <code>ExprShape</code> patterns again:</p>

<p>```fsharp
let identity quote =</p>

<pre><code>let rec transform q =
    match q with
    | And' (True' _, p)
    | And' (p, True' _)
    | Or' (False' _, p) 
    | Or' (p, False' _)
        -&gt; transform p
    | ShapeVar v -&gt; Expr.Var v
    | ShapeLambda (v, e) -&gt; Expr.Lambda(v, transform e)
    | ShapeCombination (o, es) -&gt;
        RebuildShapeCombination(o, es |&gt; List.map transform)
transform quote
</code></pre>

<p>```</p>

<p>Firstly, we check if the top of the quotation matches any of the four relevant conditions for the identity law. If any of them do, we bind the proposition that we&rsquo;re reducing to to the name <code>p</code>, and then we carry on recursing down the tree.</p>

<p>Otherwise, we&rsquo;re back to the <code>id</code> function above: a <code>Var</code> is a leaf node, we <code>transform</code> the body of any lambdas and if we hit a combination we <code>transform</code> all of it&rsquo;s constituent expressions.</p>

<p>This is starting to reach the stage it&rsquo;s worth unit testing, so let&rsquo;s break out xUnit and add some &ldquo;facts&rdquo; (you&rsquo;ll need to reference xUnit manually or via NuGet to build the tests.)</p>

<p>```fsharp
open Algebra.Boolean
open Xunit</p>

<p>[<Fact>]
let <code>Identity reduction &amp;&amp;</code> () =</p>

<pre><code>Assert.Equal (&lt;@@ false @@&gt;, identity &lt;@@ true &amp;&amp; false @@&gt;)
</code></pre>

<p>[<Fact>]
let <code>Identity reduction ||</code> () =</p>

<pre><code>Assert.Equal (&lt;@@ true @@&gt;, identity &lt;@@ true || false @@&gt;)
</code></pre>

<p>[<Fact>]
let <code>Identity reduction recurses</code> () =</p>

<pre><code>Assert.Equal (&lt;@@ true @@&gt;, identity &lt;@@ (true || false) &amp;&amp; true @@&gt;)
</code></pre>

<p>[<Fact>]
let <code>Identity reduction recurses with none boolean</code> () =</p>

<pre><code>Assert.Equal (&lt;@@ "bob" = "fred" @@&gt;, identity &lt;@@ ("bob" = "fred" || false) &amp;&amp; true @@&gt;)
</code></pre>

<p>[<Fact>]
let <code>Identity reduction recurses with none boolean 2</code> () =</p>

<pre><code>Assert.Equal (&lt;@@ "bob" = "fred" @@&gt;, identity &lt;@@ (false || "bob" = "fred") &amp;&amp; true @@&gt;)
</code></pre>

<p>```</p>

<p>And there you have it, a function that takes an expression tree and manipulates it in a potentially useful fashion.</p>

<p>Why did we go to all this trouble? Well, I&rsquo;m afraid for that, dear reader, you&rsquo;ll have to either wait for the next installment or come along to my session at <a href="https://skillsmatter.com/conferences/1926-progressive-f-tutorials-2014#program">Progressive F# London 2014</a> where we look at translating quotations into other languages.</p>

<p>If you want to look into this further yourself in the mean time, an implementation of all of the rules of boolean algebra and a basic test suite can be found in a <a href="https://gist.github.com/mavnn/9acfb52c8c311879266b">gist on github</a>.</p>

<p>If you&rsquo;re feeling really brave, I also highly recommend looking into &ldquo;A Practical Theory of Language-Integrated Query&rdquo;:</p>

<ul>
<li><a href="https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query">Talk by Philip Wadler</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf">Academic paper describing the techniques</a> &ndash; the first few sections are very readable even without a background in programming language research, and definitely worth looking at before you get to&hellip;</li>
<li><a href="https://github.com/fsprojects/FSharp.Linq.ComposableQuery">The practical implementation</a> &ndash; if you want to watch people much cleverer than me <strong>really</strong> apply some of these principles.</li>
</ul>


<p>That&rsquo;s all till next time, and I hope your brains recover sooner than mine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tap, tap, tapping on the door]]></title>
    <link href="http://blog.mavnn.co.uk/tap/"/>
    <updated>2014-05-30T11:45:35+01:00</updated>
    <id>http://blog.mavnn.co.uk/tap</id>
    <content type="html"><![CDATA[<p>In my investigations into <a href="/blog/categories/typeprovider/">type providers</a>, I started digging into a feature of F# called quotations. These blur the boundary between code and data; a representation of an expression tree that you can then evaluate or manipulate.</p>

<p>Why is this useful? Well; it&rsquo;s used in a number of places in various F# libraries. As mentioned above, type providers use them as a mechanism for providing the invocation code for the types that are being provided. The compiler can then take that expression tree and turn in into clr code.</p>

<p>They can also be useful as a way of defining code within your F# that can then be translated into other programming languages. The linq to sql implementation does this (turning your linq into SQL, fairly obviously!) while the FunScript project compiles your F# quotations into JavaScript.</p>

<p>So; linked features, often used in concert: quotations allow you to generate expressions at runtime, manipulate them at run time and evaluate them at run time &ndash; where evaluation covers everything from running the code on the clr to outputting it as a different language.</p>

<!-- more -->


<p>Creating expressions is fairly straightforward. If you have a valid F# expression, you can wrap it in <code>&lt;@ ... @&gt;</code> (or <code>&lt;@@ ... @@&gt;</code>, see below&hellip;):</p>

<p>```fsharp
let quote1 = &lt;@ 1 + 2 @></p>

<p>// val quote1 : Expr<int> = Call (None, op_Addition, [Value (1), Value (2)])</p>

<p>let quote2 = &lt;@@ 2 + 1 @@>;;</p>

<p>// val quote2 : Expr = Call (None, op_Addition, [Value (2), Value (1)])
```</p>

<p>What&rsquo;s the difference between the two? Well, the first with it&rsquo;s strong typing provides you with greater safety if you know what types you&rsquo;re expecting an expression tree to evaluate to &ndash; but those same type restraints prevent you from writing methods which can transform and return expressions whose types are unknown at compile time. There are also, apparently, some performance implications to carrying around the type information.</p>

<p>You can also generate the expression trees directly using the <code>Expr</code> module in the <code>Microsoft.FSharp.Quotations</code> namespace.</p>

<p>```fsharp
open Microsoft.FSharp.Quotations</p>

<p>Expr.Call(typeof&lt;System.Math>.GetMethod(&ldquo;Cos&rdquo;), [Expr.Value(1.0)])</p>

<p>// val it : Expr = Call (None, Cos, [Value (1.0)]) {CustomAttributes = [];
//                                                 Type = System.Double;}
```</p>

<p>The above being identical to: <code>&lt;@@ System.Math.Cos(1.0) @@&gt;</code>. Building directly with the classes becomes especially useful when doing things like recursively building expression trees; the F# compilers type inference tends to get a little unhappy trying to infer the types of the quotations and the expressions you&rsquo;re splicing into them on occasion.</p>

<p>Splicing?</p>

<p>Okay, so I slightly snuck that one in there. If you&rsquo;re building expressions with the <code>Expr</code> module it&rsquo;s obviously how you could create functions that could compose into larger expression trees. But the F# quotation syntax also allows you to do something similar, splicing values in with the <code>%</code> and <code>%%</code> operators.</p>

<p>An example is worth 1,000 words in these situations:</p>

<p>```fsharp
let splice otherExpr =</p>

<pre><code>&lt;@
    System.Math.Cos(%otherExpr)
@&gt;
</code></pre>

<p>// val splice : otherExpr:Expr<float> &ndash;> Expr<float></p>

<p>let complete = splice &lt;@ 1.0 @></p>

<p>// val complete : Expr<float> = Call (None, Cos, [Value (1.0)])</p>

<p>// And the untyped (and less safe) option:</p>

<p>let splice' otherExpr =</p>

<pre><code>&lt;@@
    System.Math.Cos(%%otherExpr)
@@&gt;
</code></pre>

<p>// val splice' : otherExpr:Expr &ndash;> Expr</p>

<p>let complete' = splice' &lt;@@ 1.0 @@></p>

<p>// val complete' : Expr = Call (None, Cos, [Value (1.0)])
```</p>

<p>As an aside, the generic <code>Expr</code> type has the <code>Raw</code> property which exposes the untyped version of the quotation. Which, as quotations have value based equality, allows us to do this:</p>

<p>```fsharp
complete.Raw = complete'</p>

<p>// val it : bool = true
```</p>

<p>And of course we can build up more complex trees if we wish:</p>

<p>```fsharp
let moreComplexComplete =</p>

<pre><code>let value =
    &lt;@ 
        System.Math.Max(
            -0.8, 
            System.Math.Min(
                0.8, 
                System.Math.Sin(2.0))) 
    @&gt;
splice value
</code></pre>

<p>// val moreComplexComplete : Expr<float> =
//   Call (None, Cos,
//       [Call (None, Max,
//              [Value (-0.8),
//               Call (None, Min, [Value (0.8), Call (None, Sin, [Value (2.0)])])])])
```</p>

<p>Finished here? Time to check out part 2 about how to manipulate quotations once you have them: <a href="/cutting-quotations-down-to-size/">Cutting Quotations Down to Size</a>.</p>

<p><em>Yes, I know the title quote is inaccurate &ndash; but I&rsquo;m afraid I prefer it this way.</em></p>
]]></content>
  </entry>
  
</feed>
