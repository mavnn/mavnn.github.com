<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quotations | Mavnn's blog]]></title>
  <link href="https://blog.mavnn.co.uk/blog/categories/quotations/atom.xml" rel="self"/>
  <link href="https://blog.mavnn.co.uk/"/>
  <updated>2020-03-20T20:35:10+00:00</updated>
  <id>https://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cutting Quotations Down to Size]]></title>
    <link href="https://blog.mavnn.co.uk/cutting-quotations-down-to-size/"/>
    <updated>2014-10-07T21:30:58+01:00</updated>
    <id>https://blog.mavnn.co.uk/cutting-quotations-down-to-size</id>
    <content type="html"><![CDATA[<blockquote>
<p>This is part 2 in my quotations series, following on from <a href="/tap/">Tap, Tap, Tapping on the Door</a>.</p>
</blockquote>

<p>As promised in the first part of this series, here we&#39;re going to take a look at manipulating quotations. I mean, we&#39;ve got this <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> - now what are we going to do with it?</p>

<p>Let&#39;s start with something fairly straightforward; <a href="http://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a>.</p>

<p>First, let&#39;s get a look at how some boolean expressions are represented in quotations.</p>

<p>Firing up F# Interactive, we&#39;ll feed a few in and see what happens:</p>
<div class="highlight"><pre><code class="fsharp"><span class="o">&lt;@@</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : Expr =</span>
<span class="c">      Value (true)</span>
<span class="c">        {CustomAttributes = [NewTuple (Value (&quot;DebugRange&quot;),</span>
<span class="c">              NewTuple (Value (&quot;stdin&quot;), Value (4), Value (4), Value (4), Value (8)))];</span>
<span class="c">         Type = System.Boolean;} *)</span>
</code></pre></div>
<p>Hmm. That&#39;s... not as nice as we might want. The custom attributes are being added by F# interactive for debugging purposes, but hopefully the general shape is clear: our expression consists of a single value of <code>true</code>.</p>

<p>I&#39;ll cut out the custom attributes from now on to make reading things a bit easier.</p>

<p>Next!</p>

<!-- more -->
<div class="highlight"><pre><code class="fsharp"><span class="o">&lt;@@</span> <span class="bp">true</span> <span class="o">&amp;&amp;</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : Expr =</span>
<span class="c">      IfThenElse (Value (true), Value (true), Value (false))</span>
<span class="c">        {CustomAttributes = ...;</span>
<span class="c">         Type = System.Boolean;} *)</span>
</code></pre></div>
<p>So. Looks like someone has decided to represent the <code>&amp;&amp;</code> operator with the expression tree of an <code>if</code> statement. Useful in some ways; after all, any logic we can apply to an <code>&amp;&amp;</code> operator will equally apply to a logically equivalent <code>if</code> statement. Checking the <a href="http://msdn.microsoft.com/en-us/library/ee370408.aspx">MSDN documentation for Expr.IfThenElse</a> tells if that the 3 values above are <code>guard</code>, <code>thenExpr</code> and <code>elseExpr</code>. Which kind of makes sense; our <code>&lt;@@ true &amp;&amp; true @@&gt;</code> is being turned (loosely) into <code>if true then true else false</code> - which is equivalent.</p>

<p>Let&#39;s put something other than plain boolean constants in to see if we can make it clearer.</p>
<div class="highlight"><pre><code class="fsharp"><span class="o">&lt;@@</span> <span class="s2">&quot;b&quot;</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span> <span class="o">&amp;&amp;</span> <span class="s2">&quot;t&quot;</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : Expr =</span>
<span class="c">      IfThenElse (Call (None, op_Equality, [Value (&quot;b&quot;), Value (&quot;b&quot;)]),</span>
<span class="c">                Call (None, op_Equality, [Value (&quot;t&quot;), Value (&quot;t&quot;)]), Value (false))</span>
<span class="c">        {CustomAttributes = ...;</span>
<span class="c">         Type = System.Boolean;} *)</span>
</code></pre></div>
<p>Looks hopeful. As a last check, let&#39;s take advantage of the fact that quotations are structurally comparable to double check our understanding:</p>
<div class="highlight"><pre><code class="fsharp"><span class="o">&lt;@@</span> <span class="k">if</span> <span class="s2">&quot;b&quot;</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span> <span class="k">then</span> <span class="s2">&quot;t&quot;</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span> <span class="k">else</span> <span class="bp">false</span> <span class="o">@@&gt;</span> <span class="o">=</span> <span class="o">&lt;@@</span> <span class="s2">&quot;b&quot;</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span> <span class="o">&amp;&amp;</span> <span class="s2">&quot;t&quot;</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
</code></pre></div>
<p>Awesome!</p>

<p>I&#39;m going to take a wild punt that the <code>||</code> operator does something similar:</p>
<div class="highlight"><pre><code class="fsharp"><span class="o">&lt;@@</span> <span class="k">if</span> <span class="s2">&quot;b&quot;</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span> <span class="k">then</span> <span class="bp">true</span> <span class="k">else</span> <span class="s2">&quot;t&quot;</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span> <span class="o">@@&gt;</span> <span class="o">=</span> <span class="o">&lt;@@</span> <span class="s2">&quot;b&quot;</span> <span class="o">=</span> <span class="s2">&quot;t&quot;</span> <span class="o">||</span> <span class="s2">&quot;t&quot;</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
</code></pre></div>
<p>And it does. Excellent.</p>

<p>We&#39;ve now got an idea what the expression trees are going to look like, but how do we go about manipulating them? The answer is the answer we always hope for when traversing data structure in F#: pattern matching.</p>

<p>The <code>Expr</code> types are all recognized by a set of <a href="http://msdn.microsoft.com/en-us/library/ee370259.aspx">active patterns</a> in the <code>Microsoft.FSharp.Quotations.Patterns</code> module. The only problem is that there are about 40 cases in the active patterns, and at the moment we&#39;re only interested in one: the <code>IfThenElse</code> case.</p>

<p>That&#39;s sounding rather verbose for a language that&#39;s normally as succinct as F# and fortunately the language designers agreed. As well as the specific cases in the main <code>Patterns</code> module, there are a number of other modules under the <code>Microsoft.FSharp.Quotations</code> namespace that contain &quot;broader&quot; active patterns, and helper methods for rebuilding expressions.</p>

<p>Let&#39;s take the broadest set, from the <code>ExprShape</code> module, and have a look at a method that takes in an expression, recursively works it way through the tree, and rebuilds it exactly as it was before:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nc">Quotations</span>
<span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Quotations</span><span class="p">.</span><span class="nc">ExprShape</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">id</span> <span class="n">q</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">q</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">ShapeVar</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="nn">Expr</span><span class="p">.</span><span class="nc">Var</span> <span class="n">v</span>
    <span class="o">|</span> <span class="nc">ShapeLambda</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">Expr</span><span class="p">.</span><span class="nc">Lambda</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">id</span> <span class="n">e</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">ShapeCombination</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">es</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nc">RebuildShapeCombination</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">es</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">id</span><span class="o">)</span>
</code></pre></div>
<p>So, as we recurse down there are three possibilities for our expression on any one pass through the <code>id</code> function:</p>

<ul>
<li>We&#39;ve hit a <code>Var</code>: this is a leaf node holding a variable, we&#39;re done with this branch of the tree.</li>
<li>We&#39;ve hit a lambda function, with a variable being bound and an expression representing the body of the function. We apply <code>id</code> to the body to continue recursing down.</li>
<li>We&#39;ve hit something else; anything else. The <code>ShapeCombination</code> pattern knows how to take the structure apart, and the <code>RebuildShapeCombination</code> method from the same module knows how to use the object <code>ShapeCombination</code> spits to put it back together again. In the mean time, we still apply <code>id</code> to all the sub-expressions of the combination, whatever they may be.</li>
</ul>

<p>(As an aside, don&#39;t actually call your functions <code>id</code> - there&#39;s already a function called that in the standard library.)</p>

<p>Of course, on it&#39;s own that&#39;s not very exciting. But how about if before moving onto these very broad shapes, we first check some specific cases?</p>

<p>Let&#39;s see if we can detect <code>true</code> literals within an expression.</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nc">Quotations</span>
<span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Quotations</span><span class="p">.</span><span class="nc">ExprShape</span>
<span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Quotations</span><span class="p">.</span><span class="nc">Patterns</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">detectTrue</span> <span class="n">q</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">q</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Value</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">o</span> <span class="o">:?&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">=</span> <span class="bp">true</span> <span class="o">-&gt;</span>
        <span class="bp">true</span>
    <span class="o">|</span> <span class="nc">ShapeVar</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="bp">false</span>
    <span class="o">|</span> <span class="nc">ShapeLambda</span> <span class="o">(_,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="n">detectTrue</span> <span class="n">e</span>
    <span class="o">|</span> <span class="nc">ShapeCombination</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">es</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="n">es</span>
        <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">detectTrue</span>
        <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold</span> <span class="o">(||)</span> <span class="bp">false</span>
</code></pre></div>
<p>The <code>Value</code> pattern gives us an object representing a literal and it&#39;s type as a tuple. We&#39;ll add a guard condition to the pattern to specify that we&#39;re only interested when the type is <code>bool</code> and (taking advantage of short circuiting to make sure we don&#39;t try and cast if it&#39;s not a bool!) when the value is <code>true</code>. After that, we move back to our broader patterns, but this time we&#39;re happy to throw away most of the information at each step as we&#39;re not interested in
reconstructing the tree afterwards.</p>

<p>Loading up the function in F# Interactive, we can feed it some test inputs and see how we&#39;re doing.</p>
<div class="highlight"><pre><code class="fsharp"><span class="n">detectTrue</span> <span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
<span class="n">detectTrue</span> <span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="bp">false</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = false *)</span>
<span class="n">detectTrue</span> <span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="bp">false</span> <span class="o">||</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
<span class="n">detectTrue</span> <span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">||</span> <span class="n">x</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
<span class="n">detectTrue</span> <span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">||</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
<span class="n">detectTrue</span> <span class="o">&lt;@@</span> <span class="s2">&quot;bob&quot;</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = false *)</span>
</code></pre></div>
<p>Looking good.</p>

<p>Looks like we need just one final step before we start playing with the rules of boolean algebra; let&#39;s check we can detect the <code>||</code> and <code>&amp;&amp;</code> operators.</p>

<p>First, let&#39;s give ourselves some helper active patterns of our own to detect literal <code>true</code> and <code>false</code> values:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nc">Quotations</span>
<span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Quotations</span><span class="p">.</span><span class="nc">ExprShape</span>
<span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Quotations</span><span class="p">.</span><span class="nc">Patterns</span>


<span class="k">let</span> <span class="o">(|</span><span class="nc">True&#39;</span><span class="o">|_|)</span> <span class="n">expr</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">expr</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Value</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">o</span> <span class="o">:?&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">=</span> <span class="bp">true</span> <span class="o">-&gt;</span>
        <span class="nc">Some</span> <span class="n">expr</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="nc">None</span>

<span class="k">let</span> <span class="o">(|</span><span class="nc">False&#39;</span><span class="o">|_|)</span> <span class="n">expr</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">expr</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Value</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">when</span> <span class="n">t</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">o</span> <span class="o">:?&gt;</span> <span class="kt">bool</span><span class="o">)</span> <span class="o">=</span> <span class="bp">false</span> <span class="o">-&gt;</span>
        <span class="nc">Some</span> <span class="n">expr</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="nc">None</span>
</code></pre></div>
<p>Now, let&#39;s add some more for <code>||</code> and <code>&amp;&amp;</code>:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="o">(|</span><span class="nc">Or&#39;</span><span class="o">|_|)</span> <span class="n">expr</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">expr</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">IfThenElse</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="nc">True&#39;</span> <span class="o">_,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nc">Some</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="nc">None</span>

<span class="k">let</span> <span class="o">(|</span><span class="nc">And&#39;</span><span class="o">|_|)</span> <span class="n">expr</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">expr</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">IfThenElse</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="nc">False&#39;</span> <span class="o">_)</span> <span class="o">-&gt;</span>
        <span class="nc">Some</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="nc">None</span>
</code></pre></div>
<p>Because you can nest patterns within a pattern match, here we&#39;re only matching <code>IfThenElse</code> expressions where the &#39;then&#39; clause (<code>||</code>) is always <code>true</code> or the &#39;else&#39; clause (<code>&amp;&amp;</code>) is always <code>false</code>.</p>

<p>And now, with all our pieces in place, let&#39;s pick one of the rules of boolean algebra and see if we can apply it. Commutativity sounds like it&#39;s probably the simplest:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">commute</span> <span class="n">quote</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">quote</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Or&#39;</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="o">&lt;@@</span> <span class="o">%%</span><span class="n">right</span> <span class="o">||</span> <span class="o">%%</span><span class="n">left</span> <span class="o">@@&gt;</span>
    <span class="o">|</span> <span class="nc">And&#39;</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="o">&lt;@@</span> <span class="o">%%</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">%%</span><span class="n">left</span> <span class="o">@@&gt;</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
        <span class="n">quote</span>
</code></pre></div>
<p>Pretty simple: if we see a <code>&amp;&amp;</code> or a <code>||</code> as the top expression in a quotation, swap the arguments. There&#39;s no recursion, so we won&#39;t go through the tree swapping every <code>&amp;&amp;</code> or <code>||</code> expression, although we could if we wanted...</p>

<p>For example:</p>
<div class="highlight"><pre><code class="fsharp"><span class="c1">// basic usage</span>
<span class="o">&lt;@@</span> <span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span> <span class="o">@@&gt;</span> <span class="o">=</span> <span class="n">commute</span> <span class="o">&lt;@@</span> <span class="bp">false</span> <span class="o">||</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>
<span class="o">&lt;@@</span> <span class="s2">&quot;bob&quot;</span> <span class="o">=</span> <span class="s2">&quot;fred&quot;</span> <span class="o">||</span> <span class="s2">&quot;fred&quot;</span> <span class="o">=</span> <span class="s2">&quot;bob&quot;</span> <span class="o">@@&gt;</span> <span class="o">=</span> <span class="n">commute</span> <span class="o">&lt;@@</span> <span class="s2">&quot;fred&quot;</span> <span class="o">=</span> <span class="s2">&quot;bob&quot;</span> <span class="o">||</span> <span class="s2">&quot;bob&quot;</span> <span class="o">=</span> <span class="s2">&quot;fred&quot;</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = true *)</span>

<span class="c1">// only operates at the top level though</span>
<span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span> <span class="o">@@&gt;</span> <span class="o">=</span> <span class="n">commute</span> <span class="o">&lt;@@</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="bp">false</span> <span class="o">||</span> <span class="bp">true</span> <span class="o">@@&gt;;;</span>
<span class="c">(* val it : bool = false *)</span>
</code></pre></div>
<p>A nice simple function, to apply a nice simple rule. Generally you&#39;ll want to choose when to apply something like the <code>commute</code> function, hence not making it recursive. But what about something like the identity law?</p>

<p>The identity law states that <code>true &amp;&amp; x = x</code> and <code>false || x = x</code> for all x. This looks like it might allow us to remove redundant statements from our boolean expressions without changing the logical result, and if we&#39;re interested in carrying out this operation at all we almost certainly want to apply it recursively down through the expression.</p>

<p>Time to break out our broad <code>ExprShape</code> patterns again:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">identity</span> <span class="n">quote</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">transform</span> <span class="n">q</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">q</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">And&#39;</span> <span class="o">(</span><span class="nc">True&#39;</span> <span class="o">_,</span> <span class="n">p</span><span class="o">)</span>
        <span class="o">|</span> <span class="nc">And&#39;</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="nc">True&#39;</span> <span class="o">_)</span>
        <span class="o">|</span> <span class="nc">Or&#39;</span> <span class="o">(</span><span class="nc">False&#39;</span> <span class="o">_,</span> <span class="n">p</span><span class="o">)</span> 
        <span class="o">|</span> <span class="nc">Or&#39;</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="nc">False&#39;</span> <span class="o">_)</span>
            <span class="o">-&gt;</span> <span class="n">transform</span> <span class="n">p</span>
        <span class="o">|</span> <span class="nc">ShapeVar</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="nn">Expr</span><span class="p">.</span><span class="nc">Var</span> <span class="n">v</span>
        <span class="o">|</span> <span class="nc">ShapeLambda</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">Expr</span><span class="p">.</span><span class="nc">Lambda</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">transform</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">|</span> <span class="nc">ShapeCombination</span> <span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">es</span><span class="o">)</span> <span class="o">-&gt;</span>
            <span class="nc">RebuildShapeCombination</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">es</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">transform</span><span class="o">)</span>
    <span class="n">transform</span> <span class="n">quote</span>
</code></pre></div>
<p>Firstly, we check if the top of the quotation matches any of the four relevant conditions for the identity law. If any of them do, we bind the proposition that we&#39;re reducing to to the name <code>p</code>, and then we carry on recursing down the tree.</p>

<p>Otherwise, we&#39;re back to the <code>id</code> function above: a <code>Var</code> is a leaf node, we <code>transform</code> the body of any lambdas and if we hit a combination we <code>transform</code> all of it&#39;s constituent expressions.</p>

<p>This is starting to reach the stage it&#39;s worth unit testing, so let&#39;s break out xUnit and add some &quot;facts&quot; (you&#39;ll need to reference xUnit manually or via NuGet to build the tests.)</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">open</span> <span class="nn">Algebra</span><span class="p">.</span><span class="nc">Boolean</span>
<span class="k">open</span> <span class="nc">Xunit</span>

<span class="o">[&lt;</span><span class="nc">Fact</span><span class="o">&gt;]</span>
<span class="k">let</span> <span class="o">``</span><span class="nc">Identity</span> <span class="n">reduction</span> <span class="o">&amp;&amp;``</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="nc">Equal</span> <span class="o">(&lt;@@</span> <span class="bp">false</span> <span class="o">@@&gt;,</span> <span class="n">identity</span> <span class="o">&lt;@@</span> <span class="bp">true</span> <span class="o">&amp;&amp;</span> <span class="bp">false</span> <span class="o">@@&gt;)</span>

<span class="o">[&lt;</span><span class="nc">Fact</span><span class="o">&gt;]</span>
<span class="k">let</span> <span class="o">``</span><span class="nc">Identity</span> <span class="n">reduction</span> <span class="o">||``</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="nc">Equal</span> <span class="o">(&lt;@@</span> <span class="bp">true</span> <span class="o">@@&gt;,</span> <span class="n">identity</span> <span class="o">&lt;@@</span> <span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span> <span class="o">@@&gt;)</span>

<span class="o">[&lt;</span><span class="nc">Fact</span><span class="o">&gt;]</span>
<span class="k">let</span> <span class="o">``</span><span class="nc">Identity</span> <span class="n">reduction</span> <span class="n">recurses</span><span class="o">``</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="nc">Equal</span> <span class="o">(&lt;@@</span> <span class="bp">true</span> <span class="o">@@&gt;,</span> <span class="n">identity</span> <span class="o">&lt;@@</span> <span class="o">(</span><span class="bp">true</span> <span class="o">||</span> <span class="bp">false</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="bp">true</span> <span class="o">@@&gt;)</span>

<span class="o">[&lt;</span><span class="nc">Fact</span><span class="o">&gt;]</span>
<span class="k">let</span> <span class="o">``</span><span class="nc">Identity</span> <span class="n">reduction</span> <span class="n">recurses</span> <span class="k">with</span> <span class="n">none</span> <span class="n">boolean</span><span class="o">``</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="nc">Equal</span> <span class="o">(&lt;@@</span> <span class="s2">&quot;bob&quot;</span> <span class="o">=</span> <span class="s2">&quot;fred&quot;</span> <span class="o">@@&gt;,</span> <span class="n">identity</span> <span class="o">&lt;@@</span> <span class="o">(</span><span class="s2">&quot;bob&quot;</span> <span class="o">=</span> <span class="s2">&quot;fred&quot;</span> <span class="o">||</span> <span class="bp">false</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="bp">true</span> <span class="o">@@&gt;)</span>

<span class="o">[&lt;</span><span class="nc">Fact</span><span class="o">&gt;]</span>
<span class="k">let</span> <span class="o">``</span><span class="nc">Identity</span> <span class="n">reduction</span> <span class="n">recurses</span> <span class="k">with</span> <span class="n">none</span> <span class="n">boolean</span> <span class="mi">2</span><span class="o">``</span> <span class="bp">()</span> <span class="o">=</span>
    <span class="nn">Assert</span><span class="p">.</span><span class="nc">Equal</span> <span class="o">(&lt;@@</span> <span class="s2">&quot;bob&quot;</span> <span class="o">=</span> <span class="s2">&quot;fred&quot;</span> <span class="o">@@&gt;,</span> <span class="n">identity</span> <span class="o">&lt;@@</span> <span class="o">(</span><span class="bp">false</span> <span class="o">||</span> <span class="s2">&quot;bob&quot;</span> <span class="o">=</span> <span class="s2">&quot;fred&quot;</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="bp">true</span> <span class="o">@@&gt;)</span>
</code></pre></div>
<p>And there you have it, a function that takes an expression tree and manipulates it in a potentially useful fashion.</p>

<p>Why did we go to all this trouble? Well, I&#39;m afraid for that, dear reader, you&#39;ll have to either wait for the next installment or come along to my session at <a href="https://skillsmatter.com/conferences/1926-progressive-f-tutorials-2014#program">Progressive F# London 2014</a> where we look at translating quotations into other languages.</p>

<p>If you want to look into this further yourself in the mean time, an implementation of all of the rules of boolean algebra and a basic test suite can be found in a <a href="https://gist.github.com/mavnn/9acfb52c8c311879266b">gist on github</a>.</p>

<p>If you&#39;re feeling really brave, I also highly recommend looking into &quot;A Practical Theory of Language-Integrated Query&quot;:</p>

<ul>
<li><a href="https://skillsmatter.com/skillscasts/4486-a-practical-theory-of-language-integrated-query">Talk by Philip Wadler</a></li>
<li><a href="http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf">Academic paper describing the techniques</a> - the first few sections are very readable even without a background in programming language research, and definitely worth looking at before you get to...</li>
<li><a href="https://github.com/fsprojects/FSharp.Linq.ComposableQuery">The practical implementation</a> - if you want to watch people much cleverer than me <strong>really</strong> apply some of these principles.</li>
</ul>

<p>That&#39;s all till next time, and I hope your brains recover sooner than mine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tap, tap, tapping on the door]]></title>
    <link href="https://blog.mavnn.co.uk/tap/"/>
    <updated>2014-05-30T11:45:35+01:00</updated>
    <id>https://blog.mavnn.co.uk/tap</id>
    <content type="html"><![CDATA[<p>In my investigations into <a href="/blog/categories/typeprovider/">type providers</a>, I started digging into a feature of F# called quotations. These blur the boundary between code and data; a representation of an expression tree that you can then evaluate or manipulate.</p>

<p>Why is this useful? Well; it&#39;s used in a number of places in various F# libraries. As mentioned above, type providers use them as a mechanism for providing the invocation code for the types that are being provided. The compiler can then take that expression tree and turn in into clr code.</p>

<p>They can also be useful as a way of defining code within your F# that can then be translated into other programming languages. The linq to sql implementation does this (turning your linq into SQL, fairly obviously!) while the FunScript project compiles your F# quotations into JavaScript.</p>

<p>So; linked features, often used in concert: quotations allow you to generate expressions at runtime, manipulate them at run time and evaluate them at run time - where evaluation covers everything from running the code on the clr to outputting it as a different language.</p>

<!-- more -->

<p>Creating expressions is fairly straightforward. If you have a valid F# expression, you can wrap it in <code>&lt;@ ... @&gt;</code> (or <code>&lt;@@ ... @@&gt;</code>, see below...):</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">quote1</span> <span class="o">=</span> <span class="o">&lt;@</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">@&gt;</span>

<span class="c1">// val quote1 : Expr&lt;int&gt; = Call (None, op_Addition, [Value (1), Value (2)])</span>

<span class="k">let</span> <span class="n">quote2</span> <span class="o">=</span> <span class="o">&lt;@@</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">@@&gt;;;</span>

<span class="c1">// val quote2 : Expr = Call (None, op_Addition, [Value (2), Value (1)])</span>
</code></pre></div>
<p>What&#39;s the difference between the two? Well, the first with it&#39;s strong typing provides you with greater safety if you know what types you&#39;re expecting an expression tree to evaluate to - but those same type restraints prevent you from writing methods which can transform and return expressions whose types are unknown at compile time. There are also, apparently, some performance implications to carrying around the type information.</p>

<p>You can also generate the expression trees directly using the <code>Expr</code> module in the <code>Microsoft.FSharp.Quotations</code> namespace.</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">open</span> <span class="nn">Microsoft</span><span class="p">.</span><span class="nn">FSharp</span><span class="p">.</span><span class="nc">Quotations</span>

<span class="nn">Expr</span><span class="p">.</span><span class="nc">Call</span><span class="o">(</span><span class="n">typeof</span><span class="o">&lt;</span><span class="nn">System</span><span class="p">.</span><span class="nc">Math</span><span class="o">&gt;.</span><span class="nc">GetMethod</span><span class="o">(</span><span class="s2">&quot;Cos&quot;</span><span class="o">),</span> <span class="o">[</span><span class="nn">Expr</span><span class="p">.</span><span class="nc">Value</span><span class="o">(</span><span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="o">)])</span>

<span class="c1">// val it : Expr = Call (None, Cos, [Value (1.0)]) {CustomAttributes = [];</span>
<span class="c1">//                                                 Type = System.Double;}</span>
</code></pre></div>
<p>The above being identical to: <code>&lt;@@ System.Math.Cos(1.0) @@&gt;</code>. Building directly with the classes becomes especially useful when doing things like recursively building expression trees; the F# compilers type inference tends to get a little unhappy trying to infer the types of the quotations and the expressions you&#39;re splicing into them on occasion.</p>

<p>Splicing?</p>

<p>Okay, so I slightly snuck that one in there. If you&#39;re building expressions with the <code>Expr</code> module it&#39;s obviously how you could create functions that could compose into larger expression trees. But the F# quotation syntax also allows you to do something similar, splicing values in with the <code>%</code> and <code>%%</code> operators.</p>

<p>An example is worth 1,000 words in these situations:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">splice</span> <span class="n">otherExpr</span> <span class="o">=</span>
    <span class="o">&lt;@</span>
        <span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="nc">Cos</span><span class="o">(%</span><span class="n">otherExpr</span><span class="o">)</span>
    <span class="o">@&gt;</span>

<span class="c1">// val splice : otherExpr:Expr&lt;float&gt; -&gt; Expr&lt;float&gt;</span>

<span class="k">let</span> <span class="n">complete</span> <span class="o">=</span> <span class="n">splice</span> <span class="o">&lt;@</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="o">@&gt;</span>

<span class="c1">// val complete : Expr&lt;float&gt; = Call (None, Cos, [Value (1.0)])</span>

<span class="c1">// And the untyped (and less safe) option:</span>

<span class="k">let</span> <span class="n">splice&#39;</span> <span class="n">otherExpr</span> <span class="o">=</span>
    <span class="o">&lt;@@</span>
        <span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="nc">Cos</span><span class="o">(%%</span><span class="n">otherExpr</span><span class="o">)</span>
    <span class="o">@@&gt;</span>

<span class="c1">// val splice&#39; : otherExpr:Expr -&gt; Expr</span>

<span class="k">let</span> <span class="n">complete&#39;</span> <span class="o">=</span> <span class="n">splice&#39;</span> <span class="o">&lt;@@</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span> <span class="o">@@&gt;</span>

<span class="c1">// val complete&#39; : Expr = Call (None, Cos, [Value (1.0)])</span>
</code></pre></div>
<p>As an aside, the generic <code>Expr</code> type has the <code>Raw</code> property which exposes the untyped version of the quotation. Which, as quotations have value based equality, allows us to do this:</p>
<div class="highlight"><pre><code class="fsharp"><span class="n">complete</span><span class="o">.</span><span class="nc">Raw</span> <span class="o">=</span> <span class="n">complete&#39;</span>

<span class="c1">// val it : bool = true</span>
</code></pre></div>
<p>And of course we can build up more complex trees if we wish:</p>
<div class="highlight"><pre><code class="fsharp"><span class="k">let</span> <span class="n">moreComplexComplete</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">value</span> <span class="o">=</span>
        <span class="o">&lt;@</span> 
            <span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="nc">Max</span><span class="o">(</span>
                <span class="o">-</span><span class="mi">0</span><span class="o">.</span><span class="mi">8</span><span class="o">,</span> 
                <span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="nc">Min</span><span class="o">(</span>
                    <span class="mi">0</span><span class="o">.</span><span class="mi">8</span><span class="o">,</span> 
                    <span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="nc">Sin</span><span class="o">(</span><span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="o">)))</span> 
        <span class="o">@&gt;</span>
    <span class="n">splice</span> <span class="n">value</span>

<span class="c1">// val moreComplexComplete : Expr&lt;float&gt; =</span>
<span class="c1">//   Call (None, Cos,</span>
<span class="c1">//       [Call (None, Max,</span>
<span class="c1">//              [Value (-0.8),</span>
<span class="c1">//               Call (None, Min, [Value (0.8), Call (None, Sin, [Value (2.0)])])])])</span>
</code></pre></div>
<p>Finished here? Time to check out part 2 about how to manipulate quotations once you have them: <a href="/cutting-quotations-down-to-size/">Cutting Quotations Down to Size</a>.</p>

<p><em>Yes, I know the title quote is inaccurate - but I&#39;m afraid I prefer it this way.</em></p>
]]></content>
  </entry>
  
</feed>
