<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: suave | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/suave/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2015-04-13T11:44:03+01:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Single file websites with Suave]]></title>
    <link href="http://blog.mavnn.co.uk/single-file-websites-with-suave/"/>
    <updated>2014-02-28T09:54:46+00:00</updated>
    <id>http://blog.mavnn.co.uk/single-file-websites-with-suave</id>
    <content type="html"><![CDATA[<blockquote><p>As of a few days ago, the embedded module <a href="https://github.com/SuaveIO/suave/pull/100/files">was merged</a> into Suave master. Enjoy!</p></blockquote>

<p>I&rsquo;m a great fan of <a href="http://suave.io/">Suave</a> for simple web development in F#. I highly recommend checking out the site for details, but in the mean time I&rsquo;d like to share a little trick I&rsquo;ve been using for rapid prototyping that I&rsquo;m finding very useful.</p>

<p>The Suave.Http module contains a few helpers for serving static files from disk. Unfortunately, depending on use case and deployment strategy, relying on the location of a bunch of files on disk can be problematic.</p>

<p>So (open source to the rescue!) I cracked open the code and wrote a small alternative implementation that serves files from the current assembly&rsquo;s embedded resources. I&rsquo;m finding it especially useful for single page JavaScript apps where you have a small number of resources and then a lot of end points providing api functionality.</p>

<p>Setting up your website looks something like this:</p>

<p>``` fsharp
module Website
open System
open Suave.Http
open Suave.Types
open Embedded</p>

<p>let app =</p>

<pre><code>choose [
    // serve the embedded index.html for "/"
    GET &gt;&gt;= url "/" &gt;&gt;= resource "index.html"
    // check if the request matches the name of an embedded resource
    // if it does, serve it up with a reasonable cache
    GET &gt;&gt;= browse_embedded
    // If it doesn't, try and trigger your api end points
    GET &gt;&gt;= url "/json" &gt;&gt;== (fun _ -&gt; serveJson &lt;| makeData())
    GET &gt;&gt;= url "/carrier" &gt;&gt;== (fun _ -&gt; getCarrierCodes ())
    // Nothing else has worked - 404
    NOT_FOUND "Sorry, couldn't find your page"
]
</code></pre>

<p>web_server default_config app
```</p>

<p>And the embedded module looks like this:</p>

<p>``` fsharp
module Embedded</p>

<p>open System
open System.IO
open System.Reflection
open Suave
open Suave.Http
open Suave.Types
open Suave.Socket</p>

<p>let private ass = Assembly.GetExecutingAssembly()</p>

<p>let private resources =</p>

<pre><code>ass.GetManifestResourceNames()
</code></pre>

<p>let private CACHE_CONTROL_MAX_AGE = 600</p>

<p>let private lastModified = DateTime.UtcNow</p>

<p>let private send_embedded resourceName r =</p>

<pre><code>let write_embedded file (r : HttpRequest) = async {
  use s = ass.GetManifestResourceStream(resourceName)

  if s.Length &gt; 0L then
    do! async_writeln r.connection (sprintf "Content-Length: %d" s.Length) r.line_buffer

  do! async_writeln r.connection "" r.line_buffer

  if s.Length &gt; 0L then
    do! transfer_x r.connection s }

async { do! response_f 200 "OK" (write_embedded resourceName) r } |&gt; succeed
</code></pre>

<p>let resource resourceName =</p>

<pre><code>if resources |&gt; Array.exists ((=) resourceName) then
  let send_it _ = 
    let mimes = mime_type &lt;| IO.Path.GetExtension resourceName
    #if DEBUG
    set_mime_type mimes 
    &gt;&gt; send_embedded (resourceName)
    #else
    set_header "Cache-Control" (sprintf "max-age=%d" CACHE_CONTROL_MAX_AGE)
    &gt;&gt; set_header "Last-Modified" (lastModified.ToString("R"))
    &gt;&gt; set_header "Expires" (DateTime.UtcNow.AddSeconds(float(CACHE_CONTROL_MAX_AGE)).ToString("R")) 
    &gt;&gt; set_mime_type mimes 
    &gt;&gt; send_embedded (resourceName)
    #endif
  warbler ( fun (r:HttpRequest) -&gt;
    let modified_since = (r.headers ? ``if-modified-since`` )
    match modified_since with
    | Some v -&gt; let date = DateTime.Parse v
                if lastModified &gt; date then send_it ()
                else NOT_MODIFIED
    | None   -&gt; send_it ())
else
  never
</code></pre>

<p>let browse_embedded : WebPart =</p>

<pre><code>warbler (fun req -&gt; resource (req.url.TrimStart([| '/' |])))
</code></pre>

<p>```</p>

<p><a href="https://twitter.com/ad3mar">@ad3mar</a> if you feel like rolling this into Suave, you can consider it licenced under what ever is most convenient. An official licence file would make me much happier using Suave in production, by the way (hint, hint).</p>

<p>Edit: ad3mar has pointed out in the comments that Suave is already Apache2 licensed, I just failed to find the file last time I looked.</p>
]]></content>
  </entry>
  
</feed>
