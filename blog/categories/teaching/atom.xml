<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: teaching | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/teaching/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2015-04-01T11:07:01+01:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing F# to Experienced Developers]]></title>
    <link href="http://blog.mavnn.co.uk/introducing-f-number-to-experienced-developers/"/>
    <updated>2013-10-14T12:30:00+01:00</updated>
    <id>http://blog.mavnn.co.uk/introducing-f-number-to-experienced-developers</id>
    <content type="html"><![CDATA[<p>So, as a follow up to <a href="http://blog.mavnn.co.uk/teaching-f-number-to-c-number-devs/">this post</a> I&rsquo;m in the final stages of preparing a presentation for this Friday introducing an audience of (mostly) fairly experienced developers to F# and F# syntax. The main reason for this is to get a number of people up to speed enough on reading F# that they can have a better experience at <a href="http://skillsmatter.com/event/scala/progressive-f-tutorials-2013">the Progressive F# Tutorials</a> at the end of the month. So the aim here isn&rsquo;t to get people fully autonomous and writing code <em>right now</em>, but to allow them to read the bulk of the example code in the tutorials and follow what&rsquo;s going on.</p>

<p>The general approach I&rsquo;ve gone for is to set up a Git repository that has a series of tagged snap shots I can check out as I work through the concepts I&rsquo;m planning to cover. This will enable me to actually demonstrate and run pieces of code, answer questions and make live modifications and then always jump back to a known starting point for the next section of the talk. Given the people involved have all done some .net development and I don&rsquo;t need to cover things like Visual Studio usage and projects, all of the code is contained in a single Program.fs file in a console app. I&rsquo;ve included the snapshot of the file from each tagged commit below, with a brief overview of what I&rsquo;m planning to introduce before skipping to the next snapshot.</p>

<p>With a full screen Visual Studio editing session, I should be able to make the code large enough to be visible and reasonably rapidly guide people to the areas where the code has changed.</p>

<p>A combination of the excellent <a href="http://papercut.codeplex.com/">PaperCut</a> project and a local &lsquo;http request to email&rsquo; service pretending to be an SMS sender, we should be able to see messages being generated by the code as we go along.</p>

<p>After the session, I&rsquo;m planning to mention <a href="https://github.com/ChrisMarinos/FSharpKoans">Chris Marinos' koans</a> and <a href="http://www.tryfsharp.org/">Try F#</a> (especially given that Rachel Reese is <a href="http://skillsmatter.com/podcast/scala/try-f-from-zero-to-data-science">running a session</a> at the tutorials for those who are going).</p>

<p>Please note that these are up here for comment and suggestions at this point &ndash; I&rsquo;ll be pushing up the actual Git repository and a screencast (I hope) after the event. The code is designed to be a prop for the talk rather than an independent resource &ndash; for that I&rsquo;d always point people to the koans/Try F# first.</p>

<p>So, show me the codez:</p>

<!--more-->


<h2>Tag &lsquo;1&rsquo;</h2>

<p>Nothing too exciting here :). This is just a place holder while giving the introduction, although I will also point out the lack of required boiler plate compared to C#.</p>

<p><code>fsharp
// Let's send an email!
</code></p>

<h2>Tag &lsquo;2&rsquo;</h2>

<p>Introduce the <code>open</code> keyword, <code>let</code> for value assignment, and give people a feel that they&rsquo;re not completely leaving their nice safe .net world behind.</p>

<p>``` fsharp
// Let&rsquo;s send an email!</p>

<p>open System.Net.Mail</p>

<p>// We only use the &lsquo;new&rsquo; keyword here because SmtpClient is disposable
let smtpClient = new SmtpClient(&ldquo;smtp.local&rdquo;)</p>

<p>// And given it&rsquo;s disposable, we should really dispose of it&hellip;
smtpClient.Dispose()
```</p>

<h2>Tag &lsquo;3&rsquo;</h2>

<p>Talk about functions, show parameter application, introduce the pipe operator.</p>

<p>Some discussion about type inference will probably happen here.</p>

<p>``` fsharp
open System.Net.Mail</p>

<p>let smtpClient = new SmtpClient(&ldquo;smtp.local&rdquo;)</p>

<p>// This is a function
let sendMessage client message =</p>

<pre><code>// We'd better do something here to actually
// send a message...
printfn "I haven't sent a mail message!"
()
</code></pre>

<p>sendMessage smtpClient &ldquo;My message&rdquo;</p>

<p>smtpClient.Dispose()</p>

<p>// And we&rsquo;ll add this so we can see the output
// before it disappears
System.Console.ReadLine() |> ignore
// This line would be the same as writing:
//
// ignore (System.Console.Readline())
//
// but you have to admit that this is a bit
// more readable
```</p>

<h2>Tag &lsquo;4&rsquo;</h2>

<p>Introduce the <code>use</code> keyword, show property assignment with <code>&lt;-</code>.</p>

<p>``` fsharp
open System.Net.Mail</p>

<p>let smtpClient = new SmtpClient(&ldquo;smtp.local&rdquo;)</p>

<p>let sendMessage client message =</p>

<pre><code>(* Because we used 'use' this will get
disposed at the end of the declaring
scope *)
use mailMessage = new MailMessage("me@example.com", "you@example.com")
(* This is have you assign a parameter *)
mailMessage.Subject &lt;- "Message subject"
mailMessage.Body &lt;- message
smtpClient.Send mailMessage
printfn "I've sent a mail message!"
</code></pre>

<p>sendMessage smtpClient &ldquo;My message&rdquo;</p>

<p>smtpClient.Dispose()
System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;5&rsquo;</h2>

<p>List syntax and introduce the <code>Seq</code> module. Example of currying.</p>

<p>``` fsharp
open System.Net.Mail</p>

<p>let smtpClient = new SmtpClient(&ldquo;smtp.local&rdquo;)</p>

<p>let sendMessage client message =</p>

<pre><code>use mailMessage = new MailMessage("me@example.com", "you@example.com")
mailMessage.Subject &lt;- "Message subject"
mailMessage.Body &lt;- message
smtpClient.Send mailMessage
printfn "I've sent a mail message!"
</code></pre>

<p>(<em> But really, what you want computers for
is doing the same thing lots of times&hellip; </em>)
let myMessages =</p>

<pre><code>[
    "My first message"
    "My second message"
    "My third and final message"
]
</code></pre>

<p>myMessages
|> Seq.iter (sendMessage smtpClient)
(<em> Let&rsquo;s have some vindaloo with that map </em>)</p>

<p>smtpClient.Dispose()
System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;6&rsquo;</h2>

<p>An async workflow. Turns out that <code>SmtpClient</code> is not as clean for that as you would hope &ndash; it&rsquo;s async send methods don&rsquo;t appear to be thread safe (wait, what?) and even the relatively recent looking <code>SendMailAsync</code> method returns a <code>Task</code> rather than a <code>Task&lt;'T&gt;</code>. Having said that, it shows that even in less than ideal circumstances, you can leverage the <code>async</code> stuff even when interfacing with older .net code from other languages.</p>

<p>``` fsharp
open System.Net.Mail</p>

<p>(<em> But really, what you want computers for
is doing the same thing lots of times&hellip;
at the same time! </em>)
let sendMessage message =</p>

<pre><code>async {
    // Move the client inside because...
    // have _you_ checked if it's thread safe?
    use smtpClient = new SmtpClient("smtp.local")
    use mailMessage = new MailMessage("me@example.com", "you@example.com")
    mailMessage.Subject &lt;- "Message subject"
    mailMessage.Body &lt;- message
    do!
        smtpClient.SendMailAsync(mailMessage)
        |&gt; Async.AwaitIAsyncResult
        |&gt; Async.Ignore
    printfn "I've sent a mail message!"
}
</code></pre>

<p>let myMessages =</p>

<pre><code>[
    "My first message"
    "My second message"
    "My third and final message"
]
</code></pre>

<p>myMessages
|> Seq.map sendMessage
|> Async.Parallel
|> Async.RunSynchronously
|> fun _ &ndash;> printfn &ldquo;Finished all sends!&rdquo;</p>

<p>System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;7&rsquo;</h2>

<p>Tuples! Showing both construction and deconstruction syntax. Also discuss that this is how we pass multiple parameters to methods on classes.</p>

<p>In the live coding for this one, I&rsquo;ll make sure to demonstrate adding and removing brackets in different places.</p>

<p>``` fsharp
open System.Net.Mail</p>

<p>let sendMessage messageDetails =</p>

<pre><code>async {
    let address, body = messageDetails
    use smtpClient = new SmtpClient("smtp.local")
    use mailMessage = new MailMessage("me@example.com", address)
    mailMessage.Subject &lt;- "Message subject"
    mailMessage.Body &lt;- body
    do!
        smtpClient.SendMailAsync(mailMessage)
        |&gt; Async.AwaitIAsyncResult
        |&gt; Async.Ignore
    printfn "I've sent a mail message!"
}
</code></pre>

<p>(<em> But we probably don&rsquo;t want to send all of these
to the same person. </em>)
let myMessages =</p>

<pre><code>[
    "first@example.com", "My first message"
    "secord@example.com", "My second message"
    "third@example.com", "My third and final message"
]
</code></pre>

<p>myMessages
|> Seq.map sendMessage
|> Async.Parallel
|> Async.RunSynchronously
|> fun _ &ndash;> printfn &ldquo;Finished all sends!&rdquo;</p>

<p>System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;8&rsquo;</h2>

<p>Record syntax.</p>

<p>``` fsharp
open System.Net.Mail</p>

<p>(<em> How about if I want to pass lots of different bits
of information in? </em>)
type messageDetails =</p>

<pre><code>{
    toAddress : string
    fromAddress : string
    body : string
}
</code></pre>

<p>let sendMessage messageDetails =</p>

<pre><code>async {
    use smtpClient = new SmtpClient("smtp.local")
    use mailMessage = 
        new MailMessage(
            messageDetails.fromAddress,
            messageDetails.toAddress)
    mailMessage.Subject &lt;- "Message subject"
    mailMessage.Body &lt;- messageDetails.body
    do!
        smtpClient.SendMailAsync(mailMessage)
        |&gt; Async.AwaitIAsyncResult
        |&gt; Async.Ignore
    printfn "I've sent a mail message!"
}
</code></pre>

<p>let myMessages =</p>

<pre><code>[
    { toAddress = "first@example.com"; fromAddress = "official@example.com"; body = "My first message" }
    { toAddress = "second@example.com"; fromAddress = "personal@example.com"; body = "My second message" }
    { toAddress = "first@example.com"; fromAddress = "official@example.com"; body = "My third message" }
]
</code></pre>

<p>myMessages
|> Seq.map sendMessage
|> Async.Parallel
|> Async.RunSynchronously
|> fun _ &ndash;> printfn &ldquo;Finished all sends!&rdquo;</p>

<p>System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;9&rsquo;</h2>

<p>Use discriminated unions for modeling business inputs. In this case, building a MessageDetails class that can contain the details of either an email or an SMS send request.</p>

<p>Also has a 2nd, maybe slightly more idiomatic implementation of an async workflow.</p>

<p>I&rsquo;m hoping to get at least this far in the session. The rest of it would be nice, but if we get here then I&rsquo;ll be happy I&rsquo;ve covered at least the basics.</p>

<p>``` fsharp
open System.IO
open System.Net
open System.Net.Mail</p>

<p>(<em> But some people have given us mobile
numbers rather than email addresses </em>)
type EmailDetails =</p>

<pre><code>{
    toAddress : string
    fromAddress : string
    body : string
}
</code></pre>

<p>type SmsDetails =</p>

<pre><code>{
    toNumber : string
    fromNumber : string
    message : string
}
</code></pre>

<p>type MessageDetails =</p>

<pre><code>| Email of EmailDetails
| Sms of SmsDetails
</code></pre>

<p>let sendEmail messageDetails =</p>

<pre><code>async {
    use smtpClient = new SmtpClient("smtp.local")
    use mailMessage = 
        new MailMessage(
            messageDetails.fromAddress,
            messageDetails.toAddress)
    mailMessage.Subject &lt;- "Message subject"
    mailMessage.Body &lt;- messageDetails.body
    do!
        smtpClient.SendMailAsync(mailMessage)
        |&gt; Async.AwaitIAsyncResult
        |&gt; Async.Ignore
    printfn "I've sent a mail message!"
}
</code></pre>

<p>let sendSms messageDetails =</p>

<pre><code>async {
    let http = HttpWebRequest.Create("http://sms.local") :?&gt; HttpWebRequest
    http.Method &lt;- "POST"
    let messagePayload =
        sprintf
            "To: %s\nFrom: %s\nMessage: %s"
            messageDetails.toNumber
            messageDetails.fromNumber
            messageDetails.message
    using 
        (http.GetRequestStream())
        (fun stream -&gt; 
            use sw = new StreamWriter(stream)
            sw.Write(messagePayload))
    let! response = http.GetResponseAsync() |&gt; Async.AwaitTask
    if (response :?&gt; HttpWebResponse).StatusCode &lt;&gt; HttpStatusCode.OK then
        failwith "Http request failed!"
    printfn "I've sent an SMS!"
}
</code></pre>

<p>let sendMessage message =</p>

<pre><code>match message with
| Email details -&gt; sendEmail details
| Sms details -&gt; sendSms details
</code></pre>

<p>let myMessages =</p>

<pre><code>[
    Email { toAddress = "first@example.com"; fromAddress = "official@example.com"; body = "My first message" }
    Email { toAddress = "second@example.com"; fromAddress = "personal@example.com"; body = "My second message" }
    Email { toAddress = "first@example.com"; fromAddress = "official@example.com"; body = "My third message" }
    Sms { toNumber = "+447777123123"; fromNumber = "+447888321321"; message = "Hello by sms" }
    Sms { toNumber = "+447777123124"; fromNumber = "+447888321321"; message = "Hello by sms x2" }
    Sms { toNumber = "+447777123123"; fromNumber = "+447888321321"; message = "Hello by sms x3" }
]
</code></pre>

<p>myMessages
|> Seq.map sendMessage
|> Async.Parallel
|> Async.RunSynchronously
|> fun _ &ndash;> printfn &ldquo;Finished all sends!&rdquo;</p>

<p>System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;10&rsquo;</h2>

<p>Validation with Active patterns.</p>

<p>``` fsharp
open System.IO
open System.Net
open System.Net.Mail</p>

<p>type EmailDetails =</p>

<pre><code>{
    toAddress : string
    fromAddress : string
    body : string
}
</code></pre>

<p>type SmsDetails =</p>

<pre><code>{
    toNumber : string
    fromNumber : string
    message : string
}
</code></pre>

<p>type MessageDetails =</p>

<pre><code>| Email of EmailDetails
| Sms of SmsDetails
</code></pre>

<p>(* But what if some people have given us invalid data?</p>

<p>Our SMS sender requires full numbers with national
codes &ndash; let&rsquo;s add some validation! *)
let (|ValidSmsRequest|InvalidSmsRequest|) details =</p>

<pre><code>// Hmm. Bananas. My favourite.
let regex = System.Text.RegularExpressions.Regex(@"^\+\d\d")
if regex.IsMatch(details.toNumber) &amp;&amp; regex.IsMatch(details.fromNumber) then
    ValidSmsRequest details
else
    InvalidSmsRequest "You must include the +xx country prefix on mobile numbers."
</code></pre>

<p>let sendEmail messageDetails =</p>

<pre><code>async {
    use smtpClient = new SmtpClient("smtp.local")
    use mailMessage = 
        new MailMessage(
            messageDetails.fromAddress,
            messageDetails.toAddress)
    mailMessage.Subject &lt;- "Message subject"
    mailMessage.Body &lt;- messageDetails.body
    do!
        smtpClient.SendMailAsync(mailMessage)
        |&gt; Async.AwaitIAsyncResult
        |&gt; Async.Ignore
    printfn "I've sent a mail message!"
}
</code></pre>

<p>(* We&rsquo;ve moved the SMS post logic into this method
without change &ndash; no validation here.</p>

<p>We&rsquo;ve marked it private so no one else can call it
by mistake *)
let private postSms messageDetails =</p>

<pre><code>async {
    let http = HttpWebRequest.Create("http://sms.local") :?&gt; HttpWebRequest
    http.Method &lt;- "POST"
    let messagePayload =
        sprintf
            "To: %s\nFrom: %s\nMessage: %s"
            messageDetails.toNumber
            messageDetails.fromNumber
            messageDetails.message
    using 
        (http.GetRequestStream())
        (fun stream -&gt; 
            use sw = new StreamWriter(stream)
            sw.Write(messagePayload))
    let! response = http.GetResponseAsync() |&gt; Async.AwaitTask
    if (response :?&gt; HttpWebResponse).StatusCode &lt;&gt; HttpStatusCode.OK then
        failwith "Http request failed!"
    printfn "I've sent an SMS!"
}
</code></pre>

<p>(<em> And this is where we do our validation </em>)
let sendSms messageDetails =</p>

<pre><code>match messageDetails with
| ValidSmsRequest details -&gt; postSms details
| InvalidSmsRequest error -&gt; async { printfn "Sms sending error: %s" error }
</code></pre>

<p>let sendMessage message =</p>

<pre><code>match message with
| Email details -&gt; sendEmail details
| Sms details -&gt; sendSms details
</code></pre>

<p>let myMessages =</p>

<pre><code>[
    Email { toAddress = "first@example.com"; fromAddress = "official@example.com"; body = "My first message" }
    Email { toAddress = "second@example.com"; fromAddress = "personal@example.com"; body = "My second message" }
    Email { toAddress = "first@example.com"; fromAddress = "official@example.com"; body = "My third message" }
    Sms { toNumber = "+447777123123"; fromNumber = "+447888321321"; message = "Hello by sms" }
    Sms { toNumber = "+447777123124"; fromNumber = "+447888321321"; message = "Hello by sms x2" }
    Sms { toNumber = "+447777123123"; fromNumber = "+447888321321"; message = "Hello by sms x3" }
    Sms { toNumber = "447777123123"; fromNumber = "+447888321321"; message = "I won't be sent!" }
    Sms { toNumber = "+447777123123"; fromNumber = "+ab7888321321"; message = "Neither will I!" }
    Sms { toNumber = "Bob"; fromNumber = "+ab7888321321"; message = "..and I definitely won't!" }
]
</code></pre>

<p>myMessages
|> Seq.map sendMessage
|> Async.Parallel
|> Async.RunSynchronously
|> fun _ &ndash;> printfn &ldquo;Finished all sends!&rdquo;</p>

<p>System.Console.ReadLine() |> ignore
```</p>

<h2>Tag &lsquo;11&rsquo;</h2>

<p>The extra credit section! I very much doubt I&rsquo;ll get this far in a one hour session, but if I do this is just some fun playing with type providers. Also covers randomness such as:</p>

<ul>
<li>generating infinite sequences using <code>seq</code> expressions</li>
<li>double back tick identifiers</li>
<li>pattern matching with guards</li>
<li>a bit more of a workout of the <code>Seq</code> module</li>
<li>we can have a lot of discussion of lazy evaluation, because this code is just insanely broken without it</li>
</ul>


<p>``` fsharp
open System
open System.IO
open System.Net
open System.Net.Mail
open System.Text.RegularExpressions</p>

<p>type EmailDetails =</p>

<pre><code>{
    toAddress : string
    fromAddress : string
    body : string
}
</code></pre>

<p>type SmsDetails =</p>

<pre><code>{
    toNumber : string
    fromNumber : string
    message : string
}
</code></pre>

<p>type MessageDetails =</p>

<pre><code>| Email of EmailDetails
| Sms of SmsDetails
</code></pre>

<p>let (|ValidSmsRequest|InvalidSmsRequest|) details =</p>

<pre><code>let regex = Regex(@"^\+\d\d")
if regex.IsMatch(details.toNumber) &amp;&amp; regex.IsMatch(details.fromNumber) then
    ValidSmsRequest details
else
    InvalidSmsRequest "You must include the +xx country prefix on mobile numbers."
</code></pre>

<p>let sendEmail messageDetails =</p>

<pre><code>async {
    use smtpClient = new SmtpClient("smtp.local")
    use mailMessage = 
        new MailMessage(
            messageDetails.fromAddress,
            messageDetails.toAddress)
    mailMessage.Subject &lt;- "Message subject"
    mailMessage.Body &lt;- messageDetails.body
    do!
        smtpClient.SendMailAsync(mailMessage)
        |&gt; Async.AwaitIAsyncResult
        |&gt; Async.Ignore
    printfn "I've sent a mail message!"
}
</code></pre>

<p>let private postSms messageDetails =</p>

<pre><code>async {
    let http = HttpWebRequest.Create("http://sms.local") :?&gt; HttpWebRequest
    http.Method &lt;- "POST"
    let messagePayload =
        sprintf
            "To: %s\nFrom: %s\nMessage: %s"
            messageDetails.toNumber
            messageDetails.fromNumber
            messageDetails.message
    using 
        (http.GetRequestStream())
        (fun stream -&gt; 
            use sw = new StreamWriter(stream)
            sw.Write(messagePayload))
    let! response = http.GetResponseAsync() |&gt; Async.AwaitTask
    if (response :?&gt; HttpWebResponse).StatusCode &lt;&gt; HttpStatusCode.OK then
        failwith "Http request failed!"
    printfn "I've sent an SMS!"
}
</code></pre>

<p>let sendSms messageDetails =</p>

<pre><code>match messageDetails with
| ValidSmsRequest details -&gt; postSms details
| InvalidSmsRequest error -&gt; async { printfn "Sms sending error: %s" error }
</code></pre>

<p>let sendMessage message =</p>

<pre><code>match message with
| Email details -&gt; sendEmail details
| Sms details -&gt; sendSms details
</code></pre>

<p>(* And now for something completely different&hellip;</p>

<p>Let&rsquo;s send a bunch of actors and celebrities a selection
of astronomical data. Because, you know. Why not?</p>

<p>If you&rsquo;re running this code at home, you&rsquo;ll need
to install the nuget package from the packages.config
file *)
open FSharp.Data
let FreebaseKey =</p>

<pre><code>let rec getKey (dir : DirectoryInfo) =
    match dir.EnumerateFiles("freebase.key") with
    | files when Seq.isEmpty files -&gt; getKey (dir.Parent)
    | files -&gt; (Seq.head files).OpenText().ReadToEnd().Trim()
let dir = DirectoryInfo(Directory.GetCurrentDirectory())
getKey dir
</code></pre>

<p>type FreebaseProvider = FreebaseDataProvider&lt;Key=&ldquo;api key goes here&rdquo;></p>

<p>let freebase = FreebaseProvider.GetDataContext()</p>

<p>(* If you don&rsquo;t have an api key you can delete lines
88 to the end of this comment, and uncomment the line below.</p>

<p>It will limit how many times you can run the program
before it starts throwing authentication errors,
though &ndash; there&rsquo;s a fairly strict rate limit. *)
//let freebase = FreebaseData.GetDataContext()</p>

<p>let actors =</p>

<pre><code>freebase.``Arts and Entertainment``.Film.``Film actors``
|&gt; Seq.filter (fun a -&gt; not &lt;| Seq.isEmpty a.``Film performances``)
(* You get a (virtual) cookie if you can work out
why I've added the filter below *)
|&gt; Seq.filter (fun a -&gt; 
    (a.``Film performances`` |&gt; Seq.head)
        .Film.Name.[0 .. 0]
    |&gt; Regex("[a-zA-Z]").IsMatch)
|&gt; Seq.filter (fun a -&gt; not &lt;| Seq.isEmpty a.``Country of nationality``)
|&gt; Seq.take 20
</code></pre>

<p>let encode (str : string) =</p>

<pre><code>let clean = Regex("\W")
clean.Replace(str, "-")
</code></pre>

<p>let emailAddresses =</p>

<pre><code>seq { for actor in actors -&gt; 
        let name = actor.Name |&gt; encode
        let domain =
            (actor.``Film performances`` |&gt; Seq.head).Film.Name
            |&gt; encode
        let countryCode =
            match (actor.``Country of nationality`` |&gt; Seq.head).``ISO Alpha 2`` with
            | alpha when Seq.isEmpty alpha -&gt;
                "com"
            | alpha when (Seq.head alpha).ToLower() = "us" -&gt;
                "com"
            | alpha -&gt; sprintf "co.%s" &lt;| (Seq.head alpha).ToLower()
        sprintf "%s@%s.%s"
            name
            domain
            countryCode }
</code></pre>

<p>(<em> We&rsquo;re going to need 20 planets for our 20 celebrities,
so we&rsquo;ll repeat the planets as many times as we need </em>)
let planets =</p>

<pre><code>seq {
    while true do
        yield! freebase.``Science and Technology``.Astronomy.Planets
}
</code></pre>

<p>let messages =</p>

<pre><code>seq { for planet in planets -&gt;
        sprintf """Hi there!
</code></pre>

<p>We thought you might be interested to know that:</p>

<p>The planet %s has:
%d moons!
An average orbital velocity of %Am/s!</p>

<p>And is also known as:
%s</p>

<p>Regards,</p>

<p>Astro</p>

<pre><code>            """
            planet.Name
            (planet.``Orbited by`` |&gt; Seq.length)
            planet.``Average Orbital Speed``
            (planet.``Also known as`` |&gt; String.concat ", ") }
</code></pre>

<p>let combineAddressAndMessage (address, message) =</p>

<pre><code>Email {
    toAddress = address
    fromAddress = "astro@random.org"
    body = message
}
</code></pre>

<p>let myMessages =</p>

<pre><code>Seq.zip emailAddresses messages
|&gt; Seq.map combineAddressAndMessage
</code></pre>

<p>myMessages
|> Seq.map sendMessage
|> Async.Parallel
|> Async.RunSynchronously
|> fun _ &ndash;> printfn &ldquo;Finished all sends!&rdquo;</p>

<p>System.Console.ReadLine() |> ignore
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Teaching F# to C# Devs]]></title>
    <link href="http://blog.mavnn.co.uk/teaching-f-number-to-c-number-devs/"/>
    <updated>2013-09-17T11:12:00+01:00</updated>
    <id>http://blog.mavnn.co.uk/teaching-f-number-to-c-number-devs</id>
    <content type="html"><![CDATA[<p>So, in a fit of enthusiasm my boss bought 15 tickets to the <a href="" title="http://skillsmatter.com/event/scala/progressive-f-tutorials-2013">London Progressive F# Tutorials</a> when he saw the early birds pricing (did I mention it&rsquo;s nice working here?). Several of the people who have been assigned tickets have asked to go largely because they are new to F#, so I&rsquo;ve been asked to put together a starter session to teach them the basics. I&rsquo;ve tried this <a href="" title="http://blog.mavnn.co.uk/an-introduction-to-f-screencast-and-pdf-slide">once before</a> and it was a fairly successful session (F# was adopted as a official supported language in the company partly due to feedback following it). But it was still pretty rough around the edges, and as normal with these things, you always want to do them better the next time round&hellip;</p>

<p>So, with a target audience of curious, experienced C# devs I&rsquo;m wondering about the best approach. The initial session needs to fit in an hour, although I can do individual follow ups afterwards.</p>

<p>My current thinking is to take a block of C# code (smtp sender?) that is fairly straight forward but &lsquo;production ready&rsquo; in the sense that it includes error handling, logging, etc. Then do a straight re-write in F# live coding. And then start refactoring to more idiomatic F# as we go along.</p>

<p>Features I feel would be important to cover:</p>

<ul>
<li>Basic syntax (let, functions, if &hellip; then, etc)</li>
<li>Common idioms (|>, Seq.map)</li>
<li>At least one computational expression (probably an error handling one; simpler than async in some ways)</li>
<li>Several examples of using the match statements</li>
<li>&hellip;which probably means at least one DU, possibly for error handling</li>
<li>Records and { &hellip; with &hellip; } expressions</li>
</ul>


<p>I&rsquo;ve got a week or two to prepare, so what I&rsquo;m really hoping for at this point is suggestions and ideas from people for how to improve this as a session idea, things that threw you when you first started writing F# you think should be covered, whether you think this is a stupid idea for a session from the concept up, etc. Once the session is completed I&rsquo;ll be posting the slides and hopefully a screen cast of it as I did last time for use by <a href="" title="http://fsharp.org">fsharp.org</a>.</p>

<p>Suggestions on the piece of C# code to translate would also be appreciated &ndash; either in terms of ideas of the type of code, or actual open source code that would serve as a code starting point.</p>
]]></content>
  </entry>
  
</feed>
