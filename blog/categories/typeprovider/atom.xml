<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: typeprovider | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/typeprovider/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2014-06-25T21:33:23+01:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Type safe printf via Type Providers]]></title>
    <link href="http://blog.mavnn.co.uk/type-safe-printf-via-type-providers/"/>
    <updated>2014-05-06T15:33:15+01:00</updated>
    <id>http://blog.mavnn.co.uk/type-safe-printf-via-type-providers</id>
    <content type="html"><![CDATA[<p><a href="http://twitter.com/puffnfresh">Brian McKenna</a> posted an interesting <a href="http://www.youtube.com/watch?v=fVBck2Zngjo">video</a> and <a href="https://gist.github.com/puffnfresh/11202637">gist</a> on implementing a type safe printf in Idris with dependent types.</p>

<p>This led me down a nice little rabbit hole wondering if something similar could be achieved with an F# type provider.</p>

<p>With a <a href="http://stackoverflow.com/questions/23375469/how-can-i-build-an-arbitary-curried-function-in-an-f-type-provider">bit of help from Tomas</a> the final solution turned out to be surprisingly nice, although not quite so clean as the Idris original.</p>

<!-- more -->


<p>Taking the format string and parsing it looks very similar to the Idris version, what with the common ML history of the two languages:</p>

<p>```fsharp
type Format =</p>

<pre><code>| FString of Format
| FInt of Format
| Other of char * Format
| End
</code></pre>

<p>let parseFormatString str =</p>

<pre><code>let rec parseFormat chars =
    match chars with
    | '%'::'d'::t -&gt; FInt (parseFormat t)
    | '%'::'s'::t -&gt; FString (parseFormat t)
    | c::t -&gt; Other (c, parseFormat t)
    | [] -&gt; End
parseFormat (Seq.toList str)
</code></pre>

<p>```</p>

<p>This might not be the most efficient or flexible parsing method, but that&rsquo;s not really the point of the current exercise and it&rsquo;s very clear what it&rsquo;s doing.</p>

<p>Next, we want to create a <a href="http://msdn.microsoft.com/en-us/library/dd233212.aspx">quotation</a> that represents a curried function based on our format type. This is where I needed Tomas' help &ndash; it turns out there isn&rsquo;t any easy way to do this with the <code>&lt;@@ ... @@&gt;</code> syntax I&rsquo;ve usually used to build quotations for type providers.</p>

<p>Tomas reminded me that the <code>Microsoft.FSharp.Quotations</code> namespace gives direct access to the underlying classes that represent the expression tree of the quotation. This allows us to build an expression tree recusively; check out <a href="http://stackoverflow.com/a/23375794/68457">Tomas' explanation</a>  of the technique for more details of how it works.</p>

<p>```fsharp
open System.Reflection
open Microsoft.FSharp.Quotations</p>

<p>(<em> &hellip; </em>)</p>

<p>let rec invoker printers format =</p>

<pre><code>match format with
| End -&gt;
    let arr = Expr.NewArray(typeof&lt;string&gt;, List.rev printers)
    let conc = typeof&lt;string&gt;.GetMethod("Concat", [|typeof&lt;string[]&gt;|])
    Expr.Call(conc, [arr])
| Other (c, t) -&gt;
    invoker (&lt;@@ string&lt;char&gt; c @@&gt; :: printers) t
| FInt t -&gt;
    let v = Var("v", typeof&lt;int&gt;)
    let printer = &lt;@@ string&lt;int&gt; (%%(Expr.Var v)) @@&gt;
    Expr.Lambda(v, invoker (printer::printers) t)
| FString t -&gt;
    let v = Var("v", typeof&lt;string&gt;)
    let printer = &lt;@@ %%(Expr.Var v):string @@&gt;
    Expr.Lambda(v, invoker (printer::printers) t)
</code></pre>

<p>```</p>

<p>That&rsquo;s the hard stuff out of the way! Now we just have some type provider boiler plate. We&rsquo;re going to provide a type provider named <code>TPrint</code> which takes a single parameter (our format string). Once the parameter is supplied, we provide a single static property which is an FSharpFunc type which matches the signature required by the format string.</p>

<p>```fsharp
open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices</p>

<p>(<em> &hellip; </em>)</p>

<p>let toMethod format =</p>

<pre><code>let invokeCode =
    invoker [] format
let invokeType = invokeCode.Type
ProvidedProperty("show", invokeType, IsStatic = true, GetterCode = fun _ -&gt; invokeCode)
</code></pre>

<p>[<TypeProvider>]
type TPrintProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "TypeSet.Provided"
let asm = Assembly.GetExecutingAssembly()

let tPrintProvider = ProvidedTypeDefinition(asm, ns, "TPrint", Some(typeof&lt;obj&gt;))

let parameters = [ProvidedStaticParameter("FormatString", typeof&lt;string&gt;)]

do tPrintProvider.DefineStaticParameters(parameters, fun typeName args -&gt;
    let formatString = args.[0] :?&gt; string

    let provider = ProvidedTypeDefinition(asm, ns, typeName, Some(typeof&lt;obj&gt;))
    provider.HideObjectMethods &lt;- true

    formatString |&gt; parseFormatString |&gt; toMethod |&gt; provider.AddMember

    provider
    )

do
    this.AddNamespace(ns, [tPrintProvider])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>So, put it all together and you get a type provider which allows you to do this:</p>

<p>```fsharp
TPrint&lt;&ldquo;A %s string! %s %d&rdquo;>.show &ldquo;hello&rdquo; &ldquo;world&rdquo; 32
// val it : string = &ldquo;A hello string! world 32&rdquo;</p>

<p>TPrint&lt;&ldquo;Number one: %d! Number two: %d! A string: %s!&rdquo;>.show 1 2 &ldquo;My string!&rdquo;
// val it : string = &ldquo;Number one: 1! Number two: 2! A string: My string!!&rdquo;
```</p>

<p>So; nothing there that the built in <code>printf</code> doesn&rsquo;t already do for you. But, this does start opening up some options for providing much more idiomatic F# style APIs then I&rsquo;ve really seen so far from Type Providers, which tend to provide very OO style interfaces. Should be some interesting ideas in there to explore!</p>

<p>Full code can be found <a href="https://github.com/mavnn/TypeSet">at Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Providers From the First Floor]]></title>
    <link href="http://blog.mavnn.co.uk/type-providers-from-the-first-floor/"/>
    <updated>2014-03-19T21:06:05+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-providers-from-the-first-floor</id>
    <content type="html"><![CDATA[<p><em>This post follows on directly from my previous post <a href="http://blog.mavnn.co.uk/type-providers-from-the-ground-up/">Type Providers from the Ground Up</a>. I highly recommend that you read that first, and check out the relevant example code from GitHub.</em></p>

<p><em>It&rsquo;s also a bit epic&hellip; grab yourself a coffee before you start.</em></p>

<p>So we have a working type provider now. Unfortunately, we&rsquo;re missing out on at least two major features that your new type provider will almost certainly want to make use of.</p>

<p>The first is that in our example, we&rsquo;re reading the metadata that defines our types from a fixed file location. In almost every real life case, you will want to be able to parametrize your provider to specify where this instance is getting it&rsquo;s metadata from.</p>

<p>The second is that in many cases getting the metadata will be slow, and the number of types available to generate may be very large. In these situations, you really want to be able to only generate the types that are required as they are requested, especially because this will reduce the size of the final compiled output. This is particularly important for type providers that read from large network based data sources like the Freebase provider.</p>

<p>We&rsquo;ll take the second first, because it&rsquo;s easy &ndash; and we like easy&hellip;</p>

<!-- more -->


<h2>Generating types on demand</h2>

<p>This is in many ways one of the features that makes type providers uniquely powerful compared to code generation. Because the types are being requested by the compiler as needed, type providers can give meaningful access to literally infinite type hierarchies.</p>

<p>So, does all this power come with great cost and complexity? Not really, no.</p>

<p>Let&rsquo;s take the our node creation function, with some bits snipped out:</p>

<p>``` fsharp
let createNodeType id (node : Node) =</p>

<pre><code>let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
// ... snip constructors

let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
outputs.AddMember(outputCtor)
outputs.HideObjectMethods &lt;- true

let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
inputs.AddMember(inputCtor)
inputs.HideObjectMethods &lt;- true
addPorts inputs outputs node.Ports

// Add the inputs and outputs types of nested types under the Node type
nodeType.AddMembers([inputs;outputs])

// Now add some instance properties to expose them on a node instance.
let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)

nodeType.AddMembers([inputPorts;outputPorts])

nodeType
</code></pre>

<p>```</p>

<p>To make the ports deferred, we simply change the <code>AddMembers</code> call at the end to <code>AddMembersDelayed</code> and wrap the creation of the array in a function that takes <code>unit</code>.</p>

<p>It ends up looking like this:</p>

<p>``` fsharp
let createNodeType id (node : Node) =</p>

<pre><code>let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
// ... snip out the constructor again...

let addInputOutput () =
    let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
    let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    outputs.AddMember(outputCtor)
    outputs.HideObjectMethods &lt;- true

    let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
    let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    inputs.AddMember(inputCtor)
    inputs.HideObjectMethods &lt;- true
    addPorts inputs outputs node.Ports

    // Add the inputs and outputs types of nested types under the Node type
    nodeType.AddMembers([inputs;outputs])

    // Now add some instance properties to expose them on a node instance.
    let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                        GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                        GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
    [inputPorts;outputPorts]

nodeType.AddMembersDelayed(addInputOutput)

nodeType
</code></pre>

<p>```</p>

<p>Now the input and output ports of a node will only be generated the first time that the compiler needs them available. If you don&rsquo;t use a particular node in your program, then the compiler will never generate it&rsquo;s ports, and they will not be including in your final build output.</p>

<p>Of course, in this case we&rsquo;re pre-loading all of our metadata anyway, but hopefully this gives you an idea.</p>

<h2>Parametrizing the Data Source</h2>

<p>Currently, we&rsquo;re reading the json that&rsquo;s generating our types like this:</p>

<p>``` fsharp
let private nodes = JsonConvert.DeserializeObject&lt;seq<Node>>(IO.File.ReadAllText(@&ldquo;c:\Temp\Graph.json&rdquo;))</p>

<pre><code>                |&gt; Seq.map (fun n -&gt; n.Id.UniqueId.ToString(), n)
                |&gt; Map.ofSeq
</code></pre>

<p>```</p>

<p>Lovely.</p>

<p>Now, you&rsquo;ll probably of noticed from playing with other type providers that they allow you to do funky things like:</p>

<p><code>fsharp
type myThing = FancyProvider&lt;"configStringThing"&gt;
</code></p>

<p>This is actually one of the things that kept me going for longest in writing my first type provider, and I have to admit I&rsquo;m still not fully certain why it&rsquo;s done this way.</p>

<p>At the moment, if we strip out all of the type creation logic, our type provider looks like this:</p>

<p>``` fsharp
[<TypeProvider>]
type MavnnProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Mavnn.Blog.TypeProvider.Provided"
let asm = Assembly.GetExecutingAssembly()

// ... massive snip

let createNodeType id (node : Node) =
    let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
    // ... more snipped here ...

let createTypes () =
    nodes |&gt; Map.map createNodeType |&gt; Map.toList |&gt; List.map (fun (k, v) -&gt; v)

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>```</p>

<p>As you can see, we add the types to the namespace during the initialization of the MavnnProvider type.</p>

<p>This is no good if we want to add parameters &ndash; after all, we don&rsquo;t know what they are yet. And the same provider might be used several times with different parameters. Also, when we create our provided type (<code>let nodeType = ...</code>) we&rsquo;re putting into a fixed space in the assemblies namespace. Again, this is no good if we want to be able to use more than one of our provider with different parameters.</p>

<p>To get around these issues, we create a &ldquo;parent&rdquo; provided type within the type provider which will host an isolated namespace for each parametrized provider instance:</p>

<p><code>fsharp
let mavnnProvider = ProvidedTypeDefinition(asm, ns, "MavnnProvider", Some(typeof&lt;obj&gt;))
</code></p>

<p>Then we define some &lsquo;static parameters&rsquo; and call the <code>DefineStaticParameters</code> method on the parent provided type, still within the construction of the type provider:</p>

<p>``` fsharp
let parameters = [ProvidedStaticParameter(&ldquo;PathToJson&rdquo;, typeof<string>)]</p>

<p>do mavnnProvider.DefineStaticParameters(parameters, fun typeName args &ndash;></p>

<pre><code>let pathToJson = args.[0] :?&gt; string
// ... do all our type creation logic in here ...
)
</code></pre>

<p>```</p>

<p>&hellip; and then we amend the base TypeProvider type so that the only type it adds to the namespace is the <code>mavnnProvider</code> type:</p>

<p><code>fsharp
// was: do this.AddNamespace(ns, createTypes())
do this.AddNamespace(ns, [mavnnProvider])
</code></p>

<p>At this point, we&rsquo;re creating an independent environment for each instance of the type provider. Unfortunately we need to make several changes to the type creation logic to make this work.</p>

<p>Firstly, we loaded quite a few things globally in the original version &ndash; things like the node list now need to happen within the context of <code>DefineStaticParameters</code>. You&rsquo;ll also notice that <code>DefineStaticParameters</code> gets given a <code>typeName</code> as one of the parameters on the callback. This is a compiler generated type name for this instance of the which is passed in when a parameterised provider is defined, and the callback method needs to return a provided type with that name.</p>

<p>So, for example:</p>

<p>``` fsharp
// In a script file called: Script.fsx</p>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Newtonsoft.Json.dll&rdquo;</h1>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Mavnn.Blog.TypeProvider.dll&rdquo;</h1>

<p>open System
open Mavnn.Blog.TypeProvider.Provided</p>

<p>type thisOne = MavnnProvider&lt;&ldquo;c:\Temp\Graph.json&rdquo;>
```</p>

<p>Will pass in <code>"Script.thisOne" [| box "c:\Temp\Graph.json" |]</code> to the callback method, and expect to get back a provided type. So the first thing we&rsquo;ll do in the callback is create the new type which we will then add all of our nodes to.</p>

<p>Keeping all of the amendments separate in your head just gets harder and harder at this point, so let&rsquo;s just few the final annotated method and get an overview of the final result. It&rsquo;s long, but hopefully worth it!</p>

<p>``` fsharp
do mavnnProvider.DefineStaticParameters(parameters, fun typeName args &ndash;></p>

<pre><code>// All args arrive as type obj - you'll need to cast them back to what
// you specified for actual usage
let pathToJson = args.[0] :?&gt; string

// This is the type that is going to host all the other types
// and get returned at the end of the method
let provider = ProvidedTypeDefinition(asm, ns, typeName, Some typeof&lt;obj&gt;, HideObjectMethods = true)

// ---------- set up ----------
// This section contains all the methods that where previously global
// to the module, but now need to be constrained to this instance of
// the provider
let nodes = JsonConvert.DeserializeObject&lt;seq&lt;Node&gt;&gt;(IO.File.ReadAllText(pathToJson))
            |&gt; Seq.map (fun n -&gt; n.Id.UniqueId.ToString(), n)
            |&gt; Map.ofSeq

let GetNode id =
    nodes.[id]

let ports =
    nodes
    |&gt; Map.toSeq
    |&gt; Seq.map (fun (_, node) -&gt; node.Ports)
    |&gt; Seq.concat
    |&gt; Seq.map (fun p -&gt; p.Id.UniqueId.ToString(), p)
    |&gt; Map.ofSeq

let GetPort id =
    ports.[id]

let addInputPort (inputs : ProvidedTypeDefinition) (port : Port) =
    let port = ProvidedProperty(
                    port.Id.Name, 
                    typeof&lt;InputPort&gt;, 
                    GetterCode = fun args -&gt; 
                        let id = port.Id.UniqueId.ToString()
                        &lt;@@ GetPort id |&gt; InputPort @@&gt;)
    inputs.AddMember(port)

let addOutputPort (outputs : ProvidedTypeDefinition) (port : Port) =
    let port = ProvidedProperty(
                    port.Id.Name, 
                    typeof&lt;OutputPort&gt;, 
                    GetterCode = fun args -&gt; 
                        let id = port.Id.UniqueId.ToString()
                        &lt;@@ GetPort id |&gt; OutputPort @@&gt;)
    outputs.AddMember(port)

let addPorts inputs outputs (portList : seq&lt;Port&gt;) =
    portList
    |&gt; Seq.iter (fun port -&gt; 
                    match port.Type with
                    | "input" -&gt; addInputPort inputs port
                    | "output" -&gt; addOutputPort outputs port
                    | _ -&gt; failwithf "Unknown port type for port %s/%s" port.Id.Name (port.Id.UniqueId.ToString()))


// ---------- end set up ----------

let createNodeType id (node : Node) =
    let nodeType = ProvidedTypeDefinition(node.Id.Name, Some typeof&lt;nodeInstance&gt;)
    let ctor = ProvidedConstructor(
                [
                    ProvidedParameter("Name", typeof&lt;string&gt;)
                    ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
                    ProvidedParameter("Config", typeof&lt;string&gt;)
                ],
                InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
    nodeType.AddMember(ctor)

    let addInputOutput () =
        let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
        let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        outputs.AddMember(outputCtor)
        outputs.HideObjectMethods &lt;- true

        let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
        let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        inputs.AddMember(inputCtor)
        inputs.HideObjectMethods &lt;- true
        addPorts inputs outputs node.Ports

        // Add the inputs and outputs types of nested types under the Node type
        nodeType.AddMembers([inputs;outputs])

        // Now add some instance properties to expose them on a node instance.
        let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                            GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                            GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
        [inputPorts;outputPorts]

    nodeType.AddMembersDelayed(addInputOutput)

    provider.AddMember(nodeType)

// And this is where we actually interate through the loaded nodes,
// using createNodeType to add each one to the parent provider type.
let createTypes pathToJson =
    nodes |&gt; Map.map createNodeType |&gt; Map.toList |&gt; List.iter (fun (k, v) -&gt; v)

createTypes pathToJson

// And then we return our fully populated provider.
provider)
</code></pre>

<p>```</p>

<p>Let&rsquo;s just check this all still works&hellip;</p>

<p><img src="/images/tp-oh-no.png" alt="Losing!" /></p>

<p>Ah. No. No, it doesn&rsquo;t.</p>

<p>This is where type provider development can get a bit more frustrating. The compiler allows the code above to compile &ndash; it&rsquo;s completely valid F# that looks like it should do the right thing. But now, our quotations are doing something different; and evaluating them at runtime fails.</p>

<p>Let&rsquo;s take a look at the constructor that&rsquo;s throwing the error:</p>

<p><code>fsharp
InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
</code></p>

<p>Previously, <code>GetNode</code> was referring to a public method in the type provider assembly. But if you look above now, it&rsquo;s actually a private method with in the type provider class that we are closing over. But our generated type is in the assembly that&rsquo;s being created, not in the type provider assembly so <em>it can&rsquo;t access this method</em>. Even if it was in the same assembly, this method is actually private to the class, so we&rsquo;d still be stuck. Bearing that in mind, let&rsquo;s try a
rewrite to see if we can get all of our quotations into better shape.</p>

<p>What are our options? Well, we can either capture all private state in types that the quotation evaluator knows about (<code>string</code>, mostly!). Or we can make sure that any methods called in the quotations are public.</p>

<p>The first gives us a cleaner interface for the outside world (the <code>GetNode</code> method should never really have been public in the first place), so let&rsquo;s give it a try.</p>

<p>In our first version of the type provider, we were using the <code>GetNode</code> method to avoid having to embed the <code>Node</code> in the constructor directly. But how would we go about putting the node in directly? We need something that creates an <code>Expr&lt;Node&gt;</code>; but <code>Node</code> isn&rsquo;t a completely trivial type &ndash; it&rsquo;s members (<code>Id</code> and <code>Ports</code>) are made of more complex types themselves. Let&rsquo;s start with a simpler challenge, and see if we can make an <code>Expr&lt;Id&gt;</code>.</p>

<p>We already know that:</p>

<p><code>fsharp
let embeddedId (identifier : Id) = &lt;@ identifier @&gt;
</code></p>

<p>isn&rsquo;t going to work. The expression evaluator won&rsquo;t know what to do with the <code>Id</code> type. But <code>Id</code>&rsquo;s constructor is a public method, as is the <code>Guid</code> constructor. Let&rsquo;s try it:</p>

<p>``` fsharp
let private embeddedId (id : Id) =</p>

<pre><code>let guid = sprintf "%A" (id.UniqueId)
let name = id.Name
&lt;@ Id(UniqueId = Guid(guid), Name = name) @&gt;
</code></pre>

<p>```</p>

<p>Cool. It works, and even has the right signature. Looks like we might be getting somewhere. The <code>Port</code> type is nearly as straight forward:</p>

<p>``` fsharp
let private embeddedPort (port : Port) =</p>

<pre><code>let idExpr = embeddedId port.Id
let type' = port.Type
&lt;@ Port(Id = %idExpr, Type = type') @&gt;
</code></pre>

<p>```</p>

<p>We&rsquo;re using our embeddedId method to &lsquo;lift&rsquo; the port&rsquo;s <code>Id</code> into an expression, and then splicing that expression into a call to create a new port.</p>

<p>We&rsquo;re on a roll! Just need to do the same for the <code>Node</code> type itself, with it&rsquo;s&hellip; <code>List</code> of <code>Port</code>s. Ah.</p>

<p>There&rsquo;s probably a more elegant way of doing this, but given this is a functional first language, let&rsquo;s grab the first tool that springs to mind.</p>

<p>Recursion.</p>

<p>``` fsharp
let private embeddedNode (node : Node) =</p>

<pre><code>let idExpr = embeddedId node.Id
let portsExpr adder = 
    &lt;@
        let outPorts = Collections.Generic.List&lt;Port&gt;()
        (%adder) outPorts
        outPorts
    @&gt;
let adder =
    let portExprs =
        Seq.map (fun port -&gt; embeddedPort port) (node.Ports)
        |&gt; Seq.toList
    let rec builder expr remaining =
        match remaining with
        | h::t -&gt;
            builder
                &lt;@ fun (ports : Collections.Generic.List&lt;Port&gt;) -&gt;
                        (%expr) ports
                        ports.Add(%h) @&gt;
                t
        | [] -&gt;
            expr
    builder
        &lt;@ fun (ports : Collections.Generic.List&lt;Port&gt;) -&gt; () @&gt;
        portExprs
&lt;@ Node(Id = %idExpr, Ports = (%portsExpr adder)) @&gt;
</code></pre>

<p>```</p>

<p>So, from the top down. <code>portsExpr</code> creates a quotation that takes an <code>adder</code> quotation (<code>Expr&lt;List&lt;Port&gt;&gt; -&gt; unit</code>) and returns an <code>Expr&lt;List&lt;Port&gt;&gt;</code>. This is what we&rsquo;re going to use in our <code>Node</code> construction quotation; but first we need the <code>adder</code>; some kind of magic method that takes a List and adds each of the ports from the node that&rsquo;s being passed into <code>embeddedNode</code>. I&rsquo;ve built it as a recursive function; the &lsquo;zero&rsquo; state that&rsquo;s passed in looks like this:</p>

<p><code>fsharp
&lt;@ fun (ports : Collections.Generic.List&lt;Port&gt;) -&gt; () @&gt;
</code></p>

<p>This is what will happen if the port list on the input node is empty. If it&rsquo;s not empty, we repeated build up nested calls to:</p>

<p>``` fsharp
&lt;@ fun (ports : Collections.Generic.List<Port>) &ndash;></p>

<pre><code>    (%expr) ports
    ports.Add(%h) @&gt;
</code></pre>

<p>```</p>

<p>Where <code>h</code> is the next port from the list. By the end of the process we have a chain of anonymous functions, each in turn closing over the quotation of a port from the input. Finally, we can splice that into the expression that actually creates our node.</p>

<p>Now we can use our new <code>embeddedX</code> expressions in our provided constructors and methods; for example, the constructor above becomes:</p>

<p>``` fsharp
let ctor = ProvidedConstructor(</p>

<pre><code>        [
            ProvidedParameter("Name", typeof&lt;string&gt;)
            ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
            ProvidedParameter("Config", typeof&lt;string&gt;)
        ],
        InvokeCode =
            fun [name;unique;config] -&gt; 
                let nodeExpr = embeddedNode &lt;| GetNode id
                &lt;@@ NodeInstance.create (%nodeExpr) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
</code></pre>

<p>```</p>

<p>Can you see the difference? Now, rather than closing over the <code>GetNode</code> method, we&rsquo;re closing over the quotation of the node that it returns.</p>

<p>With a sense of deja vu, let&rsquo;s just check this all works&hellip;</p>

<p><img src="/images/tp_quotations.png" alt="Winning!" /></p>

<p>And somewhat surprisingly &ndash; it does.</p>

<p>If you want to see and play with the code, the version for this post can be found in <a href="https://github.com/mavnn/Mavnn.Blog.TypeProvider/tree/FirstFloor">the FirstFloor branch of the project on GitHub</a>.</p>

<p>As with the first post in the series, let me know your questions and comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Provider ProTip]]></title>
    <link href="http://blog.mavnn.co.uk/type-provider-protip/"/>
    <updated>2014-01-10T12:15:15+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-provider-protip</id>
    <content type="html"><![CDATA[<p>While type providers are incredibly powerful, the ProvidedTypes api for creating them is sometimes a bit rough around the edges. And not always as functional as you might hope.</p>

<p>At some point I&rsquo;d like to do something about that, but for the moment I&rsquo;m just going to collect a few helpful tips and hints (mostly for own reference).</p>

<p>Tip one is in the case where you have XmlDocs to add to ProvidedTypes, ProvidedMethods and ProvidedProperties; in our case we have an optional description field in our metadata and the boiler plate was getting tiresome.</p>

<p>``` fsharp
let inline addDoc (desc : Descriptor) def =</p>

<pre><code>match desc.Description with
| Some d -&gt;
    (^T : (member AddXmlDoc : string -&gt; unit) (def, d))
| None -&gt; ()
</code></pre>

<p>```</p>

<p>This function takes a <code>Descriptor</code> with a <code>string option</code> Description field and any <code>def</code> with an AddXmlDoc member with the noted signature &ndash; and adds description as the xml doc if it exists.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type Providers from the Ground Up]]></title>
    <link href="http://blog.mavnn.co.uk/type-providers-from-the-ground-up/"/>
    <updated>2013-12-05T11:28:00+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-providers-from-the-ground-up</id>
    <content type="html"><![CDATA[<p><em>This post is part of a series: <a href="/type-providers-from-the-first-floor/">part 2</a> follows on directly from this post.</em></p>

<p>In the ground tradition of blog posts as both documentation and augmented memory, I&rsquo;ve just added our first <a href="http://blogs.msdn.com/b/dsyme/archive/2013/01/30/twelve-type-providers-in-pictures.aspx">Type Provider</a> to the code base. Time to write up the details before a) I forget them and b) anyone else needs to modify the code.</p>

<p>So, first things first. Before we get to the actual problem space at hand, let&rsquo;s try and provide a type. Any type&hellip;</p>

<p>1) Create yourself a new Visual Studio F# library project (2012 or up should work).</p>

<p>2a) Install the <a href="https://www.nuget.org/packages/FSharp.TypeProviders.StarterPack/">F# TypeProvider Starter Pack</a> or</p>

<p>2b) add <a href="https://raw.github.com/fsharp/FSharp.Data/master/src/CommonProviderImplementation/ProvidedTypes.fs">ProvidedTypes.fs</a> and <a href="https://raw.github.com/fsharp/FSharp.Data/master/src/CommonProviderImplementation/ProvidedTypes.fsi">ProvidedTypes.fsi</a> to the project as the first couple of files.</p>

<p>In either case, make sure that the .fsi file appears before the .fs file in your project listing, and that both appear before any type provider code &ndash; you will probably have to manually re-order them.</p>

<p>These are provided as code files rather than as compiled dlls due to complications with security and AppDomains when referencing dlls in the type provider assembly. For now just add them in &ndash; you really don&rsquo;t want to be re-creating the code in there by hand.</p>

<p>3) Replace the contents of Library1.fs with something like this:</p>

<p>``` fsharp
module Mavnn.Blog.TypeProvider</p>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices</p>

<p>[<TypeProvider>]
type MavnnProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>So, that&rsquo;s great and it builds. We have a type provider class and an assembly that knows it&rsquo;s a type providing assembly. Unfortunately, it doesn&rsquo;t actually provide any types yet. Let&rsquo;s try it.</p>

<!--more-->


<p>Update Library1.fs in your solution with something that looks like this, and then we&rsquo;ll run through what&rsquo;s going on, and how to test it.</p>

<p>``` fsharp
module Mavnn.Blog.TypeProvider</p>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open System.Reflection</p>

<p>[<TypeProvider>]
type MavnnProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Mavnn.Blog.TypeProvider.Provided"
let asm = Assembly.GetExecutingAssembly()

let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true, 
                                    GetterCode = (fun args -&gt; &lt;@@ "Hello world" @@&gt;))
    myType.AddMember(myProp)
    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>First things first &ndash; it looks like it should provide a class with a static property, but how do we test it?</p>

<p>It turns out it&rsquo;s harder than it looks. If you reference your brand new type provider in Visual Studio, that instance of Visual Studio will promptly lock the dll file. Which means you can&rsquo;t recompile it. So referencing the dll from within the instance of Visual Studio you&rsquo;re using to develop it is a no go.</p>

<p>Fire up a second copy of Visual Studio (you went for the extra RAM option on your hardware, yes?) and create an F# project in it. Add an fsx file that looks something like this:</p>

<p>``` fsharp
// Your path may vary&hellip;</p>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Mavnn.Blog.TypeProvider.dll&rdquo;</h1>

<p>open Mavnn.Blog.TypeProvider.Provided</p>

<p>// Type <code>MyType.MyProperty</code> on next line down.
```</p>

<p>Start typing, and&hellip; hurrah! Intellisense on your new, provided type with static property. Evaluate the script in F# interactive for one of the longest &ldquo;Hello World&rdquo; programs you&rsquo;ve ever seen.</p>

<p><em>You will need to close this instance of Visual Studio every time you want to recompile the type provider.</em></p>

<h2>What&rsquo;s going on here?</h2>

<p>We&rsquo;re declaring a new namespace and detecting the current assembly so we can inject things into it. During our initializing for the type provider, we then add that namespace to the assembly (<code>this.AddNamespace(...)</code>) along with a type created in the slightly (at the moment) misnamed <code>createTypes</code> method.</p>

<p>In <code>createTypes</code> we&rsquo;re first creating a type (<code>MyType</code>) which will be a direct member of the namespace we&rsquo;re creating (we&rsquo;ll get onto nested types shortly), then we&rsquo;re creating a static property and adding it to the type. <code>AddNamespace</code> takes a list of types, so will add the one we have to a list and pass it back.</p>

<p><code>MyType</code>&rsquo;s underlying representation in the CLR has been defined as <code>obj</code>, which means that if you try and access it in a non-F# language it will appear to the compiler as an <code>object</code>.</p>

<p>All well and good&hellip; except for the rather bizarre <code>&lt;@@ ... @@&gt;</code> syntax in our static property. Obviously, in some way it&rsquo;s creating a get method for the property that returns <code>"Hello world"</code>, but how does it do it?</p>

<p>This syntax represents a <a href="http://msdn.microsoft.com/en-us/library/dd233212.aspx">code quotation</a>, and rather than being compiled into your program it will compile to an object that represents an expression.</p>

<p>Did that make your brain hurt? Mine too&hellip; I&rsquo;m not going to go into quotations in great detail here (partly as I don&rsquo;t understand them well enough!) but we&rsquo;ll need to cover a couple of basics.</p>

<p>To give you a flavour, the quotation <code>&lt;@@ 1 + 2 @@&gt;</code> compiles to <code>Quotations.Expr = Call (None, op_Addition, [Value (1), Value (2)])</code>. Not very exciting so far, but how about:</p>

<p>``` fsharp
let addI i =</p>

<pre><code>&lt;@@ 1 + (%%i) @@&gt;
</code></pre>

<p>```</p>

<p>This gives a function of <code>Expr -&gt; Expr</code>, and now we can do things like <code>let add2 = addI &lt;@@ 2 @@&gt;</code> (gives <code>val add2 : Expr = Call (None, op_Addition, [Value (1), Value (2)])</code>) or <code>let add2MultipliedByX x = addI &lt;@@ 2 * x @@&gt;</code> (gives <code>val add2MultipliedByX : x:int -&gt; Expr</code>) and what we get back is effectively the AST of the first F# expression with the second spliced in to evaluate as you will. So in our <code>GetterCode</code> above, we are actually providing the AST that will be compiled into the <code>get_MyPropertyMethod</code> of the type when it is created.</p>

<p>The second thing that you need to know about quotations for current purposes is that the thing evaluating them may or may not be able to handle the F# expression you&rsquo;ve created. Which again we&rsquo;ll get back to in a moment!</p>

<p>So far, our type isn&rsquo;t very exciting. You can&rsquo;t even construct an instance of it. Let&rsquo;s see what we can do about that, with a replacement <code>createTypes</code> method:</p>

<p>``` fsharp</p>

<pre><code>let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true, 
                                    GetterCode = fun args -&gt; &lt;@@ "Hello world" @@&gt;)
    myType.AddMember(myProp)

    let ctor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ "My internal state" :&gt; obj @@&gt;)
    myType.AddMember(ctor)

    let ctor2 = ProvidedConstructor(
                    [ProvidedParameter("InnerState", typeof&lt;string&gt;)],
                    InvokeCode = fun args -&gt; &lt;@@ (%%(args.[0]):string) :&gt; obj @@&gt;)
    myType.AddMember(ctor2)

    let innerState = ProvidedProperty("InnerState", typeof&lt;string&gt;,
                        GetterCode = fun args -&gt; &lt;@@ (%%(args.[0]) :&gt; obj) :?&gt; string @@&gt;)
    myType.AddMember(innerState)

    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>```</p>

<p>Now we can construct our type (in two ways, no less). As the underlying CLR type is an <code>object</code> we can store pretty much anything as the internal representation of an instance of our type. The <code>InvokeCode</code> parameter of the constructors needs to return a quotation that will return the internal representation of the object when it&rsquo;s evaluated. We&rsquo;re going to return a string (which we need to cast to an obj), and using the splicing syntax above we can inject the parameters of the constructor into the quotation (for the constructor which has a parameter).</p>

<p>Similarly, we also add a property (notice that we&rsquo;re not setting it to be a static property this time). Because this property is not static, the first item in the <code>args</code> Array is the instance of the type itself (similar to the way that you define an extension method). So we can splice that into our method quotation (remembering to cast it from <code>obj</code> to <code>string</code>) and expose the underlying state of the object for all the world to see.</p>

<p>And now you can do things like this:</p>

<p>``` fsharp
// Your path may vary&hellip;</p>

<h1>r @&ldquo;../../Mavnn.Blog.TypeProvider/Mavnn.Blog.TypeProvider/bin/Debug/Mavnn.Blog.TypeProvider.dll&rdquo;</h1>

<p>open Mavnn.Blog.TypeProvider.Provided</p>

<p>let thing = MyType()
let thingInnerState = thing.InnerState</p>

<p>let thing2 = MyType(&ldquo;Some other text&rdquo;)
let thing2InnerState = thing2.InnerState</p>

<p>// val thing : Mavnn.Blog.TypeProvider.Provided.MyType = &ldquo;My internal state&rdquo;
// val thingInnerState : string = &ldquo;My internal state&rdquo;
// val thing2 : Mavnn.Blog.TypeProvider.Provided.MyType = &ldquo;Some other text&rdquo;
// val thing2InnerState : string = &ldquo;Some other text&rdquo;
```</p>

<h2>And the point is?</h2>

<p>Well &ndash; this is great, except the perceptive among you will have noticed that we&rsquo;re just generating a static type here. We could have just declared it using normal syntax.</p>

<p>So let&rsquo;s try going a step further. Let&rsquo;s say that we have some Json definitions of graph nodes types, each with a defined set of input and output &ldquo;ports&rdquo;. All of these graph bits are given to us as a Json array, and each Node type and port has a Guid identifier and a friendly name.</p>

<p>Our input JSON looks something like this:</p>

<p>``` json
[
   {</p>

<pre><code>  "Id":{
     "Name":"Simple",
     "UniqueId":"0ab82262-0ad3-47d3-a026-615b84352822"
  },
  "Ports":[
     {
        "Id":{
           "Name":"Input",
           "UniqueId":"4b69408e-82d2-4c36-ab78-0d2327268622"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Output",
           "UniqueId":"92ae5a96-6900-4d77-832f-d272329f8a90"
        },
        "Type":"output"
     }
  ]
</code></pre>

<p>   },
   {</p>

<pre><code>  "Id":{
     "Name":"Join",
     "UniqueId":"162c0981-4370-4db3-8e3f-149f13c001da"
  },
  "Ports":[
     {
        "Id":{
           "Name":"Input1",
           "UniqueId":"c0fea7ff-456e-4d4e-b5a4-9539ca134344"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Input2",
           "UniqueId":"4e93c3b1-11bc-422a-91b8-e53204368714"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Output",
           "UniqueId":"fb54728b-9602-4220-ba08-ad160d92d5a4"
        },
        "Type":"output"
     }
  ]
</code></pre>

<p>   },
   {</p>

<pre><code>  "Id":{
     "Name":"Split",
     "UniqueId":"c3e44941-9182-41c3-921c-863a82097ba8"
  },
  "Ports":[
     {
        "Id":{
           "Name":"Input",
           "UniqueId":"0ec2537c-3346-4503-9f5a-d0bb49e9e431"
        },
        "Type":"input"
     },
     {
        "Id":{
           "Name":"Output1",
           "UniqueId":"77b5a50c-3d11-4a67-b14d-52d6246e78c5"
        },
        "Type":"output"
     },
     {
        "Id":{
           "Name":"Output2",
           "UniqueId":"d4d1e928-5347-4d51-be54-8650bdfe9bac"
        },
        "Type":"output"
     }
  ]
</code></pre>

<p>   }
]
```</p>

<p>Things start getting a bit more in depth here, so you might want to check out the full code for this post, available on <a href="https://github.com/mavnn/Mavnn.Blog.TypeProvider">GitHub</a>, and follow along in your favourite development environment.</p>

<p>We&rsquo;ll let someone else deal with the parsing &ndash; add a Nuget reference to <code>Newtonsoft.Json</code> to your type provider, and let&rsquo;s have a third reprise of <code>createTypes</code>.</p>

<p>First, we&rsquo;ll need some classes to deserialize the Json into. Out of the box Newtonsoft doesn&rsquo;t do a great job on F# core classes (although that&rsquo;s changing), so for the moment we&rsquo;ll create some classic OO style mutable types:</p>

<p>``` fsharp
type Id () =</p>

<pre><code>member val UniqueId = Guid() with get, set
member val Name = "" with get, set
</code></pre>

<p>type Port () =</p>

<pre><code>member val Id = Id() with get, set
member val Type = "" with get, set
</code></pre>

<p>type Node () =</p>

<pre><code>member val Id = Id() with get, set
member val Ports = Collections.Generic.List&lt;Port&gt;() with get, set
</code></pre>

<p>```</p>

<p>(Don&rsquo;t worry though, these aren&rsquo;t what we&rsquo;ll actually expose as the main interface.)</p>

<p>Turning our Json into the our new CLR types is straight forward:</p>

<p>``` fsharp
let nodes =</p>

<pre><code>JsonConvert.DeserializeObject&lt;seq&lt;Node&gt;&gt;(IO.File.ReadAllText(@"c:\Temp\Graph.json"))
</code></pre>

<p>```</p>

<p>Now the interesting part. To build a graph out of these nodes, we need to be able to do a few things.</p>

<p>Firstly, we need to be able to build a specific instance of a node type: which <code>Split</code> node is this?</p>

<p>Let&rsquo;s help ourselves out by having a concrete type as an the underlying type for our instances:</p>

<p>``` fsharp
type nodeInstance =</p>

<pre><code>{
    Node : Node
    InstanceId : Id
    Config : string
}
</code></pre>

<p>module private NodeInstance =</p>

<pre><code>let create node name guid config =
    { Node = node; InstanceId = Id(Name = name, UniqueId = guid); Config = config }  
</code></pre>

<p>```</p>

<p>And then constructing a more specific type with a constructor for each node type we&rsquo;ve read from the Json:</p>

<p>``` fsharp
let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof<nodeInstance>)
let ctor = ProvidedConstructor(</p>

<pre><code>        [
            ProvidedParameter("Name", typeof&lt;string&gt;)
            ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
            ProvidedParameter("Config", typeof&lt;string&gt;)
        ],
        InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
</code></pre>

<p>```</p>

<p>So now we can construct (look back at the json) a <code>Simple</code> node instance by using <code>let simple = Simple("simpleInstance", Guid.NewGuid(),"MyConfig")</code>. And it already has our <code>InstanceId</code>, <code>Config</code> and <code>Node</code> properties from the underlying type.</p>

<p>Good progress &ndash; but we don&rsquo;t have a nice way of representing the inputs and outputs? We want to be able to write some kind of connection builder function afterwards that won&rsquo;t allow you to connect to outputs to each other, or similar silliness, so we&rsquo;re going to need separate types for inputs and outputs.</p>

<p>``` fsharp
// Check out the excellent article at F# for Fun and Profit
// on using single case Discriminated Unions for data modelling
// <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/">http://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/</a></p>

<p>type InputPort = | InputPort of Port
type OutputPort = | OutputPort of Port
```</p>

<p>And finally, we&rsquo;ll update our node creation function to add two subtypes to each node type called <code>Inputs</code> and <code>Outputs</code>, and then create properties on those objects to represent each port. Our full type creation for a node now looks something like this:</p>

<p>``` fsharp
let addInputPort (inputs : ProvidedTypeDefinition) (port : Port) =</p>

<pre><code>let port = ProvidedProperty(
                port.Id.Name, 
                typeof&lt;InputPort&gt;, 
                GetterCode = fun args -&gt; 
                    let id = port.Id.UniqueId.ToString()
                    &lt;@@ GetPort id @@&gt;)
inputs.AddMember(port)
</code></pre>

<p>let addOutputPort (outputs : ProvidedTypeDefinition) (port : Port) =</p>

<pre><code>let port = ProvidedProperty(
                port.Id.Name, 
                typeof&lt;OutputPort&gt;, 
                GetterCode = fun args -&gt; 
                    let id = port.Id.UniqueId.ToString()
                    &lt;@@ GetPort id @@&gt;)
outputs.AddMember(port)
</code></pre>

<p>let addPorts inputs outputs (portList : seq<Port>) =</p>

<pre><code>portList
|&gt; Seq.iter (fun port -&gt; 
                match port.Type with
                | "input" -&gt; addInputPort inputs port
                | "output" -&gt; addOutputPort outputs port
                | _ -&gt; failwithf "Unknown port type for port %s/%s" port.Id.Name (port.Id.UniqueId.ToString()))
</code></pre>

<p>let createNodeType id (node : Node) =</p>

<pre><code>let nodeType = ProvidedTypeDefinition(asm, ns, node.Id.Name, Some typeof&lt;nodeInstance&gt;)
let ctor = ProvidedConstructor(
            [
                ProvidedParameter("Name", typeof&lt;string&gt;)
                ProvidedParameter("UniqueId", typeof&lt;Guid&gt;)
                ProvidedParameter("Config", typeof&lt;string&gt;)
            ],
            InvokeCode = fun [name;unique;config] -&gt; &lt;@@ NodeInstance.create (GetNode id) (%%name:string) (%%unique:Guid) (%%config:string) @@&gt;)
nodeType.AddMember(ctor)

let outputs = ProvidedTypeDefinition("Outputs", Some typeof&lt;obj&gt;)
let outputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
outputs.AddMember(outputCtor)
outputs.HideObjectMethods &lt;- true

let inputs = ProvidedTypeDefinition("Inputs", Some typeof&lt;obj&gt;)
let inputCtor = ProvidedConstructor([], InvokeCode = fun args -&gt; &lt;@@ obj() @@&gt;)
inputs.AddMember(inputCtor)
inputs.HideObjectMethods &lt;- true
addPorts inputs outputs node.Ports

// Add the inputs and outputs types of nested types under the Node type
nodeType.AddMembers([inputs;outputs])

// Now add some instance properties to expose them on a node instance.
let outputPorts = ProvidedProperty("OutputPorts", outputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)
let inputPorts = ProvidedProperty("InputPorts", inputs, [],
                    GetterCode = fun args -&gt; &lt;@@ obj() @@&gt;)

nodeType.AddMembers([inputPorts;outputPorts])

nodeType
</code></pre>

<p>```</p>

<p>Leaving only one final mystery. What are the <code>GetPort</code> and <code>GetNode</code> methods &ndash; and why am I using them in the quotations rather than just using something like <code>&lt;@@ node @@&gt;</code>?</p>

<p>Well, if you remember I mentioned earlier that the evaluation of a quotation is limited by the implementation of the evaluator used. The type provider files you included right at the beginning contain an evaluator that turn a quotation into IL instructions &ndash; but, it doesn&rsquo;t include support for literals of custom types. In fact, if you check in <a href="https://github.com/fsharp/FSharp.Data/blob/master/src/CommonProviderImplementation/ProvidedTypes.fs#L1876">the relevant part of ProvidedTypes.fs</a> you&rsquo;ll see that it&rsquo;s actually quite prescriptive.</p>

<p>So, what we do is we build a couple of private helper methods that know how to find the correct port or node from one of the types that is allowed &ndash; in this case, a <code>string</code>:</p>

<p>``` fsharp
let private nodes = JsonConvert.DeserializeObject&lt;seq<Node>>(IO.File.ReadAllText(@&ldquo;c:\Temp\Graph.json&rdquo;))</p>

<pre><code>                |&gt; Seq.map (fun n -&gt; n.Id.UniqueId.ToString(), n)
                |&gt; Map.ofSeq
</code></pre>

<p>let GetNode id =</p>

<pre><code>nodes.[id]
</code></pre>

<p>let private ports =</p>

<pre><code>nodes
|&gt; Map.toSeq
|&gt; Seq.map (fun (_, node) -&gt; node.Ports)
|&gt; Seq.concat
|&gt; Seq.map (fun p -&gt; p.Id.UniqueId.ToString(), p)
|&gt; Map.ofSeq
</code></pre>

<p>let GetPort id =</p>

<pre><code>ports.[id]
</code></pre>

<p>```</p>

<p>So, there you have it. A complete, working type provider that uses meta data supplied in Json format to create CLR types. Lots of things still to be added for production ready code (delayed loading, handling multiple ports with the same names, not hard coding the filename, etc).</p>

<p><img src="/images/typeprovider.png" alt="Winning..." /></p>

<p>Any questions or corrections, fire away. As mentioned, this is very much the first time I&rsquo;ve used type providers &ndash; but even this level of usage is providing a goodly amount of value for us.</p>

<p>And if you&rsquo;re ready for the next challenge&hellip; off to <a href="/type-providers-from-the-first-floor/">part 2</a> with you!</p>
]]></content>
  </entry>
  
</feed>
