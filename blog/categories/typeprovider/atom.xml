<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: typeprovider | Mavnn's blog]]></title>
  <link href="http://blog.mavnn.co.uk/blog/categories/typeprovider/atom.xml" rel="self"/>
  <link href="http://blog.mavnn.co.uk/"/>
  <updated>2016-02-29T21:19:35+00:00</updated>
  <id>http://blog.mavnn.co.uk/</id>
  <author>
    <name><![CDATA[mavnn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Type Providers Live - the Movie]]></title>
    <link href="http://blog.mavnn.co.uk/type-providers-live-the-movie/"/>
    <updated>2016-02-29T21:10:51+00:00</updated>
    <id>http://blog.mavnn.co.uk/type-providers-live-the-movie</id>
    <content type="html"><![CDATA[<p>I recently gave a live streamed tutorial on building type providers, which I&rsquo;ve embedded below. Apologies for the sound; apparently Google Hangouts added a feature I was unaware of until after the stream started which mutes your microphone whenever you type.</p>

<p>Fortunately I think enough was preserved to be useful, and (amazingly!) all of the demonstrations actually worked.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/pXT0li6zxKQ" frameborder="0" allowfullscreen></iframe>


<p>If you&rsquo;d like to try things out for yourself, there&rsquo;s a github repository at <a href="https://github.com/mavnn/CambridgeTypeProvider">https://github.com/mavnn/CambridgeTypeProvider</a> which contains 6 individual fsx files, one for each new feature added to the type provider.</p>

<p>There&rsquo;s a bunch of other type provider information scattered around this blog, if you&rsquo;re interested just click <a href="http://blog.mavnn.co.uk/blog/categories/typeprovider/">the &ldquo;typeprovider&rdquo; tag</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EmParsec Embedded Parser Library]]></title>
    <link href="http://blog.mavnn.co.uk/emparsec-embedded-parser-library/"/>
    <updated>2016-01-18T12:53:11+00:00</updated>
    <id>http://blog.mavnn.co.uk/emparsec-embedded-parser-library</id>
    <content type="html"><![CDATA[<blockquote><p>You can find EmParsec on GitHub: <a href="https://github.com/mavnn/EmParsec">https://github.com/mavnn/EmParsec</a></p></blockquote>

<p>Type providers, by their very nature, tend to access data external to the .net ecosystem. It can also be very awkward technically to make use of dependencies during the actual type generation process.</p>

<p>This is rather a pity, because accessing all of that external data is much nicer and easier when you have a decent parser to do it with. And F# has very, very nice parser support via the <a href="http://www.quanttec.com/fparsec/">FParsec</a> library. Instead, many (most?) type providers end up creating mini-one shot parsers which can be a bit slow to write and don&rsquo;t tend to have features that come for free in a more complete solution such as nice error reporting.</p>

<p>Writing yet an other parser (YAOP) this week I decided that enough was enough. What I needed was a shared resource that people could pool improvements for that could be easily embedded in projects like type providers were it isn&rsquo;t desirable (or sometimes possible) to take external binary dependencies.</p>

<p>So I built it.</p>

<!-- more -->


<p>EmParsec is a single file parser combinator &ldquo;library&rdquo;, inspired by both FParsec library and <a href="http://fsharpforfunandprofit.com/posts/understanding-parser-combinators/">Scott&rsquo;s excellent series on building parser combinators</a>.</p>

<p>It consists of a single fs file that can be loaded in the editor of your choice without any requirement for a project file or similar. When you want to use it, you can just reference it as a <a href="https://fsprojects.github.io/Paket/github-dependencies.html">Paket GitHub dependency</a> (which you&rsquo;ll be wanting to do for the ProvidedTypes.fs file if you&rsquo;re creating a type provider anyway) or even just copy the file across.</p>

<p>If you are compiling EmParsec into a larger project, it marks itself as &ldquo;internal&rdquo; so that you don&rsquo;t pollute the end users name space, and so that if two projects you reference have embedded different versions of EmParsec there are no collisions.</p>

<h2>How do I use it?</h2>

<p>So, you&rsquo;ve added EmParsec.fs to your project (manually or with Paket) and now you&rsquo;re wondering how to use it. Let&rsquo;s build some simple examples.</p>

<h3>Matching an exact string</h3>

<p>Let&rsquo;s start with something simple: what if I just want to match a string?</p>

<p>Parser combinator libraries allow you to combine parsers from simpler parsers (hence the name), but in this case <code>pstring</code> (the &lsquo;p&rsquo; is there to avoid clashing with the existing <code>string</code> function) is provided for us by EmParsec.</p>

<p>Let&rsquo;s try it out!</p>

<p>``` fsharp
open EmParsec</p>

<p>let thingParser = pstring &ldquo;thing&rdquo;
// When you enter this line, F# give a &ldquo;Value restriction&rdquo; error.
// You can either mark thingParser as type UParser<string>, or
// use the parser with run as below and the error will disappear.</p>

<p>run thingParser &ldquo;thing&rdquo;
// val it : Choice&lt;string,string> = Choice1Of2 &ldquo;thing&rdquo;</p>

<p>run thingParser &ldquo;th1ng&rdquo;
// val it : Choice&lt;string,string> =
//   Choice2Of2
//     &ldquo;Parser <string thing> failed at line 0 column 2
// Unexpected [&lsquo;1&rsquo;]
// th1ng
//   ^&rdquo;
```</p>

<p>Not bad! It even marks the unexpected character in the error output.</p>

<p>Unfortunately:</p>

<p><code>fsharp
run thingParser "thing and more"
// val it : Choice&lt;string,string&gt; = Choice1Of2 "thing"
</code></p>

<p>That probably isn&rsquo;t the behaviour you were hoping for. There&rsquo;s still input left after the parser has finished, but that isn&rsquo;t being seen as an error. EmParsec includes the <code>eof</code> parser for just this type of occasion &ndash; a parser that checks the input is exhausted.</p>

<p>So we want a parser that parses &ldquo;thing&rdquo; and then ends.</p>

<p>Let&rsquo;s go:</p>

<p>``` fsharp
let thingParser2 = andThen (pstring &ldquo;thing&rdquo;) eof
// normally written
let thingParser2' = pstring &ldquo;thing&rdquo; .>>. eof</p>

<p>run thingParser2 &ldquo;thing&rdquo;
// val it : Choice&lt;(string * unit),string> = Choice1Of2 (&ldquo;thing&rdquo;, null)</p>

<p>run thingParser2 &ldquo;th1ng&rdquo;
// val it : Choice&lt;(string * unit),string> =
//   Choice2Of2
//     &ldquo;Parser (<string thing> andThen <end>) failed at line 0 column 2
// Unexpected [&lsquo;1&rsquo;]
// th1ng
//   ^&rdquo;</p>

<p>run thingParser2 &ldquo;thing and more&rdquo;
// val it : Choice&lt;(string * unit),string> =
//   Choice2Of2
//     &ldquo;Parser (<string thing> andThen <end>) failed at line 0 column 5
// Unexpected input remaining &lsquo; and more&rsquo;
// thing and more
//      ^&rdquo;
```</p>

<p>That&rsquo;s more like it. The only issue now is that we&rsquo;ve combined two parser, so we&rsquo;re getting back a tuple of two results.</p>

<p>A simple tweak tells EmParsec to throw away the unit result returned by <code>eof</code>.</p>

<p>``` fsharp
let improvedThingParser = pstring &ldquo;thing&rdquo; .>> eof</p>

<p>run improvedThingParser &ldquo;thing&rdquo;
// val it : Choice&lt;string,string> = Choice1Of2 &ldquo;thing&rdquo;
```</p>

<p>&ldquo;Impressive,&rdquo; I hear you say: &ldquo;You can parse static strings!&rdquo;</p>

<h3>Parsing a simple template language</h3>

<p>You have a point. Let&rsquo;s tackle a simple template language. You know the kind of thing:</p>

<p><code>Welcome {name}! Please spend money here.</code></p>

<p>That kind of thing. I&rsquo;m going to start building up a set of helper parsers for this, applying some type annotations both to make the example code clearer and to avoid the value restriction errors that crop up until you actually use the parsers (those occur because these parsers can carry generic user state, but we&rsquo;re not going to go into using that here).</p>

<p>We have two &ldquo;types&rdquo; of token that can exist in our template language: values to be replaced, and text to be preserved. Let&rsquo;s start by creating a union type to contain our parse results:</p>

<p><code>fsharp
type TemplatePart =
  | Text of string
  | Value of string
</code></p>

<p>Then, we&rsquo;ll have a parser that will parse individual characters which are <em>not</em> an opening bracket:</p>

<p><code>fsharp
let notOpenBracket : UParser&lt;char&gt; =
  satisfy (fun c -&gt; c &lt;&gt; char '{') "not open bracket"
</code></p>

<p><code>satisfy</code> is a function built into EmParsec which takes a predicate for whether or not it will consume the next character in the input stream. The final string argument is a name for the parser, which will be used in error messages.</p>

<p>Then we&rsquo;ll use that parser to create one that consumes as many &ldquo;not open bracket&rdquo; characters as it can, combines them into a string and then counts that string as a <code>Text</code> part.</p>

<p>``` fsharp
let textParser : UParser<TemplatePart> =
  many1 notOpenBracket
  |>> (fun charList &ndash;></p>

<pre><code>     charList
     |&gt; List.map string
     |&gt; String.concat ""
     |&gt; Text)
</code></pre>

<p>  &lt;?> &ldquo;<text parser>&rdquo;
```</p>

<p>There&rsquo;s a new function here and a couple of new operators (all taken from FParsec, by the way). <code>|&gt;&gt;</code> is a map operator; it allows you to transform the result of a parser and then rewrap everything back up into a new parser. This is really at the heart of the power of parser combinator libraries.</p>

<p>The <code>&lt;?&gt;</code> operator is much simpler: it allows you to name a parser rather than its name being some combination of the parsers it&rsquo;s built of.</p>

<p>The <code>many1</code> function says &ldquo;match one or more instances of the parser that follows&rdquo;. There is also a <code>many</code>, which matches 0 or more repeats.</p>

<p>So that&rsquo;s good &ndash; we can capture the text in between our replacable values. Let&rsquo;s go with a parser for the bracketed value names next!</p>

<p>``` fsharp
let valueName : UParser<string> =
  many1 (satisfy (fun c &ndash;> c &lt;> &lsquo;}&rsquo; &amp;&amp; (not &lt;| System.Char.IsWhiteSpace c)) &ldquo;&rdquo;)
  |>> (fun charList &ndash;> charList |> List.map string |> String.concat &ldquo;&rdquo;)</p>

<p>let openValue : UParser<unit> =
  pchar &lsquo;{&rsquo; .>>. spaces
  |>> ignore</p>

<p>let closeValue : UParser<unit> =
  spaces .>>. pchar &lsquo;}&rsquo;
  |>> ignore</p>

<p>let value : UParser<TemplatePart> =
  between openValue closeValue valueName
  |>> Value
  &lt;?> &ldquo;<value parser>&rdquo;
```</p>

<p>So we now have parsers for white space and our &ldquo;valueName&rdquo; (which we are saying must be at least one character long, and can consist of any character which is not whitespace or a closing curly bracket). We can then use pchar (&ldquo;parse char&rdquo;) and whitespace to allow for minor variations in syntax (some people like <code>{name}</code>, others like <code>{ name }</code>).</p>

<p>Finally we build our value parser, using the <code>between</code> function, which does pretty much what you&rsquo;d expect: it takes an opening parser, a closing parser, and captures what&rsquo;s in between with third parser.</p>

<p>Our final step is just to combine our parsers for value and text sections. We want to capture &ldquo;many&rdquo; of one or the other, until we run out of input. We&rsquo;ll put an explicit <code>eof</code> on there as well, otherwise things like (for example) an unclosed <code>}</code> at the end of the string will not show up as an error &ndash; the parser will just stop at the character before the opening <code>{</code> as the last matching input.</p>

<p>Our final parser introduces the <code>&lt;|&gt;</code> (orElse) operator, and looks like this:</p>

<p><code>fsharp
let template : UParser&lt;TemplatePart list&gt; =
  many (value &lt;|&gt; textParser)
  .&gt;&gt; eof
  &lt;?&gt; "&lt;template parser&gt;"
</code></p>

<p>Let&rsquo;s try it out!</p>

<p>``` fsharp
open System.Text</p>

<p>let showTemplate values parts =
  let folder (sb : StringBuilder) part =</p>

<pre><code>match part with
| Text s -&gt;
  sb.Append s
| Value v -&gt;
  defaultArg (Map.tryFind v values) ""
  |&gt; sb.Append
</code></pre>

<p>  let sb = List.fold folder (StringBuilder()) parts
  sb.ToString()</p>

<p>let values = Map [ &ldquo;name&rdquo;, &ldquo;bob&rdquo; ]</p>

<p>let run' parser str =
  run parser str
  |> function</p>

<pre><code> | Choice1Of2 success -&gt; showTemplate values success
 | Choice2Of2 fail -&gt; failwithf "Parsing failed!\n%s" fail
</code></pre>

<p>```</p>

<p>A couple of helpers: <code>showTemplate</code> knows how to build up a string from a list of template parts and a value map, <code>run'</code> is just a simple wrapper around <code>run</code> that throws if parsing is not successful.</p>

<p>``` fsharp
let ex1 = &ldquo;Welcome {name}! Please spend money here!&rdquo;
let ex2 = &ldquo;hello { name } thing&rdquo;</p>

<p>run' template ex1
// val it : string = &ldquo;Welcome bob! Please spend money here!&rdquo;</p>

<p>run' template ex2
// val it : string = &ldquo;hello bob thing&rdquo;</p>

<p>let ex3 = &ldquo;Hello, { name }! How about {
 date:alreadyrendered?
}? &lt;&ndash; That should be left blank, but parse as valid.&rdquo;</p>

<p>run' template ex3
// val it : string =
//   &ldquo;Hello, bob! How about ? &lt;&ndash; That should be left blank, but parse as valid.&rdquo;
```</p>

<p>And finally our templates in action. You can see that even with a simple parser like this, it&rsquo;s already reaching a complexity that would be painful to match with a hand rolled creation.</p>

<p>If you want to know more about parser combinators, and especially how to use them to create recursive grammars, do check out the <a href="http://www.quanttec.com/fparsec/">FParsec documentation</a> which is excellent. It is also more complete and <em>much</em> more performant than EmParsec.</p>

<p>But if you need a small, single file parser where performance is not the primary concern &ndash; maybe EmParsec is your friend. Anyone who wants to join in making it better is more than welcome! Of particular note is that EmParsec does not yet support controlling when backtracking does or doesn&rsquo;t happen (it will always backtrack) which can make for some pretty confusing error messages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing ProvidedType.fs by Example]]></title>
    <link href="http://blog.mavnn.co.uk/testing-providedtype-dot-fs/"/>
    <updated>2015-02-16T12:12:56+00:00</updated>
    <id>http://blog.mavnn.co.uk/testing-providedtype-dot-fs</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/fsprojects/FSharp.TypeProviders.StarterPack">Type Provider Starter Pack</a> was designed with two purposes initially. Firstly, to be a canonical repository for the ProvidedTypes files which provide a source file based API for creating type providers. And secondly, to be a set of tutorials and examples for people wanting to dip their toes into building type providers for the first time.</p>

<p>To be honest, it&rsquo;s not been doing a complete job of either:</p>

<ul>
<li>I think most people are using it as the source of ProvidedTypes.fs and .fsi now days, but it didn&rsquo;t provide any infrastructure or testing for progressing the library.</li>
<li>The &ldquo;examples&rdquo; were limited to a link to my <a href="/type-providers-from-the-ground-up/">tutorial on building type providers</a></li>
</ul>


<p>Today, that&rsquo;s changed. And I need your help!</p>

<h3>Testing ProvidedTypes</h3>

<p>Once I started thinking about it, it became clear that the code needed for basic type provider examples, and the code needed to test ProvidedTypes.fs were basically identical.</p>

<p>So I implemented a system for compiling and testing example .fsx scripts within the Starter Pack repository.</p>

<p>Want to help out? As long as you have some basic git and F# knowledge, it&rsquo;s easy!</p>

<!-- more -->


<h4>Fork the repository and pull down a clone</h4>

<h4>Add an example to the <code>/examples</code> directory</h4>

<p>Structure the example as below and save it as an .fsx file:</p>

<p>``` fsharp</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;../src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;../src/ProvidedTypes.fs&rdquo;</h1>

<h1>endif</h1>

<p>open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open System.Reflection</p>

<p>[<TypeProvider>]
type BasicProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "StaticProperty.Provided"
let asm = Assembly.GetExecutingAssembly()

let createTypes () =
    let myType = ProvidedTypeDefinition(asm, ns, "MyType", Some typeof&lt;obj&gt;)
    let myProp = ProvidedProperty("MyProperty", typeof&lt;string&gt;, IsStatic = true,
                                    GetterCode = (fun args -&gt; &lt;@@ "Hello world" @@&gt;))
    myType.AddMember(myProp)
    [myType]

do
    this.AddNamespace(ns, createTypes())
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>The <code>#if INTERACTIVE</code> block at the top will allow you to write your example in Visual Studio, without us requiring a separate project for each example provider.</p>

<h4>Add a set of tests in a .fsx script in the <code>/examples</code> directory</h4>

<p>The test file for the example above looks like this, and again should be saved as an .fsx file:</p>

<p>``` fsharp</p>

<h1>if INTERACTIVE</h1>

<h1>r @&ldquo;../packages/Nunit.Runners/tools/nunit.framework.dll&rdquo;</h1>

<h1>r @&ldquo;../test/StaticProperty.dll&rdquo;</h1>

<h1>endif</h1>

<p>open NUnit.Framework
open StaticProperty.Provided</p>

<p>[<Test>]
let <code>Static property should have been created</code> () =</p>

<pre><code>Assert.AreEqual("Hello world", MyType.MyProperty)
</code></pre>

<p>```</p>

<p>Note the two #r references at the top. Remember what you choose to call the dll!</p>

<h4>Hooking up the examples so they get built and tested</h4>

<p>The main build file is where the magic happens &ndash; <a href="https://github.com/fsprojects/FSharp.TypeProviders.StarterPack/blob/master/build.fsx">build.fsx</a> in the root directory.</p>

<p>Squirrelled away in there is a target called <code>Examples</code>. It&rsquo;s contents look like this:</p>

<p>``` fsharp
let examples =</p>

<pre><code>[
    {
        Name = "StaticProperty"
        ProviderSourceFiles = ["StaticProperty.fsx"]
        TestSourceFiles = ["StaticProperty.Tests.fsx"]
    }
    {
        Name = "ErasedWithConstructor"
        ProviderSourceFiles = ["ErasedWithConstructor.fsx"]
        TestSourceFiles = ["ErasedWithConstructor.Tests.fsx"]
    }
]
</code></pre>

<p>let testNunitDll = testDir @@ &ldquo;nunit.framework.dll&rdquo;</p>

<p>do</p>

<pre><code>if File.Exists testNunitDll then
    File.Delete testNunitDll
File.Copy (nunitDir @@ "nunit.framework.dll", testNunitDll)
</code></pre>

<p>let fromExampleDir filenames =</p>

<pre><code>filenames
|&gt; List.map (fun filename -&gt; exampleDir @@ filename)
</code></pre>

<p>examples
|> List.iter (fun example &ndash;></p>

<pre><code>    // Compile type provider
    let output = testDir @@ example.Name + ".dll"
    let setOpts = fun def -&gt; { def with Output = output; FscTarget = FscTarget.Library }
    Fsc setOpts (List.concat [pt;fromExampleDir example.ProviderSourceFiles])

    // Compile test dll
    let setTestOpts = fun def -&gt;
        { def with 
            Output = testDir @@ example.Name + ".Tests.dll"
            FscTarget = FscTarget.Library
            References = [output;nunitDir @@ "nunit.framework.dll"] }
    Fsc setTestOpts (fromExampleDir example.TestSourceFiles)
)
</code></pre>

<p>```</p>

<p>You will need to add your example to the <code>examples</code> list at the top of the target. <code>Name</code> is the name of the dll that will be produced for your type provider. <code>ProviderSourceFiles</code> is the fsx file with your type provider example code. And <code>TestSourceFiles</code> is the code of your tests.</p>

<p>If you check further down, the call to the compiler to compile your provider will automatically prepend the ProvidedTypes files, so there&rsquo;s no need to list those. And the call to the compiler to run your tests will have references added for the provider you just built and <code>nunit.framework.dll</code>.</p>

<p>So what are you waiting for? Get writing some examples!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modelling Inheritance with Inheritance]]></title>
    <link href="http://blog.mavnn.co.uk/modelling-inheritance-with-inheritance/"/>
    <updated>2014-12-18T12:01:41+00:00</updated>
    <id>http://blog.mavnn.co.uk/modelling-inheritance-with-inheritance</id>
    <content type="html"><![CDATA[<blockquote><p>This post is part of the <a href="https://sergeytihon.wordpress.com/tag/fsadvent/">F# Advent Calendar</a> 2014, which is stuffed full of other interesting posts. Go have a read!</p></blockquote>

<p>Note: This post is epic in length. If you just want to see the final resulting script of much silliness, skip straight to <a href="#conclusion">the conclusion</a>!</p>

<p>Note 2: If you just want to see an example of a sane generated type provider, <a href="https://github.com/mavnn/FPDays.TypeProvider/">the code from my FPDays tutorial</a> is a much better bet.</p>

<p>Note 3: There is a lot of code below. If you&rsquo;re viewing this on a desktop, I suggest collapsing the sidebar to the right otherwise you&rsquo;ll have a lot of horizontal scroll bars. If you&rsquo;re on a mobile device, you might want to bookmark for later.</p>

<p>So&hellip; I&rsquo;ve been playing with generated (not erased) type providers for a bit, and meaning to write something up about them. Most of the documentation out there is for erased type providers, and to be honest they have a lot of advantages in terms of performance.</p>

<p>But they also have two fundamental limitations:</p>

<ul>
<li>You can&rsquo;t used erased F# types in any other .net language</li>
<li>You can&rsquo;t use reflection on erased types (even in F#)</li>
</ul>


<p>So let&rsquo;s see if we can have a play with generated types, and then &ndash; given this is Christmas, and all &ndash; let&rsquo;s see if we can build Jesus' family tree in the .net type system. After all, if you&rsquo;re going to use inheritance to model something, how about modelling inheritance?</p>

<!-- more -->


<blockquote><p>If you need a reminder of type provider basics, check out <a href="http://blog.mavnn.co.uk/type-providers-from-the-ground-up/">Type Providers from the Ground Up</a></p></blockquote>

<p>Let&rsquo;s start with a really basic example of a generative type provider. We&rsquo;ll just create a single type with a static property on it.</p>

<p>First, our input. We&rsquo;re going to grab <a href="https://www.biblegateway.com/passage/?search=matthew+1%3A2-16&amp;version=NIV">the genealogy of Jesus from Matthew</a> and then massage the content just enough that the first name on each line is a &ldquo;parent&rdquo;, and any other names on a line are&hellip; other people. We&rsquo;ll assume they&rsquo;re siblings, although actually not all of them are.</p>

<pre><code>Abraham was the father of Isaac,
Isaac the father of Jacob,
Jacob the father of Judah and his brothers,
Judah the father of Perez and Zerah, whose mother was Tamar,
Perez the father of Hezron,
Hezron the father of Ram,
Ram the father of Amminadab,
... (some other people here) ...
Akim the father of Elihud,
Elihud the father of Eleazar,
Eleazar the father of Matthan,
Matthan the father of Jacob,
Jacob the father of Joseph, the husband of Mary, 
and Mary was the mother of Jesus who is called the Messiah.
</code></pre>

<p>For round one, we&rsquo;re just going to put this string into a type as a property.</p>

<p>Our type provider file looks a bit like this:</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()</p>

<p>```</p>

<p>What&rsquo;s with the <code>#if INTERACTIVE</code> bits? Well, that&rsquo;ll be the subject of another blog post soon; I&rsquo;m doing must of my type provider dev in Vim these days to avoid the Visual Studio restart cycle, so I thought I might as well skip the fsproj file completely.</p>

<p>In the actual provider itself, there&rsquo;s a few new things to note if you&rsquo;ve only previously done erased type provider development.</p>

<p>```fsharp</p>

<pre><code>let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath
</code></pre>

<p>```</p>

<p>Generative type providers, unlike erased type providers, actually pass IL (.net byte code) to the compiler rather than just a quotation. To achieve that, we need to write the IL into an actual assembly that the compiler will then merge into the dll it&rsquo;s compiling.</p>

<p>Let&rsquo;s try that again, slower. The compiler will be building a piece of code that uses your type provider into <code>Output.dll</code>. It will call into your type provider, which needs to write the IL of the type/codes it&rsquo;s generating to disk into <code>Temp.dll</code>. The compiler will then take the IL from <code>Temp.dll</code> and insert it into <code>Output.dll</code>. At this point, we have no further use for <code>Temp.dll</code>, hence why we&rsquo;re using <code>GetTempFileName</code> to get a file in the OS temporary file
folder.</p>

<p>The <code>ProvidedTypes</code> API knows how to create these temporary dlls, so we wrap our filename in the <code>ProvidedAssembly</code> type.</p>

<p>```fsharp</p>

<pre><code>do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>```</p>

<p>We also need to specify which types need adding to the temporary assembly. Here we&rsquo;re specifying that the parameterized type (the one that takes a filename) should be added; on line 46 of the main code you&rsquo;ll see the type generated when a parameter is supplied being added. We also need to tell the type provider where the runtime dll is being created &ndash; fortunately, a helper method works this out for us when given the config item from the type provider constructor.</p>

<p>It&rsquo;s important to note that nested types <em>should not</em> be added to the temporary assembly. That&rsquo;s handled by adding the root.</p>

<p>So, if you compile this code down you can invoke it like this:</p>

<p>```fsharp</p>

<h1>!/usr/bin/env fsharpi</h1>

<p>// Put all of this in a file called something like Families.fsx
// Yes, that hashbang line means if you make it executable it
// will run on linux/mac</p>

<h1>r @&ldquo;AdventProvider.dll&rdquo;</h1>

<p>open AdventProvider
open Advent.Provided</p>

<p>type JesusGenerations = Family&lt;&ldquo;Genealogy.txt&rdquo;></p>

<p>printfn &ldquo;%s&rdquo; JesusGenerations.Raw
```</p>

<p>Excellent! A real, valid .net type. You can only invoke the type provider from F#, but the types generated are usable across the .net language universe &ndash; and reflection works fine.</p>

<p>So&hellip; phase two. Let&rsquo;s see if we can parse something sane out of our plain text mess to turn into types. I&rsquo;m not going to go into this in detail, but because I wanted to avoid the complication of external dependencies I just wrote a very simple regex based parser for this.</p>

<p>Behold! The <code>Parser.fs</code> file:</p>

<p>```fsharp
module Parser
open System.Text.RegularExpressions</p>

<p>type Person =</p>

<pre><code>{
    Name : string
    Heir : Person option
    Others : string list
}
</code></pre>

<p>let namesRegex = Regex(@&ldquo;(?<name>[A-Z][a-z]+)&rdquo;, RegexOptions.Compiled)</p>

<p>let ParseToNames line =</p>

<pre><code>namesRegex.Matches(line)
|&gt; Seq.cast&lt;Match&gt;
|&gt; Seq.map (fun m -&gt; m.Groups.["name"].Value)
|&gt; Seq.filter (fun n -&gt; n &lt;&gt; "King" &amp;&amp; n &lt;&gt; "Messiah" &amp;&amp; n &lt;&gt; "Babylon")
|&gt; Seq.toList
|&gt; function h::t -&gt; h, t | [] -&gt; failwith "No blank lines!"
</code></pre>

<p>let rec NamesToPerson names =</p>

<pre><code>match names with
| [] -&gt; None
| (father,others)::t -&gt;
    let heir =
        match t with
        | [] -&gt; None
        | (heir, _)::_ -&gt; Some heir
    Some {
        Name = father
        Heir = NamesToPerson t
        Others =
            others
            |&gt; List.filter
                (fun c -&gt;
                    match heir with
                    | Some h -&gt; c &lt;&gt; h
                    | None -&gt; true)
    }
</code></pre>

<p>let Parse lines =</p>

<pre><code>lines
|&gt; List.map ParseToNames
|&gt; NamesToPerson
</code></pre>

<p>```</p>

<p>Nb. Never, ever, ever build a parser like this for production code. Treat this as a &ldquo;how not to build a parser&rdquo; example, and go read something like <a href="http://trelford.com/blog/post/parser.aspx">Phil&rsquo;s excellent parsing posts</a> instead.</p>

<p>So&hellip; what can we do this this?</p>

<p>Let&rsquo;s start be parsing our file, and seeing if we can build a nested set of types representing the family tree.</p>

<p>Recursive type building! Go!</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>load &ldquo;Parser.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open Parser</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile
            let input =
                raw
                |&gt; Seq.toList
                |&gt; Parse

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)
            g.SetAttributes (TypeAttributes.Public ||| TypeAttributes.Class)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            let rec personToType (father : ProvidedTypeDefinition) (person : Person) =
                let t = ProvidedTypeDefinition(person.Name, Some (father :&gt; System.Type), IsErased = false)
                t.SetAttributes (TypeAttributes.Class ||| TypeAttributes.Public)
                father.AddMember t
                match person.Heir with
                | Some p -&gt; personToType t p
                | None -&gt; ()

            match input with
            | Some p -&gt;
                personToType g p
            | None -&gt;
                ()

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>It&rsquo;s not looking too bad&hellip; but we&rsquo;re also getting our first hint of trouble to come. The first time I tried to use this provider, I didn&rsquo;t have lines 46 and 55. It turns out that the default attributes of a <code>ProvidedTypeDefinition</code> set the <code>Sealed</code> attribute on the class that&rsquo;s generated. If you then try and build a type that inherits from it, you get an error when you try and consume the types from the provider.</p>

<p>But, hey? We&rsquo;ve worked around that, right? I&rsquo;m sure there&rsquo;s no reason it&rsquo;s set that way by default&hellip;</p>

<p>And: we have types. Lots of types:</p>

<p>```fsharp</p>

<h1>!/usr/bin/env fsharpi</h1>

<h1>r @&ldquo;AdventProvider.dll&rdquo;</h1>

<p>open AdventProvider
open Advent.Provided</p>

<p>type JesusGenerations = Family&lt;&ldquo;Genealogy.txt&rdquo;></p>

<p>printfn &ldquo;%s&rdquo; JesusGenerations.Raw</p>

<p>JesusGenerations.Abraham.Isaac.Jacob.Judah.Perez.Hezron.Ram.Amminadab
// &hellip; there&rsquo;s more where that came from
```</p>

<p>We can even do things like this:</p>

<p>```fsharp
let DescendedFromAbraham (person : JesusGenerations.Abraham) =</p>

<pre><code>true
</code></pre>

<p>```</p>

<p>Compile time family tree checking &ndash; pretty nifty. Except&hellip; when we try and call this function we realise we have a problem. None of these classes have constructors.</p>

<p>Hmmm.</p>

<p>Let&rsquo;s try and add one. Nothing fancy &ndash; just a default constructor.</p>

<p>We&rsquo;ll replace the <code>personToType</code> method with this:</p>

<p>```fsharp
let rec personToType (father : ProvidedTypeDefinition) (person : Person) =</p>

<pre><code>let t = ProvidedTypeDefinition(person.Name, Some (father :&gt; System.Type), IsErased = false)
t.SetAttributes (TypeAttributes.Class ||| TypeAttributes.Public)
let c = ProvidedConstructor([])
c.InvokeCode &lt;-
    fun args -&gt;
        match args with
        | [] -&gt;
            failwith "Generated constructors should always pass the instance as the first argument!"
        | _ -&gt;
            &lt;@@ () @@&gt;
t.AddMember c
father.AddMember t
match person.Heir with
| Some p -&gt; personToType t p
| None -&gt; ()
</code></pre>

<p>```</p>

<p>All looks good. In here you can see one of the first differences between erased and generated type. For a generated type, the first input arg to the constructor is the instance of the type to be initialized &ndash; and the return type of the constructor should be null.</p>

<p>The only problem is that our type provider errors immediately on usage with an &ldquo;Argument cannot be null. Parameter name: obj&rdquo; error. Not immediately informative.</p>

<p>A quick check with a type provider providing a single type later, we can confirm that the constructor above is valid; sounds like we&rsquo;re having issues with the fact that we&rsquo;re inheriting from a provided type. Maybe they&rsquo;re sealed for a reason after all. Still; we&rsquo;re not to be deterred so easily!</p>

<p><em>Cue dramatic music of choice!</em></p>

<p>Taking an guess, we&rsquo;ll assume this might have something to do with the <code>JesusGenerations</code> type not having a constructor; we&rsquo;ll add one and try again and&hellip; no dice. Same error.</p>

<p>Which is round about the time I noticed that provided constructors also have a <code>BaseConstructorCall</code> property. Time for a slightly more invasive rewrite, leaving us an overall type provider that looks like this:</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>load &ldquo;Parser.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open Parser</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile
            let input =
                raw
                |&gt; Seq.toList
                |&gt; Parse

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)
            g.SetAttributes (TypeAttributes.Public ||| TypeAttributes.Class)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            let c = ProvidedConstructor([])
            c.InvokeCode &lt;-
                fun args -&gt;
                    match args with
                    | [] -&gt;
                        failwith "Generated constructors should always pass the instance as the first argument!"
                    | _ -&gt;
                        &lt;@@ () @@&gt;
            g.AddMember c

            let rec personToType (father : ProvidedTypeDefinition) fatherCtor (person : Person) =
                let t = ProvidedTypeDefinition(person.Name, Some (father :&gt; System.Type), IsErased = false)
                t.SetAttributes (TypeAttributes.Class ||| TypeAttributes.Public)
                let c = ProvidedConstructor([])
                c.BaseConstructorCall &lt;- fun args -&gt; (fatherCtor, args)
                c.InvokeCode &lt;-
                    fun args -&gt;
                        match args with
                        | [] -&gt;
                            failwith "Generated constructors should always pass the instance as the first argument!"
                        | _ -&gt;
                            &lt;@@ () @@&gt;
                t.AddMember c
                father.AddMember t
                match person.Heir with
                | Some p -&gt; personToType t c p
                | None -&gt; ()

            match input with
            | Some p -&gt;
                personToType g c p
            | None -&gt;
                ()

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>It all builds, we can reference it&hellip; and then we get:</p>

<pre><code>The type provider 'AdventProvider+AdventProvider' reported an error: User defined subclasses of System.Type are not yet supported
</code></pre>

<p>Hmm. Irritating. Especially as the error message is actually incorrect; we&rsquo;re not subclassing System.Type and we know that that was working correctly as the types were being generated correctly before we tried to add constructors to them. But it looks like we might have hit the limits of what the current type provider implementation allows.</p>

<p>But we&rsquo;re still not quite done yet; let&rsquo;s turn the insanity up a notch.</p>

<p><em>Cue your choice of even more dramatic music or Benny Hill here</em></p>

<p>As well as actual inheritance in .net, we have interfaces which can be used to model inheritance. Let&rsquo;s have a last throw of the dice, and see whether we can create generated interfaces to do compile time ancestry checking.</p>

<p>Adding an <code>Interface</code> at every level turns out to be fairly easy, and it appears we can create generated interfaces &ndash; a useful trick to have up your sleeve. Let&rsquo;s have a look what that looks like:</p>

<p>```fsharp
module AdventProvider</p>

<h1>if INTERACTIVE</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fsi&rdquo;</h1>

<h1>load &ldquo;paket-files/fsprojects/FSharp.TypeProviders.StarterPack/src/ProvidedTypes.fs&rdquo;</h1>

<h1>load &ldquo;Parser.fs&rdquo;</h1>

<h1>endif</h1>

<p>open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices
open Microsoft.FSharp.Quotations
open Parser</p>

<p>[<TypeProvider>]
type AdventProvider (cfg : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "Advent.Provided"
let asm = Assembly.GetExecutingAssembly()
let tempAsmPath = System.IO.Path.ChangeExtension(System.IO.Path.GetTempFileName(), ".dll")
let tempAsm = ProvidedAssembly tempAsmPath

let t = ProvidedTypeDefinition(asm, ns, "Family", Some typeof&lt;obj&gt;, IsErased = false)
let parameters = [ProvidedStaticParameter("Genealogy", typeof&lt;string&gt;)]

do
    t.DefineStaticParameters(
        parameters,
        fun typeName args -&gt;
            let genealogy = args.[0] :?&gt; string
            let inputFile = 
                System.IO.Path.Combine(cfg.ResolutionFolder, genealogy)
            let raw =
                System.IO.File.ReadAllLines inputFile
            let input =
                raw
                |&gt; Seq.toList
                |&gt; Parse

            let g = ProvidedTypeDefinition(
                        asm, 
                        ns, 
                        typeName, 
                        Some typeof&lt;obj&gt;, 
                        IsErased = false)

            let s = ProvidedProperty("Raw", typeof&lt;string&gt;, IsStatic = true)
            let rawStr = String.concat "\n" raw
            s.GetterCode &lt;- fun _ -&gt; Expr.Value rawStr
            g.AddMember s

            let rec personToType (father : ProvidedTypeDefinition) (fatherInterfaces : System.Type list) (person : Person) =
                let t = ProvidedTypeDefinition(person.Name, Some typeof&lt;obj&gt;, IsErased = false)
                let parentInterface =
                    match fatherInterfaces with
                    | [] -&gt; None
                    | h::_ -&gt; Some h
                let i = ProvidedTypeDefinition("I" + person.Name, None, IsErased = false)
                i.SetAttributes (TypeAttributes.Public ||| TypeAttributes.Interface ||| TypeAttributes.Abstract)
                father.AddMembers [t;i]
                match person.Heir with
                | Some p -&gt; personToType t (i :&gt; System.Type::fatherInterfaces) p
                | None -&gt; ()

            match input with
            | Some p -&gt;
                personToType g [] p
            | None -&gt;
                ()

            tempAsm.AddTypes [g]

            g
        )

do
    this.RegisterRuntimeAssemblyLocationAsProbingFolder cfg
    tempAsm.AddTypes [t]
    this.AddNamespace(ns, [t])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>Line 58 and 59 do all the work &ndash; normally an interface has no base type, and we need to reset the type attributes to make the interface look like an interface to the compiler. This all works well &ndash; but doesn&rsquo;t, of course, give us any inheritance. Lets see if we can use those &ldquo;fatherInterfaces&rdquo; I&rsquo;ve fed into the function to get us any closer.</p>

<p>A brief experiment with <code>IDisposable</code> shows us that if we change the base type of the interface to <code>Some typeof&lt;System.IDisposable&gt;</code>, that actually works. Again &ndash; useful type provider knowledge, but doesn&rsquo;t help us here. No dice on using the parent interface as the base type &ndash; we just start getting into more of the problems we were having above inheriting from other generated types.</p>

<p>So let&rsquo;s see what happens if instead we use implement interface instead of trying to inherit the interface; it seems about as reasonable as anything else we&rsquo;re tried so far&hellip;</p>

<p>We&rsquo;ll add this:</p>

<p><code>fsharp
fatherInterfaces
|&gt; List.iter i.AddInterfaceImplementation
</code></p>

<p>after line 59 of the version above and see what happens.</p>

<h2><a name="conclusion"></a> Conclusion</h2>

<p>And suddenly&hellip; hey presto! We can do things like this:</p>

<p>```fsharp</p>

<h1>!/usr/bin/env fsharpi</h1>

<h1>r @&ldquo;AdventProvider.dll&rdquo;</h1>

<p>open AdventProvider
open Advent.Provided</p>

<p>type JesusGenerations = Family&lt;&ldquo;Genealogy.txt&rdquo;></p>

<p>printfn &ldquo;%s&rdquo; (JesusGenerations.Raw.Substring(0, 20) + &ldquo;&hellip;&rdquo;)</p>

<p>let descendentOfAbraham (_ : #JesusGenerations.IAbraham) = true
let descendentOfDavid</p>

<pre><code>    (_ : 
        #JesusGenerations
            .Abraham
            .Isaac
            .Jacob
            .Judah
            .Perez
            .Hezron
            .Ram
            .Amminadab
            .Nahshon
            .Salmon
            .Boaz
            .Obed
            .Jesse
            .IDavid) = true
</code></pre>

<p>// This compiles&hellip;
printfn &ldquo;%A&rdquo; &lt;| descendentOfAbraham ({ new JesusGenerations.Abraham.IIsaac })</p>

<p>// So does this:
printfn &ldquo;%A&rdquo; &lt;|</p>

<pre><code>descendentOfDavid 
    ({ new JesusGenerations
            .Abraham
            .Isaac
            .Jacob
            .Judah
            .Perez
            .Hezron
            .Ram
            .Amminadab
            .Nahshon
            .Salmon
            .Boaz
            .Obed
            .Jesse
            .David
            .Solomon
            .Rehoboam
            .IAbijah })
</code></pre>

<p>// This doesn&rsquo;t &ndash; how cool is that?
(* printfn &ldquo;%A&rdquo; &lt;|</p>

<pre><code>descendentOfDavid ({ new JesusGenerations.Abraham.IIsaac }) *)
</code></pre>

<p>```</p>

<p>Which personally I think is pretty awesome.</p>

<p>There is, unfortunately, only one problem. Whilst we now have compile time propositional logic&hellip; unfortunately our code fails at runtime with a type load error. Whilst the compiler is happy with the IL my random hacking has turned at, apparently the runtime is not.</p>

<p>Maybe next year&hellip;</p>

<p>I hope you enjoyed this random journey down the rabbit hole of type providers; and if you&rsquo;re interested in looking into the genealogy a bit further <a href="http://christianity.about.com/od/biblefactsandlists/a/jesusgenealogy.htm">this article</a> gives a brief overview of a few things, like why we think Jesus has two different genealogies in the bible and how Jewish genealogies didn&rsquo;t always include every generation.</p>

<p>See you next time: and if anyone can get the inheritance to work properly, I&rsquo;ll owe you a beverage of (reasonable) choice!</p>

<p>The code from this blog post can, as normal be found on github in the <a href="https://github.com/mavnn/Advent2014">Advent2014</a> repository.</p>

<p>It&rsquo;s set up to be developed in Vim or Emacs without project files on a nix system, but it will probably play nicely with Visual Studio as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Type safe printf via Type Providers]]></title>
    <link href="http://blog.mavnn.co.uk/type-safe-printf-via-type-providers/"/>
    <updated>2014-05-06T15:33:15+01:00</updated>
    <id>http://blog.mavnn.co.uk/type-safe-printf-via-type-providers</id>
    <content type="html"><![CDATA[<p><a href="http://twitter.com/puffnfresh">Brian McKenna</a> posted an interesting <a href="http://www.youtube.com/watch?v=fVBck2Zngjo">video</a> and <a href="https://gist.github.com/puffnfresh/11202637">gist</a> on implementing a type safe printf in Idris with dependent types.</p>

<p>This led me down a nice little rabbit hole wondering if something similar could be achieved with an F# type provider.</p>

<p>With a <a href="http://stackoverflow.com/questions/23375469/how-can-i-build-an-arbitary-curried-function-in-an-f-type-provider">bit of help from Tomas</a> the final solution turned out to be surprisingly nice, although not quite so clean as the Idris original.</p>

<!-- more -->


<p>Taking the format string and parsing it looks very similar to the Idris version, what with the common ML history of the two languages:</p>

<p>```fsharp
type Format =</p>

<pre><code>| FString of Format
| FInt of Format
| Other of char * Format
| End
</code></pre>

<p>let parseFormatString str =</p>

<pre><code>let rec parseFormat chars =
    match chars with
    | '%'::'d'::t -&gt; FInt (parseFormat t)
    | '%'::'s'::t -&gt; FString (parseFormat t)
    | c::t -&gt; Other (c, parseFormat t)
    | [] -&gt; End
parseFormat (Seq.toList str)
</code></pre>

<p>```</p>

<p>This might not be the most efficient or flexible parsing method, but that&rsquo;s not really the point of the current exercise and it&rsquo;s very clear what it&rsquo;s doing.</p>

<p>Next, we want to create a <a href="http://msdn.microsoft.com/en-us/library/dd233212.aspx">quotation</a> that represents a curried function based on our format type. This is where I needed Tomas' help &ndash; it turns out there isn&rsquo;t any easy way to do this with the <code>&lt;@@ ... @@&gt;</code> syntax I&rsquo;ve usually used to build quotations for type providers.</p>

<p>Tomas reminded me that the <code>Microsoft.FSharp.Quotations</code> namespace gives direct access to the underlying classes that represent the expression tree of the quotation. This allows us to build an expression tree recusively; check out <a href="http://stackoverflow.com/a/23375794/68457">Tomas' explanation</a>  of the technique for more details of how it works.</p>

<p>```fsharp
open System.Reflection
open Microsoft.FSharp.Quotations</p>

<p>(<em> &hellip; </em>)</p>

<p>let rec invoker printers format =</p>

<pre><code>match format with
| End -&gt;
    let arr = Expr.NewArray(typeof&lt;string&gt;, List.rev printers)
    let conc = typeof&lt;string&gt;.GetMethod("Concat", [|typeof&lt;string[]&gt;|])
    Expr.Call(conc, [arr])
| Other (c, t) -&gt;
    invoker (&lt;@@ string&lt;char&gt; c @@&gt; :: printers) t
| FInt t -&gt;
    let v = Var("v", typeof&lt;int&gt;)
    let printer = &lt;@@ string&lt;int&gt; (%%(Expr.Var v)) @@&gt;
    Expr.Lambda(v, invoker (printer::printers) t)
| FString t -&gt;
    let v = Var("v", typeof&lt;string&gt;)
    let printer = &lt;@@ %%(Expr.Var v):string @@&gt;
    Expr.Lambda(v, invoker (printer::printers) t)
</code></pre>

<p>```</p>

<p>That&rsquo;s the hard stuff out of the way! Now we just have some type provider boiler plate. We&rsquo;re going to provide a type provider named <code>TPrint</code> which takes a single parameter (our format string). Once the parameter is supplied, we provide a single static property which is an FSharpFunc type which matches the signature required by the format string.</p>

<p>```fsharp
open System.Reflection
open ProviderImplementation.ProvidedTypes
open Microsoft.FSharp.Core.CompilerServices</p>

<p>(<em> &hellip; </em>)</p>

<p>let toMethod format =</p>

<pre><code>let invokeCode =
    invoker [] format
let invokeType = invokeCode.Type
ProvidedProperty("show", invokeType, IsStatic = true, GetterCode = fun _ -&gt; invokeCode)
</code></pre>

<p>[<TypeProvider>]
type TPrintProvider (config : TypeProviderConfig) as this =</p>

<pre><code>inherit TypeProviderForNamespaces ()

let ns = "TypeSet.Provided"
let asm = Assembly.GetExecutingAssembly()

let tPrintProvider = ProvidedTypeDefinition(asm, ns, "TPrint", Some(typeof&lt;obj&gt;))

let parameters = [ProvidedStaticParameter("FormatString", typeof&lt;string&gt;)]

do tPrintProvider.DefineStaticParameters(parameters, fun typeName args -&gt;
    let formatString = args.[0] :?&gt; string

    let provider = ProvidedTypeDefinition(asm, ns, typeName, Some(typeof&lt;obj&gt;))
    provider.HideObjectMethods &lt;- true

    formatString |&gt; parseFormatString |&gt; toMethod |&gt; provider.AddMember

    provider
    )

do
    this.AddNamespace(ns, [tPrintProvider])
</code></pre>

<p>[&lt;assembly:TypeProviderAssembly>]
do ()
```</p>

<p>So, put it all together and you get a type provider which allows you to do this:</p>

<p>```fsharp
TPrint&lt;&ldquo;A %s string! %s %d&rdquo;>.show &ldquo;hello&rdquo; &ldquo;world&rdquo; 32
// val it : string = &ldquo;A hello string! world 32&rdquo;</p>

<p>TPrint&lt;&ldquo;Number one: %d! Number two: %d! A string: %s!&rdquo;>.show 1 2 &ldquo;My string!&rdquo;
// val it : string = &ldquo;Number one: 1! Number two: 2! A string: My string!!&rdquo;
```</p>

<p>So; nothing there that the built in <code>printf</code> doesn&rsquo;t already do for you. But, this does start opening up some options for providing much more idiomatic F# style APIs then I&rsquo;ve really seen so far from Type Providers, which tend to provide very OO style interfaces. Should be some interesting ideas in there to explore!</p>

<p>Full code can be found <a href="https://github.com/mavnn/TypeSet">at Github</a>.</p>
]]></content>
  </entry>
  
</feed>
